/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../externals/index.js":
/*!*****************************!*\
  !*** ../externals/index.js ***!
  \*****************************/
/***/ ((module) => {

module.exports = {
  externals: [{
    module: 'react',
    root: 'React',
    dist: 'react/umd/react.production.min.js'
  }, {
    module: 'react-dom',
    dependencies: ['react'],
    root: 'ReactDOM',
    dist: 'react-dom/umd/react-dom.production.min.js'
  }, {
    module: 'vue',
    root: 'Vue',
    dist: 'vue/dist/vue.min.js'
  }, {
    module: 'echarts',
    root: 'echarts',
    dist: 'echarts/dist/echarts.min.js'
  }, {
    module: 'echarts-gl',
    root: 'echarts-gl',
    dependencies: ['echarts'],
    dist: 'echarts-gl/dist/echarts-gl.min.js'
  }, {
    module: 'highcharts',
    root: 'Highcharts',
    dist: 'highcharts/highcharts.js'
  }, {
    module: 'highcharts/highstock',
    root: 'Highcharts',
    dist: 'highcharts/highstock.js'
  }, {
    module: 'highcharts/highcharts-more',
    dependencies: ['highcharts'],
    dist: 'highcharts/highcharts-more.js'
  }, {
    module: 'highcharts/highcharts-3d',
    dependencies: ['highcharts'],
    dist: 'highcharts/highcharts-3d.js'
  }, {
    module: 'highcharts/modules/funnel3d',
    dependencies: ['highcharts'],
    dist: 'highcharts/modules/funnel3d.js'
  }, {
    module: 'highcharts/modules/cylinder',
    dependencies: ['highcharts'],
    dist: 'highcharts/modules/cylinder.js'
  }, {
    module: 'highcharts/modules/treemap',
    dependencies: ['highcharts'],
    dist: 'highcharts/modules/treemap.js'
  }, {
    module: 'bizcharts',
    root: 'BizCharts',
    dist: 'bizcharts/umd/BizCharts.min.js'
  }, {
    module: 'react-highcharts',
    dependencies: ['highcharts'],
    root: 'ReactHighcharts',
    dist: 'react-highcharts/ReactHighcharts.js'
  }, {
    module: 'snapsvg',
    root: 'Snap',
    dist: 'snapsvg/dist/snap.svg-min.js'
  }, {
    module: '@antv/data-set',
    root: 'DataSet',
    dist: '@antv/data-set/dist/data-set.js'
  }, {
    module: '@ant-design/icons',
    root: 'icons',
    dependencies: ['antd'],
    dist: '@ant-design/icons/dist/index.umd.min.js'
  }, {
    module: 'moment/locale/zh-cn',
    root: 'moment_locale_zh-cn',
    dist: 'moment/locale/zh-cn.js',
    dependencies: ['moment']
  }, {
    module: 'moment',
    root: 'moment',
    dist: 'moment/min/moment-with-locales.min.js'
  }, {
    module: 'antd/dist/antd.css',
    root: 'antd_css'
  }, {
    module: 'antd/dist/antd-with-locales',
    root: 'antd'
  }, {
    module: 'antd',
    root: 'antd',
    dependencies: ['react', 'react-dom', 'moment'],
    dist: 'antd/dist/antd.min.js',
    style: 'antd/dist/antd.variable.min.css'
  }, {
    module: 'lodash',
    root: '_',
    dist: 'lodash/lodash.min.js'
  }, {
    module: 'axios',
    root: 'axios',
    dist: 'axios/dist/axios.min.js'
  }, {
    module: 'html2canvas',
    root: 'html2canvas',
    dist: 'html2canvas/dist/html2canvas.min.js'
  }, {
    module: '@douyinfe/semi-ui',
    root: 'SemiUI',
    dependencies: ['react', 'react-dom'],
    style: '@douyinfe/semi-ui/dist/css/semi.min.css',
    dist: '@douyinfe/semi-ui/dist/umd/semi-ui.min.js'
  }]
};

/***/ }),

/***/ "./src/Ridge.js":
/*!**********************!*\
  !*** ./src/Ridge.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _loader_ElementLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader/ElementLoader */ "./src/loader/ElementLoader.js");
/* harmony import */ var _element_PageElementManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./element/PageElementManager */ "./src/element/PageElementManager.js");


/**
 * The Ridge Platform Runtime
 */

class Ridge {
  constructor(opts = {}) {
    const baseUrl = opts.baseUrl ?? '/npm_packages';
    const unpkgUrl = opts.unkpgUrl ?? baseUrl;
    const debugUrl = opts.debugUrl;
    this.loader = new _loader_ElementLoader__WEBPACK_IMPORTED_MODULE_0__["default"]({
      baseUrl,
      debugUrl,
      unpkgUrl
    });
    this.pageElementManagers = {};
  }

  static async load(json) {
    const instance = new Ridge();
    window.ridge = instance;
    const jsonObject = await instance.loader.loadJSON(json);
    instance.loadPage(null, jsonObject);
  }
  /**
   * 通用库功能： 加载组件
   * @param {String} componentPath 组件路径
   * @returns 组件定义信息
   */


  loadComponent(componentPath) {
    return this.loader.loadComponent(componentPath);
  }

  loadPage(el, pageConfig) {
    const pageManager = new _element_PageElementManager__WEBPACK_IMPORTED_MODULE_1__["default"](JSON.parse(JSON.stringify(pageConfig)), this);
    pageManager.mount(el || document.body);
    return pageManager;
  }

  createPageManager(pageConfig) {
    const pageManager = new _element_PageElementManager__WEBPACK_IMPORTED_MODULE_1__["default"](pageConfig, this);
    return pageManager;
  }

  getPageElementManager(id) {
    return this.pageElementManagers[id];
  }

  registerMethod(name, method) {
    this[name] = method;
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Ridge);

/***/ }),

/***/ "./src/element/ElementWrapper.js":
/*!***************************************!*\
  !*** ./src/element/ElementWrapper.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _render_ReactRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/ReactRenderer */ "./src/render/ReactRenderer.js");
/* harmony import */ var _render_VanillaRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/VanillaRenderer */ "./src/render/VanillaRenderer.js");
/* harmony import */ var _template__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../template */ "./src/template.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/set */ "../../node_modules/lodash/set.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_4__);





const log = debug__WEBPACK_IMPORTED_MODULE_0___default()('ridge:el-wrapper');
const error = debug__WEBPACK_IMPORTED_MODULE_0___default()('ridge:error');
/**
 * 组件封装类
 */

class ElementWrapper {
  constructor({
    config,
    pageManager
  }) {
    this.config = config;
    this.id = config.id;
    this.componentPath = config.path;
    this.pageManager = pageManager; // 系统内置属性

    this.systemProperties = {
      __ridge: pageManager.ridge,
      __pageManager: pageManager,
      __elementWrapper: this
    }; // 存放计算值、运行时配置更新值

    this.properties = {}; // 组件的scope值数据

    this.scopeVariableValues = {};
  }

  setMode(mode) {
    this.mode = mode;
    this.systemProperties.__mode = mode;
    this.forceUpdate();
  }

  isRoot() {
    return this.config.parent == null;
  }
  /**
   * 复制组件实例
   * @returns
   */


  clone() {
    const cloned = new ElementWrapper({
      config: this.toJSON(),
      pageManager: this.pageManager
    });

    if (this.componentDefinition) {
      cloned.componentDefinition = this.componentDefinition;
      cloned.preloaded = true;
    }

    if (cloned.config.props.children) {
      cloned.config.props.children = cloned.config.props.children.map(wrapperId => {
        const templateNode = this.pageManager.getElement(wrapperId);
        const clonedChild = templateNode.clone();
        clonedChild.parentWrapper = cloned;
        return clonedChild;
      });
    } // TODO


    return cloned;
  }
  /**
   * 加载组件代码、按代码初始化属性
   */


  async preload(deepPreload) {
    if (this.preloaded) return;
    this.setStatus('Loading');
    this.componentDefinition = await this.loadComponentDefinition();

    if (deepPreload) {
      if (this.config.props.children) {
        for (const childId of this.config.props.children) {
          const childWrapper = this.pageManager.getElement(childId);
          await childWrapper.preload(deepPreload);
        }
      }
    }

    if (this.componentDefinition) {
      this.removeStatus('Loading');
      this.preloaded = true;
    } else {
      this.setStatus('Error');
    }
  }

  async loadComponentDefinition() {
    // 加载组件定义信息
    if (this.componentPath) {
      const componentDefinition = await this.pageManager.ridge.loadComponent(this.componentPath);

      if (!componentDefinition || !componentDefinition.component) {
        log('加载图元失败: 未获取组件', this.componentPath);
        this.setStatus('加载失败');
        return null;
      }

      return componentDefinition;
    }
  }

  appendChild(wrapper) {
    this.children.push(wrapper);
  }
  /**
   * 初始化组件属性、事件
   */


  initPropsAndEvents() {
    this.slotProps = [];

    if (this.config.parent && !this.parentWrapper) {
      this.parentWrapper = this.pageManager.getElement(this.config.parent);
    } // 枚举、处理所有属性定义


    for (const prop of this.componentDefinition.props || []) {
      // 编辑器初始化创建时给一次默认值
      if (this.config.isNew) {
        if (this.config.props[prop.name] == null && prop.value != null) {
          this.config.props[prop.name] = prop.value;
        }
      } // 处理属性的input情况 类似 vue的 v-model


      if (prop.name === 'value') {
        this.properties.input = val => {
          this.emit('input', val);
        };
      }

      if (prop.input === true) {
        // input相当于v-model，只能设置到一个属性上面
        const eventName = 'set' + prop.name.substr(0, 1).toUpperCase() + prop.name.substr(1); // 当双向绑定时， 获取动态绑定部分配置的属性值

        this.properties[eventName] = val => {
          this.emit(eventName, val);
        };
      }

      if (prop.name === 'children') {
        this.children = [];
        this.isContainer = true;
        this.el.classList.add('container'); // 写入子级的具体包装类

        if (Array.isArray(this.config.props.children)) {
          this.config.props.children = this.config.props.children.map(element => {
            if (typeof element === 'string') {
              return this.pageManager.getElement(element);
            } else {
              return element;
            }
          }).filter(child => child);
        }
      } else if (prop.type === 'slot') {
        this.isContainer = true;
        this.slotProps.push(prop.name); // 写入slot的包装类

        if (this.config.props[prop.name] && typeof this.config.props[prop.name] === 'string') {
          this.config.props[prop.name] = this.pageManager.getElement(this.config.props[prop.name]);
        }
      }
    } // 事件类属性写入，DOM初始化后事件才能挂到源头


    for (const event of this.componentDefinition.events || []) {
      this.properties[event.name] = (...args) => {
        this.emit(event.name, ...args);
      };
    }

    if (this.mode !== 'edit') {
      this.updateExpressionedProperties();
    }

    delete this.config.isNew;
  }

  isMounted() {
    return this.el != null;
  }
  /**
     * 执行组件初次加载 mount到具体DOM元素
     */


  mount(el) {
    this.el = el;
    this.el.classList.add('ridge-element');
    this.el.setAttribute('ridge-id', this.id);
    this.el.elementWrapper = this;
    this.forceUpdateStyle();

    if (!this.preloaded) {
      this.preload().then(() => {
        this.initPropsAndEvents();
        this.renderer = this.createRenderer();
      });
    } else {
      this.initPropsAndEvents();
      this.renderer = this.createRenderer();
    }
  }

  unmount() {
    if (this.children && this.children.length) {
      for (const childWrapper of this.children) {
        childWrapper.unmount();
      }
    }

    if (this.renderer) {
      this.renderer.destroy();
      this.renderer = null;
    }

    if (this.el) {
      this.el.parentElement.removeChild(this.el);
      this.el = null;
    }
  }
  /**
   * 调用组件依托的技术框架渲染内容
   * @returns
   */


  createRenderer() {
    try {
      if (this.componentDefinition.type === 'vanilla') {
        return new _render_VanillaRenderer__WEBPACK_IMPORTED_MODULE_2__["default"](this.componentDefinition.component, this.el, this.getProperties());
      } else {
        return new _render_ReactRenderer__WEBPACK_IMPORTED_MODULE_1__["default"](this.componentDefinition.component, this.el, this.getProperties());
      }
    } catch (e) {
      error('create render error', e);
    }

    return null;
  }

  getProperties() {
    return Object.assign({}, this.config.props, this.systemProperties, this.properties);
  }

  forceUpdateStyle() {
    if (this.el) {
      if (this.config.props.coverContainer) {
        this.el.style.width = '100%';
        this.el.style.height = '100%';
        this.el.style.position = 'absolute';
        this.el.style.left = 0;
        this.el.style.transform = '';
        this.el.style.top = 0;
      } else {
        this.el.style.width = this.config.style.width ? this.config.style.width + 'px' : '';
        this.el.style.height = this.config.style.height ? this.config.style.height + 'px' : '';
        this.el.style.position = this.config.style.position;

        if (this.config.style.position === 'absolute') {
          this.el.style.left = 0;
          this.el.style.top = 0;
          this.el.style.transform = `translate(${this.config.style.x}px, ${this.config.style.y}px)`;
        } else {
          this.el.style.transform = '';
        }
      }

      if (this.mode !== 'edit') {
        this.el.style.visibility = this.config.style.visible ? 'visible' : 'hidden';

        for (const styleName of Object.keys(this.config.styleEx || {})) {
          const value = (0,_template__WEBPACK_IMPORTED_MODULE_3__["default"])(this.config.styleEx[styleName], this.getVariableContext());

          if (styleName === 'width') {
            this.el.style.width = value + 'px';
          }

          if (styleName === 'visible') {
            this.el.style.visibility = value ? 'visible' : 'hidden';
          }
        }
      } else {
        this.el.style.visibility = 'visible';
      }
    }
  }

  updateProperties(props) {
    if (props) {
      Object.assign(this.properties, props);
    }

    if (this.renderer) {
      try {
        log('updateProps', this.id, this.properties);
        this.renderer.updateProps(this.getProperties());
      } catch (e) {
        log('用属性渲染组件出错', e);
      }
    } else {
      log('updateProps umounted', this.id);
    }
  }

  setScopeVariableValues(scopeVariableValues) {
    this.scopeVariableValues = scopeVariableValues;
  }

  updateScopeVariableValues(updated) {
    Object.assign(this.scopeVariableValues, updated);
  }

  getScopeVariableValues() {
    if (this.parentWrapper) {
      return Object.assign(this.parentWrapper.getScopeVariableValues(), this.scopeVariableValues);
    } else {
      return this.scopeVariableValues;
    }
  }
  /**
     * 获取当前组件可见的上下文变量信息
     */


  getVariableContext() {
    return Object.assign({}, this.pageManager.getVariableValues(), this.getScopeVariableValues());
  }
  /**
   * 强制重新计算属性并更新组件显示
   */


  async forceUpdateProps() {
    if (this.mode !== 'edit') {
      this.updateExpressionedProperties();
    }

    console.log('forceUpdate', this.properties);
    await this.updateProperties();
  }

  async forceUpdate() {
    this.forceUpdateStyle();
    this.forceUpdateProps();
  }
  /**
   * 计算所有表达式值
   */


  updateExpressionedProperties() {
    for (const propBindKey of Object.keys(this.config.propEx)) {
      if (this.hasExpression(propBindKey)) {
        this.properties[propBindKey] = (0,_template__WEBPACK_IMPORTED_MODULE_3__["default"])(this.config.propEx[propBindKey], this.getVariableContext());
      }
    }
  }

  hasExpression(propBindKey) {
    return this.config.propEx[propBindKey] !== '' && this.config.propEx[propBindKey] != null;
  }

  invoke(method, args) {
    return this.renderer.invoke(method, args);
  }
  /**
   * 组件根据对应变量变化进而进行重新布局或渲染
   * @param {*} variableNames 变动的变量Key
   */


  reactBy(variableNames) {
    if (this.configUseVariable(this.config.propEx, variableNames)) {
      this.forceUpdateProps();
    }

    if (this.configUseVariable(this.config.styleEx, variableNames)) {
      this.forceUpdateStyle();
    }
  }

  configUseVariable(config, variableNames) {
    let used = false;

    for (const expression of Object.values(config)) {
      if (used) break;

      for (const variableName of variableNames) {
        if (expression.indexOf(variableName) > -1) {
          used = true;
        }
      }
    }

    return used;
  }

  emit(eventName, payload) {
    if (eventName === 'input' && !this.config.events[eventName]) {
      // 处理双向绑定的情况
      if (this.config.propEx.value && Object.keys(this.getVariableContext()).indexOf(this.config.propEx.value) > -1) {
        this.pageManager.updatePageVariableValue({
          [this.config.propEx.value]: payload
        });
      }

      return;
    }

    if (this.config.events[eventName]) {
      // 处理input/value事件
      for (const action of this.config.events[eventName]) {
        if (action.name === 'setvar') {
          try {
            const variableContext = this.getVariableContext();
            const newVariableValue = (0,_template__WEBPACK_IMPORTED_MODULE_3__["default"])(action.value, variableContext);

            if (action.target.indexOf('.') > -1) {
              lodash_set__WEBPACK_IMPORTED_MODULE_4___default()(variableContext, action.target, newVariableValue);
            } else {
              this.pageManager.updatePageVariableValue({
                [action.target]: newVariableValue
              });
            }
          } catch (e) {
            log('Event Action[setvar] Error', e);
          }
        }
      }
    }
  }
  /**
   * 应用拦截器的拦截方法（异步）
   * @param {*} hookName
   */


  async applyDecorate(hookName) {
    if (this.pageManager && this.pageManager.decorators.element) {
      for (const decorator of this.pageManager.decorators.element) {
        try {
          decorator[hookName] && (await decorator[hookName](this));
        } catch (e) {}
      }
    }
  }
  /**
     * 为DOM元素绑定基础的交互事件
     * @param {*} el
     * @param {*} eventName
     */


  attachElEvent(el, eventName) {
    el[eventName] = event => {
      try {
        this.emit(eventName, this.componentConfig);
        event.stopPropagation();
      } catch (e) {
        console.error('事件处理异常', e);
      }

      return false;
    };
  }

  setStatus(status, el) {
    this.status = status;
    this.addMaskLayer({
      el: el || this.el,
      name: status,
      className: 'status-' + status,
      zIndex: -1
    });
  }

  removeStatus(status, el) {
    if (this.status === status) {
      this.status = null;
      this.removeMaskLayer(status, el || this.el);
    }
  }

  removeMaskLayer(name, el) {
    if (el && el.querySelector('[name="' + name + '"]')) {
      el.removeChild(el.querySelector('[name="' + name + '"]'));
    }
  }

  addMaskLayer({
    el,
    name,
    zIndex,
    className,
    text,
    content
  }) {
    if (!el) {
      return;
    }

    if (el.querySelector('[name="' + name + '"]')) {
      return;
    }

    const layer = document.createElement('div');
    layer.setAttribute('name', name);
    layer.classList.add('layer');
    layer.style.position = 'absolute';
    layer.style.left = 0;
    layer.style.right = 0;
    layer.style.top = 0;
    layer.style.bottom = 0;

    if (className) {
      layer.classList.add(className);
    }

    if (zIndex) {
      layer.style.zIndex = zIndex;
    }

    layer.innerHTML = content || text || '';
    el.appendChild(layer);
  }
  /**
   * 修改组件配置的样式信息
   * @param {*} style
   */


  setStyle(style) {
    Object.assign(this.config.style, style);
    this.forceUpdateStyle();
  }
  /**
     * 组件配置信息发生改变，通过编辑器配置面板传入
     * @param {*} values
     * @param {*} field
     */


  setPropsConfig(values, field) {
    for (const keyPath of Object.keys(field)) {
      const [type, key] = keyPath.split('.');

      if (type === 'props') {
        Object.assign(this.config.props, {
          [key]: field[keyPath]
        });
      }

      if (type === 'style') {
        this.setStyle({
          [key]: field[keyPath]
        });
      }

      if (type === 'propsEx') {
        Object.assign(this.config.propEx, {
          [key]: field[keyPath]
        });
      }

      if (type === 'styleEx') {
        Object.assign(this.config.styleEx, {
          [key]: field[keyPath]
        });
      }

      if (keyPath === 'title') {
        this.config.title = field[keyPath];
      }
    }

    this.forceUpdateStyle(); // 编辑时忽略动态配置的属性、事件

    this.applyDecorate('setPropsConfig').then(() => {
      this.forceUpdateProps();
    });
  }

  setEventsConfig(values, update) {
    Object.assign(this.config.events, values.event);
  }
  /**
     * 获取封装层样式，包括  x/y/width/height/visible/rotate
     * @returns
     */


  getStyle() {
    return this.config.style;
  }

  getChildrenIds() {
    return this.config.props.children || [];
  }
  /**
     * 计算获取插槽子元素
     * @returns Array 元素列表
     */


  getSlotChildren() {
    if (this.slotProps) {
      return this.slotProps.map(prop => {
        return {
          name: prop,
          element: this.config.props[prop]
        };
      });
    } else {
      return [];
    }
  }

  toJSON() {
    if (this.isContainer) {
      const result = Object.assign({}, this.config);
      result.props = Object.assign({}, this.config.props); // 保存时children及slotProp只保存id

      if (this.config.props.children) {
        result.props.children = this.config.props.children.filter(n => n).map(child => child.id);
      }

      for (const key of this.slotProps ?? []) {
        if (result.props[key]) {
          result.props[key] = result.props[key].id;
        }
      }

      return JSON.parse(JSON.stringify(result));
    } else {
      return JSON.parse(JSON.stringify(this.config));
    }
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ElementWrapper);

/***/ }),

/***/ "./src/element/PageElementManager.js":
/*!*******************************************!*\
  !*** ./src/element/PageElementManager.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ElementWrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ElementWrapper */ "./src/element/ElementWrapper.js");
/* harmony import */ var _utils_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/string */ "./src/utils/string.js");
/* harmony import */ var _utils_expr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/expr */ "./src/utils/expr.js");




class PageElementManager {
  constructor(pageConfig, ridge, wrapperClass) {
    this.pageConfig = pageConfig;
    this.ridge = ridge;
    this.decorators = {};
    this.ElementWrapper = wrapperClass || _ElementWrapper__WEBPACK_IMPORTED_MODULE_0__["default"];
    this.initialize();
  }
  /**
   * 根据页面配置读取页面控制对象结构
   * @param {Element} el DOM 根元素
   */


  initialize() {
    this.id = this.pageConfig.id;
    this.pageVariableValues = {};

    for (const variablesConfig of this.pageConfig.variables || []) {
      if ((0,_utils_string__WEBPACK_IMPORTED_MODULE_1__.trim)(variablesConfig.name)) {
        this.pageVariableValues[(0,_utils_string__WEBPACK_IMPORTED_MODULE_1__.trim)(variablesConfig.name)] = (0,_utils_expr__WEBPACK_IMPORTED_MODULE_2__.pe)(variablesConfig.value);
      }
    }

    this.pageElements = {};

    for (const element of this.pageConfig.elements) {
      const elementWrapper = new this.ElementWrapper({
        pageManager: this,
        config: element
      });
      this.pageElements[elementWrapper.id] = elementWrapper;
    }
  }

  getPageProperties() {
    return this.pageConfig.properties;
  }

  getVariableConfig() {
    return this.pageConfig.variables;
  }

  getVariableValues() {
    return this.pageVariableValues;
  }
  /**
   * 更新页面属性配置
   * @param {} properties
   */


  updatePageProperties(properties) {
    Object.assign(this.pageConfig.properties, properties);
    this.updateRootElStyle();
  }
  /**
   * 更新页面变量取值
   * @param {*} values 新的页面变量对
   */


  updatePageVariableValue(values) {
    Object.assign(this.pageVariableValues, values);
    this.updateVariableRelated(values);
  }
  /**
   * 更新页面变量配置
   * @param {*} name 名称
   * @param {*} value 变量值
   */


  updateVariableConfig(variablesConfig) {
    this.pageConfig.variables = variablesConfig;
    this.pageVariableValues = {};

    for (const pv of this.pageConfig.variables) {
      if ((0,_utils_string__WEBPACK_IMPORTED_MODULE_1__.trim)(pv.name)) {
        this.pageVariableValues[(0,_utils_string__WEBPACK_IMPORTED_MODULE_1__.trim)(pv.name)] = (0,_utils_expr__WEBPACK_IMPORTED_MODULE_2__.pe)(pv.value);
      }
    }

    this.forceUpdate();
  }

  getElement(id) {
    return this.pageElements[id];
  }

  getPageElements() {
    return this.pageElements;
  }
  /**
   * 挂载整个页面到body或者根元素
   * @param {Element} el 根元素
   */


  async mount(el) {
    for (const wrapper of Object.values(this.pageElements).filter(e => e.isRoot())) {
      const div = document.createElement('div');
      wrapper.mount(div);
      el.appendChild(div);
    }

    this.el = el;
    this.updateRootElStyle();
  }

  updateRootElStyle() {
    this.el.style.width = this.pageConfig.properties.width + 'px';
    this.el.style.height = this.pageConfig.properties.height + 'px';
  }

  async unmount() {
    for (const wrapper of Object.values(this.pageElements).filter(e => e.isRoot())) {
      wrapper.unmount();
    }
  }
  /**
   * 预加载及初始化页面内的元素
   */


  async preload() {
    const awaitings = [];

    for (const wrapper of this.pageElements) {
      awaitings.push(await wrapper.preload());
    }

    await Promise.allSettled(awaitings);
  }
  /**
   * 整页按照变量和动态数据完全更新
   */


  forceUpdate() {
    for (const element of Object.values(this.pageElements)) {
      element.forceUpdate();
    }
  }

  updateVariableRelated(variables) {
    const variableKeys = Object.keys(variables);

    for (const element of Object.values(this.pageElements)) {
      element.reactBy(variableKeys);
    }
  }

  setMode(mode) {
    for (const element of Object.values(this.pageElements)) {
      element.setMode(mode);
    }
  }
  /**
  * 从组件定义片段创建一个页面元素实例
  * @param {Object} fraction 来自
  * @returns
  */


  createElement(fraction) {
    // 生成组件定义
    const elementConfig = {
      title: fraction.title,
      id: (0,_utils_string__WEBPACK_IMPORTED_MODULE_1__.nanoid)(5),
      isNew: true,
      path: fraction.componentPath,
      style: {
        position: 'absolute',
        width: fraction.width ?? 100,
        height: fraction.height ?? 100
      },
      styleEx: {},
      props: {},
      propEx: {},
      events: {}
    };
    const wrapper = new _ElementWrapper__WEBPACK_IMPORTED_MODULE_0__["default"]({
      config: elementConfig,
      pageManager: this
    });
    wrapper.setMode('edit');
    this.pageElements[wrapper.id] = wrapper;
    return wrapper;
  }
  /**
   * 移出一个元素（递归进行）
   * @param {*} id
   */


  removeElement(id) {
    const element = this.pageElements[id];

    if (element) {
      for (const childId of element.getChildrenIds()) {
        this.removeElement(childId);
      }

      for (const slotChild of element.getSlotChildren()) {
        if (slotChild.element) {
          this.removeElement(slotChild.element.id);
        }
      }

      if (element.config.parent) {
        this.detachChildElement(this.pageElements[element.config.parent], id);
      }

      element.unmount();
      delete this.pageElements[id];
    }
  }
  /**
     * 当子节点从父节点移出后，（包括SLOT）重新更新父节点配置
     * @param {*} sourceParentElement 父节点
     * @param {*} childElementId 子节点
     */


  detachChildElement(sourceParentElement, childElement) {
    let isSlot = false;

    for (const slotProp of sourceParentElement.componentDefinition.props.filter(prop => prop.type === 'slot')) {
      if (sourceParentElement.config.props[slotProp.name] === childElement) {
        sourceParentElement.setPropsConfig(null, {
          ['props.' + slotProp.name]: null
        });
        isSlot = true;
      }
    }

    if (!isSlot) {
      sourceParentElement.config.props.children = sourceParentElement.invoke('getChildren');
    }
  }
  /**
   * 节点设置新的父节点
   * @param {*} targetParentElement
   * @param {*} sourceElement
   * @param {*} targetEl
   */


  attachToParent(targetParentElement, sourceElement, slotName) {
    if (slotName) {
      // 放置到slot中
      // 设置slot属性值为组件id
      // 父组件需要执行DOM操作
      targetParentElement.setPropsConfig(null, {
        ['props.' + slotName]: sourceElement
      });
    } else {
      // 这里容器会提供 appendChild 方法，并提供放置位置
      targetParentElement.invoke('appendChild', [sourceElement]);
      targetParentElement.config.props.children = targetParentElement.invoke('getChildren');
    }
  }
  /**
     * 获取页面的定义信息
     * @returns JSON
     */


  getPageJSON() {
    const result = {
      properties: this.pageConfig.properties,
      variables: this.pageConfig.variables,
      elements: []
    };

    for (const element of Object.values(this.pageElements)) {
      result.elements.push(element.toJSON());
    }

    return result;
  }

  addDecorators(type, decorator) {
    if (!this.decorators[type]) {
      this.decorators[type] = [];
    }

    this.decorators[type].push(decorator);
  }
  /**
     * 从当前页面变量实例值复原
     */


  updateVariableConfigFromValue() {
    for (const pv of this.pageConfig.variables) {
      if (this.pageConfig.variables[(0,_utils_string__WEBPACK_IMPORTED_MODULE_1__.trim)(pv.name)]) {
        pv.value = (0,_utils_expr__WEBPACK_IMPORTED_MODULE_2__.st)(this.pageConfig.variables[(0,_utils_string__WEBPACK_IMPORTED_MODULE_1__.trim)(pv.name)]);
      }
    }
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PageElementManager);

/***/ }),

/***/ "./src/loader/ElementLoader.js":
/*!*************************************!*\
  !*** ./src/loader/ElementLoader.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ridge_externals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ridge-externals */ "../externals/index.js");
/* harmony import */ var ridge_externals__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ridge_externals__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ky__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ky */ "../../node_modules/ky/index.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var loadjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loadjs */ "../../node_modules/loadjs/dist/loadjs.umd.js");
/* harmony import */ var loadjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loadjs__WEBPACK_IMPORTED_MODULE_2__);



 // 组态化组件资源服务地址

const log = debug__WEBPACK_IMPORTED_MODULE_1___default()('editor:ridge-loader');
const important = debug__WEBPACK_IMPORTED_MODULE_1___default()('important');
/**
 * 组件定义（js及其依赖）加载服务类
 * @class
 */

class ElementLoader {
  /**
   * 构造器
   * @param {string} baseUrl  元素下载基础地址
   * @param {string} unpkgUrl  第三方库下载地址
   * @param {object} externalOptions 第三方依赖定义信息，这个配置会覆盖 wind-pack-externals 中webpackExternals 定义
   */
  constructor({
    baseUrl,
    unpkgUrl,
    debugUrl,
    externalOptions
  }) {
    this.baseUrl = baseUrl ?? '';
    this.unpkgUrl = unpkgUrl ?? 'http://unpkg.com'; // 调试服务的地址

    this.debugUrl = debugUrl;
    important('RidgeLoader baseUrl: ' + this.baseUrl);
    /** @property 前端组件加载缓存 key: 组件lib名称或加载地址  value: 组件fcp */

    this.componentCache = {};
    /** @property 加载的前端npm包描述缓存 */

    this.packageJSONCache = {}; // 未安装的组件包列表

    this.packageNotInstalled = []; // 加载的字体列表

    this.loadedFonts = []; // 已经加载的前端组件的第三方依赖库

    window.fcExternalLoaded = []; // 调试组件包名称

    this.debugPackageName = null;
    this.packageLoadingPromises = {};
    this.externalOptions = externalOptions ?? {};

    if (window.top.ridgeConfig && window.top.ridgeConfig.loaderExternalOptions) {
      Object.assign(this.externalOptions, window.top.ridgeConfig.loaderExternalOptions);
    }

    this.scriptLoadingPromises = {}; // 组件加载器回调事件

    this.eventCallbacks = []; // 脚本地址对应的lib名称

    this.scriptUrlLibName = {};
    this.pelCacheByLibName = {}; // 组件加载中的Map

    this.componentLoading = new Map();
  }

  async getDebugPackage() {
    if (this.debugPackage !== undefined) {
      return this.debugPackage;
    }

    if (this.debugUrl) {
      try {
        this.debugPackage = await ky__WEBPACK_IMPORTED_MODULE_3__["default"].get(this.debugUrl + '/package.json').json();
      } catch (e) {
        this.debugPackage = null;
      }
    } else {
      this.debugPackage = null;
    }

    return this.debugPackage;
  }
  /**
     * 设置第三方库的加载额外定义信息
     * @param {object} opts 这个配置会覆盖 webpackExternals 定义
     */


  setExternalOptions(opts) {
    this.externalOptions = opts;
  }

  setAppName(appName) {
    if (appName) {
      this.appName = appName;
    }
  }

  setProjectId(projectId) {
    if (projectId) {
      this.projectId = projectId;
    }
  }

  setDebugUrl(debugUrl) {
    this.debugUrl = debugUrl;
  }

  setDebugPackageName(debugPackageName) {
    this.debugPackageName = debugPackageName;
  }

  getServePath(isProject) {
    if (isProject && this.projectId) {
      return this.baseUrl + '/' + this.appName + '/' + this.projectId;
    } else if (this.appName) {
      return this.baseUrl + '/' + this.appName;
    } else {
      return this.baseUrl;
    }
  }
  /**
   * 获取图元的url地址， 图元url将作为图元的唯一标识，此方法根据图元定义->图元url进行统一转换
   * @param {object} pel 图元定义 {packageName, version, path} 键值对象
   * @returns {string}
   */


  getComponentUrl({
    packageName,
    path
  }) {
    if (this.debugPackage && packageName === this.debugPackage.name) {
      return `${this.debugUrl}/${path}`;
    } else {
      return `${this.baseUrl}/${packageName}/${path}`;
    }
  }

  getPackageJSONUrl(packageName) {
    return `${this.baseUrl}/${packageName}/package.json`;
  }
  /**
   * 获取图元的服务对象的名称
   * @param {object} pel 图元定义
   * @returns {string}
   */


  getComponentLibName({
    packageName,
    path
  }) {
    return `/${packageName}/${path}`;
  }
  /**
   * Load Component By Id：
   * {
   *   packageName: '@gw/wind-pels-standard',
   *   path: './build/container1.pel.js'
   * }
   * @param {String} packageName Npm package from which component belongs to
   * @param {String} path Component path
   */


  async loadComponent(componentPath) {
    let packageName, path;

    if (typeof componentPath === 'object') {
      packageName = componentPath.packageName;
      path = componentPath.path;
    } else {
      // 抽取包和路径
      const paths = componentPath.split('/');

      if (paths[0].startsWith('@')) {
        packageName = paths.splice(0, 2).join('/');
        path = paths.join('/');
      } else {
        packageName = paths.splice(0, 1).join('/');
        path = paths.join('/');
      }
    }

    const componentUrl = this.getComponentUrl({
      packageName,
      path
    });
    const cache = this.getComponent(componentUrl);

    if (cache) {
      return cache;
    } // 对于正在加载中的， 监听成功、失败的回调


    if (this.componentLoading.get(componentUrl) === 'loading') {
      return new Promise((resolve, reject) => {
        this.on('component-ready', (url, fcp) => {
          if (url === componentUrl) {
            resolve(fcp);
          }
        });
        this.on('component-fail', url => {
          if (url === componentUrl) {
            resolve(null);
          }
        });
      });
    } else if (this.componentLoading.get(componentUrl) === 'fail') {
      return null;
    }

    this.componentLoading.set(componentUrl, 'loading');

    try {
      const fcp = await this.doLoadComponent({
        packageName,
        path
      });
      this.notifyComponentLoaded(componentUrl, fcp);
      this.componentCache[componentUrl] = fcp;
      return fcp;
    } catch (e) {
      this.setPelLoadFail(componentUrl);
      log('组件加载异常', e);
      return null;
    }
  }

  async doLoadComponent({
    packageName,
    path
  }) {
    await this.confirmPackageDependencies(packageName); // Load Dependecies in package.json

    const fcp = await this.loadComponentScript({
      packageName,
      path
    });

    if (fcp) {
      await this.prepareComponent(fcp, {
        packageName,
        path
      });
    } else {
      throw new Error();
    }

    return fcp;
  }

  async prepareComponent(fcp, {
    packageName,
    path
  }) {
    fcp.packageName = packageName;
    fcp.path = path;

    if (fcp.requires && fcp.requires.length) {
      await this.loadExternals(fcp.requires);
    } // 对于icon定义中含有图片名后缀，认为是预览图元，设置previewUrl


    const imageNameRegex = /\.(jpg|gif|png|jpeg|svg)$/i;

    if (fcp.icon && imageNameRegex.test(fcp.icon)) {
      if (this.debugPackageName === packageName && this.debugUrl) {
        fcp.previewUrl = `${this.debugUrl}${fcp.icon}`;
      } else {
        fcp.previewUrl = `/npm_packages/${packageName}/${fcp.icon}`;
      }
    } // 处理渲染器，加载渲染器依赖


    if (fcp.component) {
      let fc = fcp.component; // 支持异步的加载情况

      if (typeof fc === 'function') {
        if (fc.constructor.name === 'AsyncFunction') {
          fc = (await fc()).default;
        }
      }
    } else {
      log('组件 Component定义未加载到', fcp);
    }
  }

  notifyComponentLoaded(url, fcp) {
    this.componentLoading.set(url, 'loaded');

    try {
      this.eventCallbacks.filter(item => item.eventName === 'component-ready').forEach(item => {
        item.callback(url, fcp);
      });
    } catch (e) {// callback error ignored
    }
  }

  setPelLoadFail(url) {
    this.componentLoading.set(url, 'fail');

    try {
      this.eventCallbacks.filter(item => item.eventName === 'component-fail').forEach(item => {
        item.callback(url);
      });
    } catch (e) {// callback error ignored
    }
  }

  on(eventName, callback) {
    this.eventCallbacks.push({
      eventName,
      callback
    });
  }
  /**
     * 加载前端组件的代码，支持2种方式 globalThis 及 amd
     */


  async loadComponentScript({
    packageName,
    path
  }) {
    const scriptUrl = this.getComponentUrl({
      packageName,
      path
    });
    const scriptLibName = this.getComponentLibName({
      packageName,
      path
    }); // 加载图元脚本，其中每个图元在编译时都已经设置到了window根上，以图元url为可以key

    await this.loadScript(scriptUrl); // globalThis方式

    if (window[scriptLibName]) {
      return window[scriptLibName].default;
    } else {
      return null;
    }
  }
  /**
     * 获取组件
     * 优先从fcCache 中获取（依赖版本）；再从window下获取（不依赖版本）
     * @param {*} pel
     */


  getComponent(componentUrl) {
    if (this.componentCache[componentUrl]) {
      return this.componentCache[componentUrl];
    } else {
      return null;
    }
  }
  /**
    * 加载图元对外部的代码依赖
    * @param {Array} externals 外部依赖库列表
    */


  async loadExternals(externals) {
    const webpackExternalsMerged = Object.assign((ridge_externals__WEBPACK_IMPORTED_MODULE_0___default()), window.globalExternalConfig);

    for (const external of externals) {
      // 获取外部依赖库的下载地址 external为图元中声明的依赖库名称 例如 'echarts'
      const externalModule = webpackExternalsMerged.externals.filter(ex => external === ex.module)[0]; // 有声明则下载，否则忽略

      if (externalModule) {
        // 判断第三方库如果已经在全局加载，则直接使用全局的库
        if (externalModule.root && window[externalModule.root]) {
          continue;
        } // 首先递归下载依赖的依赖


        if (externalModule.dependencies) {
          await this.loadExternals(externalModule.dependencies);
        }

        const externalLibPath = `${this.unpkgUrl}/${externalModule.dist}`;

        if (externalModule.style) {
          // 外界定义的样式加载地址
          if (this.externalOptions[externalModule.module] != null) {
            if (Array.isArray(this.externalOptions[externalModule.module])) {
              try {
                for (const externalCssPath of this.externalOptions[externalModule.module]) {
                  await this.loadScript(externalCssPath);
                }
              } catch (e) {
                console.warn('加载应用定义的样式失败 地址是:' + this.externalOptions[externalModule.module]);
              }
            } else if (typeof this.externalOptions[externalModule.module] === 'string') {
              try {
                await this.loadScript(this.externalOptions[externalModule.module]);
              } catch (e) {
                console.warn('加载应用定义的样式失败 地址是:' + this.externalOptions[externalModule.module]);
              }
            }
          } else if (typeof externalModule.style === 'string') {
            await this.loadScript(`${this.unpkgUrl}/${externalModule.style}`);
          }
        }

        if (!this.scriptLoadingPromises[externalLibPath]) {
          // loadjs会自动处理重复加载的问题，因此此处无需做额外处理
          this.scriptLoadingPromises[externalLibPath] = (async () => {
            try {
              log('加载第三方库:' + externalLibPath);
              await loadjs__WEBPACK_IMPORTED_MODULE_2___default()(externalLibPath, {
                returnPromise: true,
                before: function (scriptPath, scriptEl) {
                  scriptEl.crossOrigin = true;
                }
              });
            } catch (e) {
              console.error('第三方库加载异常 ', `${externalModule.module}`);
            }
          })();
        }

        await this.scriptLoadingPromises[externalLibPath]; // 这里必须加载完成才标志为loaded。否则外部可能请求并发下载，那么后面的并发判断成功但加载未完成

        window.fcExternalLoaded.push(externalModule.module);
      } else {
        log('忽略库:' + external);
      }
    }
  }
  /**
     * 加载指定的字体（按名称）
     * @param name 字体名称
     * @param pkg 字体所在的图元包,包括名称和版本默认为@gw/web-font-assets@latest
     */


  async loadFont(pkg, name, url) {
    if (!name || this.loadedFonts.indexOf(name) > -1) {
      return;
    }

    if (name === 'default') {
      // 默认字体不需要加载
      return;
    }

    try {
      const fontFaceName = pkg ? pkg + '/' + url : name;
      let fontUrl = this.getServePath() + '/npm_packages/' + (pkg ? pkg + '/' + url : name); // 这是对110的字体加载的兼容， 110图纸中，字体是直接按名称保存到图元中的 例如 groteskia，没有直接提供字体地址的url。 所以需要根据字体包中JSON的定义获取具体的字体url
      // 进行进一步的加载

      if (!pkg && !url && name.indexOf('.woff') === -1) {
        await this.confirmPackageDependencies('@gw/web-font-assets');

        if (this.packageJSONCache['@gw/web-font-assets']) {
          if (this.packageJSONCache['@gw/web-font-assets'].fonts[name]) {
            fontUrl = this.getServePath() + '/npm_packages/@gw/web-font-assets/' + this.packageJSONCache['@gw/web-font-assets'].fonts[name].url;
          }
        } else {
          console.error('加载字体地址未找到', name);
        } // https://localhost:3001/scada/npm_packages/@gw/web-font-assets/package.json

      } // name 直接提供完整地址的情况


      const ff = new FontFace(fontFaceName, `url(${fontUrl})`);
      await ff.load();
      document.fonts.add(ff);
      this.loadedFonts.push(name);
    } catch (e) {
      console.error('加载字体异常', name, pkg, e);
    }
  }

  async loadCss(href) {
    // Create new link Element
    const link = document.createElement('link'); // set the attributes for link element

    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = href; // Get HTML head element to append
    // link element to it

    document.getElementsByTagName('HEAD')[0].appendChild(link);
  }

  async loadScript(url) {
    if (!this.scriptLoadingPromises[url]) {
      // loadjs会自动处理重复加载的问题，因此此处无需做额外处理
      this.scriptLoadingPromises[url] = (async () => {
        try {
          log('加载库:' + url);
          await loadjs__WEBPACK_IMPORTED_MODULE_2___default()(url, {
            returnPromise: true,
            before: function (scriptPath, scriptEl) {
              scriptEl.crossOrigin = true;
            }
          });
        } catch (e) {
          console.error('第三方库加载异常 ', `${url}`);
        }
      })();
    }

    await this.scriptLoadingPromises[url];
  }

  setPackageCache(packageName, packageObject) {
    this.packageJSONCache[packageName] = packageObject;
  }
  /**
     * 刷新Debug模式下从本地开发服务加载的组件
     */


  async reloadDebugCache() {
    for (const cacheKey of Object.keys(this.fcCache)) {
      if (cacheKey.startsWith('https://')) {
        delete this.scriptLoadingPromises[cacheKey];
        await this.loadScript(cacheKey);

        if (window[this.scriptUrlLibName[cacheKey]]) {
          const fcp = window[this.scriptUrlLibName[cacheKey]].default;
          await this.initFcp(fcp, this.pelCacheByLibName[this.scriptUrlLibName[cacheKey]]);
          this.fcCache[cacheKey] = fcp;
        }
      }
    }
  }
  /**
   * 获取package.json定义对象
   * @param {*} packageName
   * @returns
   */


  async getPackageJSON(packageName) {
    if (this.packageJSONCache[packageName]) {
      return this.packageJSONCache[packageName];
    }

    if (this.debugUrl) {
      const packageObject = await this.getDebugPackage();

      if (packageObject && packageObject.name === packageName) {
        this.prefixPackageJSON(packageObject, this.debugUrl);
        this.setPackageCache(packageObject.name, packageObject);
        return packageObject;
      }
    }

    const packageJSONUrl = this.getPackageJSONUrl(packageName);

    try {
      const packageObject = await ky__WEBPACK_IMPORTED_MODULE_3__["default"].get(packageJSONUrl).json();
      this.prefixPackageJSON(packageObject, this.baseUrl + '/' + packageName);
      this.setPackageCache(packageObject);
      return packageObject;
    } catch (e) {
      console.error('NPM Package Not Loaded: ', packageName, e);
    }
  }

  prefixPackageJSON(packageObject, prefix) {
    if (packageObject.icon) {
      packageObject.icon = `${prefix}/${packageObject.icon}`;
    }

    for (const com of packageObject.components ?? []) {
      if (com.icon) {
        com.icon = `${prefix}/${com.icon}`;
      }
    }
  }
  /**
   * 加载组件包的依赖资源
   * @param {String} packageName 组件包名称
   */


  async confirmPackageDependencies(packageName) {
    const packageObject = await this.getPackageJSON(packageName);

    if (packageObject && packageObject.dependencies) {
      await this.loadExternals(Object.keys(packageObject.dependencies));
    }
  }

  async loadJSON(path) {
    return await ky__WEBPACK_IMPORTED_MODULE_3__["default"].get(path).json();
  }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ElementLoader);

/***/ }),

/***/ "./src/render/ReactRenderer.js":
/*!*************************************!*\
  !*** ./src/render/ReactRenderer.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReactRenderer)
/* harmony export */ });
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Renderer */ "./src/render/Renderer.js");
/* eslint-disable no-undef */
// import React from 'react';
// import ReactDOM from 'react-dom';
// 这里需要注释掉React、ReactDOM 否则此包会同外围编辑器等项目一起使用。而开发期间的图元的React是额外load的，会在
// React hook 使用时报错 因此，React一定要使用window全局的React对象

const contextProviders = [// antd ConfigProvider 上下文
jsx => {
  if (window.antd) {
    return React.createElement(window.antd.ConfigProvider, {
      prefixCls: window.top.fdreConfig && window.top.fdreConfig.antdPrefixCls || 'ant'
    }, [jsx]);
  } else {
    return jsx;
  }
}, ...(window.top.fdreConfig && window.top.fdreConfig.reactContextProviders || [])];
/**
 * 渲染及React组件到图元层
 * @param JSXComponent  React组件实例
 * @param el  html层
 * @param initOption React初始化属性
 */

class ReactRenderer extends _Renderer__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(JSXComponent, el, initOption = {}) {
    super();
    this.el = el;
    this.JSXComponent = JSXComponent;
    this.props = initOption; // 规范：ReactDOM的render方法会返回组件的ref （class组件），然而在最新ReactDOM描述中，ref不会立刻返回
    // ReactDOM.render() currently returns a reference to the root ReactComponent instance. However,
    // using this return value is legacy and should be avoided because future versions of React may render
    // components asynchronously in some cases. If you need a reference to the root ReactComponent instance,
    // the preferred solution is to attach a callback ref to the root element.
    // this.props.refCallback = ref => {
    //     this.renderRef = ref;
    // };

    if (!this.props.ref) {
      this.props.ref = React.createRef();
    }

    this.renderRef = this.props.ref;
    this.root = ReactDOM.createRoot(el);
    this.root.render(this.getRenderInstance());
  }

  getRenderInstance() {
    let reactInstance = React.createElement(this.JSXComponent, this.props);

    for (let i = 0; i < contextProviders.length; i++) {
      reactInstance = contextProviders[i](reactInstance);
    }

    return reactInstance;
  }
  /**
   * 捕获组件向外触发的事件
   * @param {Event} event 事件
   * @param {Function} callback 回调函数
   * @override
   */


  on(event, callback) {
    Object.assign(this.props, {
      [event]: callback
    });
    ReactDOM.render(React.createElement(this.JSXComponent, this.props), this.el);
  }
  /**
   * 进行渲染器方法调用（MVVM情况下大多数不推荐）
   * @param {String} method 方法名称
   * @param {Array} args 参数数组
   */


  invoke(method, args) {
    // 只有类组件才能调用方法
    // Render a React element into the DOM in the supplied container and
    // return a reference to the component (or returns null for stateless components).
    if (this.renderRef && this.renderRef.current && this.renderRef.current[method] && typeof this.renderRef.current[method] === 'function') {
      return this.renderRef.current[method](...(args || []));
    } else {
      console.error('无法调用无状态组件的方法!');
      return null;
    }
  }
  /**
   * 更新属性，使渲染器重新渲染
   * React的虚拟DOM机制使得React的组件重新render到具体element时会只更新变化的DOM
   * @param option
   * @override
   */


  setOption(option) {
    this.updateProps(option);
  }
  /**
   * 更新属性，使渲染器重新渲染
   * React的虚拟DOM机制使得React的组件重新render到具体element时会只更新变化的DOM
   * @param option
   */


  updateProps(props) {
    // 方法说明： If the React element was previously rendered into container,
    // this will perform an update on it and only mutate the DOM as necessary to reflect the latest React element.
    this.props = props;

    if (this.renderRef && this.renderRef.current && typeof this.renderRef.current.updateProps === 'function') {
      this.renderRef.current.updateProps(props);
    } else {
      ReactDOM.render(this.getRenderInstance(), this.el);
    }
  }
  /**
   * 重新布局， 响应渲染元素移动、大小调整等情况
   * React的虚拟DOM机制使得React的组件重新render到具体element时会只更新变化的DOM
   * @param option
   */


  layout(option) {
    ReactDOM.render(React.createElement(this.JSXComponent, option), this.el);
  }
  /**
   * 渲染销毁
   */


  destroy() {
    /**
     * ReactDOM 方法说明
     * Remove a mounted React component from the DOM and clean up its event handlers and state.
     * If no component was mounted in the container, calling this function does nothing.
     * Returns true if a component was unmounted and false if there was no component to unmount.
     */
    ReactDOM.unmountComponentAtNode(this.el);

    if (this.renderRef) {
      this.renderRef = null;
    }
  }

}

/***/ }),

/***/ "./src/render/Renderer.js":
/*!********************************!*\
  !*** ./src/render/Renderer.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Renderer)
/* harmony export */ });
/**
 * 页面渲染抽象类，提供界面渲染、数据获取等方面操作的统一接口
 */
class Renderer {
  /**
   * 更新属性，使渲染器重新渲染
   * @param option
   * @deprecated 改为updateProps
   */
  setOption(option) {}
  /**
   * 更新属性，使渲染器重新渲染
   * @param option
   */


  updateProps(props) {}
  /**
   * 重新布局， 响应渲染元素移动、大小调整等情况
   * @param option
   */


  layout(option) {}
  /**
   * 进行渲染器方法调用（MVVM情况下大多数不推荐）
   * @param {String} method 方法名称
   * @param {Array} args 参数数组
   */


  invoke(method, args) {}
  /**
   * 捕获组件向外触发的时间
   * @param {Event} event 事件
   * @param {Function} callback 回调函数
   */


  on(event, callback) {}
  /**
   * 渲染销毁
   */


  destroy() {}

}

/***/ }),

/***/ "./src/render/VanillaRenderer.js":
/*!***************************************!*\
  !*** ./src/render/VanillaRenderer.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VanillaRender)
/* harmony export */ });
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Renderer */ "./src/render/Renderer.js");

/**
 * 渲染VannilaJS 组件
 * @param el  html层
 * @param initOption React初始化属性
 */

class VanillaRender extends _Renderer__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(VannilaComponent, el, initOption = {}) {
    super();
    this.el = el;
    this.VannilaComponent = VannilaComponent;
    this.props = initOption;
    this.getRenderInstance().mount(el);
  }

  getRenderInstance() {
    if (!this.instance) {
      this.instance = new this.VannilaComponent(this.props);
    }

    return this.instance;
  }
  /**
   * 捕获组件向外触发的时间
   * @param {Event} event 事件
   * @param {Function} callback 回调函数
   * @override
   */


  on(event, callback) {
    this.instance.on(event, callback);
  }
  /**
   * 进行渲染器方法调用（MVVM情况下大多数不推荐）
   * @param {String} method 方法名称
   * @param {Array} args 参数数组
   */


  invoke(method, args) {
    if (this.getRenderInstance()[method]) {
      return this.getRenderInstance()[method].apply(this.getRenderInstance(), args);
    }
  }

  setOption(option) {
    this.updateProps(option);
  }
  /**
   * 更新属性，使渲染器重新渲染
   * @param option
   */


  updateProps(props) {
    this.getRenderInstance().update(props);
  }
  /**
   * 重新布局， 响应渲染元素移动、大小调整等情况
   * @param option
   */


  layout(option) {
    this.getRenderInstance().layout(option);
  }
  /**
   * 渲染销毁
   */


  destroy() {
    if (this.instance) {
      this.instance.destroy && this.instance.destroy();
      this.instance = null;
    }
  }

}

/***/ }),

/***/ "./src/template.js":
/*!*************************!*\
  !*** ./src/template.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ template),
/* harmony export */   "isTemplateStr": () => (/* binding */ isTemplateStr)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "../../node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/template */ "../../node_modules/lodash/template.js");
/* harmony import */ var lodash_template__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_template__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_at__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/at */ "../../node_modules/lodash/at.js");
/* harmony import */ var lodash_at__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_at__WEBPACK_IMPORTED_MODULE_2__);
// import _ from 'lodash'



const log = debug__WEBPACK_IMPORTED_MODULE_0___default()('rg:template');
const compiledTemplates = new Map();
function template(tplString, variables, utils) {
  if (log.enabled) {
    log('模板计算', tplString, variables);
  } // 增加lodash对象到变量，使所有_的方法都能被表达式使用


  if (utils) {
    Object.assign(variables, utils);
  } // eslint-disable-next-line no-new-func


  if (typeof tplString === 'string') {
    if (tplString.startsWith('${')) {
      // 用 ${} 为模板计算 这类性能低容易出错
      try {
        // eslint-disable-next-line no-new-func
        const func = new Function(...Object.keys(variables), `return \`${tplString}\`;`);
        return func(...Object.values(variables));
      } catch (e) {
        return null;
      }
    } else if (tplString.match(/{{([\s\S]+?)}}/g)) {
      // 用 {{ 为模板进行计算的情况 }}
      if (!compiledTemplates.get(tplString)) {
        compiledTemplates.set(tplString, lodash_template__WEBPACK_IMPORTED_MODULE_1___default()(tplString, {
          interpolate: /{{([\s\S]+?)}}/g
        }));
      }

      return compiledTemplates.get(tplString)(variables);
    } else {
      // javascript表达式情况。
      try {
        // 首先转换为模板字符串
        const tplStringCon = `{{JSON.stringify(${tplString})}}`; // 用lodash计算为结果字符串

        const tplFunc = lodash_template__WEBPACK_IMPORTED_MODULE_1___default()(tplStringCon, {
          interpolate: /{{([\s\S]+?)}}/g
        }); // 反向解码

        return JSON.parse(tplFunc(variables));
      } catch (err) {
        try {
          // 按路径获取
          return lodash_at__WEBPACK_IMPORTED_MODULE_2___default()(variables, tplString)[0];
        } catch (err1) {
          // 按JSON格式
          return JSON.parse(tplString);
        }
      }
    }
  } else {
    return tplString;
  }
}
function isTemplateStr(tplString) {
  return tplString.startsWith('${') || tplString.startsWith('{{');
}

/***/ }),

/***/ "./src/utils/expr.js":
/*!***************************!*\
  !*** ./src/utils/expr.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pe": () => (/* binding */ pe),
/* harmony export */   "st": () => (/* binding */ st)
/* harmony export */ });
const pe = val => {
  try {
    return JSON.parse(val);
  } catch (e) {
    return val;
  }
};
const st = val => {
  return JSON.stringify(val);
};

/***/ }),

/***/ "./src/utils/string.js":
/*!*****************************!*\
  !*** ./src/utils/string.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "camelCase": () => (/* reexport default from dynamic */ lodash_camelCase__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "nanoid": () => (/* binding */ nanoid),
/* harmony export */   "trim": () => (/* reexport default from dynamic */ lodash_trim__WEBPACK_IMPORTED_MODULE_1___default.a)
/* harmony export */ });
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid */ "../../node_modules/nanoid/index.browser.js");
/* harmony import */ var lodash_camelCase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/camelCase */ "../../node_modules/lodash/camelCase.js");
/* harmony import */ var lodash_camelCase__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_camelCase__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_trim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/trim */ "../../node_modules/lodash/trim.js");
/* harmony import */ var lodash_trim__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_trim__WEBPACK_IMPORTED_MODULE_1__);



const nanoid = (0,nanoid__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)('1234567890abcdefghijklmnopqrstuvwxyz', 10);


/***/ }),

/***/ "../../node_modules/debug/src/browser.js":
/*!***********************************************!*\
  !*** ../../node_modules/debug/src/browser.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "../../node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "../../node_modules/debug/src/common.js":
/*!**********************************************!*\
  !*** ../../node_modules/debug/src/common.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "../../node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "../../node_modules/ky/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ky/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*! MIT License © Sindre Sorhus */

const globals = {};

const getGlobal = property => {
	/* istanbul ignore next */
	if (typeof self !== 'undefined' && self && property in self) {
		return self;
	}

	/* istanbul ignore next */
	if (typeof window !== 'undefined' && window && property in window) {
		return window;
	}

	if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g && property in __webpack_require__.g) {
		return __webpack_require__.g;
	}

	/* istanbul ignore next */
	if (typeof globalThis !== 'undefined' && globalThis) {
		return globalThis;
	}
};

const globalProperties = [
	'Headers',
	'Request',
	'Response',
	'ReadableStream',
	'fetch',
	'AbortController',
	'FormData'
];

for (const property of globalProperties) {
	Object.defineProperty(globals, property, {
		get() {
			const globalObject = getGlobal(property);
			const value = globalObject && globalObject[property];
			return typeof value === 'function' ? value.bind(globalObject) : value;
		}
	});
}

const isObject = value => value !== null && typeof value === 'object';
const supportsAbortController = typeof globals.AbortController === 'function';
const supportsStreams = typeof globals.ReadableStream === 'function';
const supportsFormData = typeof globals.FormData === 'function';

const mergeHeaders = (source1, source2) => {
	const result = new globals.Headers(source1 || {});
	const isHeadersInstance = source2 instanceof globals.Headers;
	const source = new globals.Headers(source2 || {});

	for (const [key, value] of source) {
		if ((isHeadersInstance && value === 'undefined') || value === undefined) {
			result.delete(key);
		} else {
			result.set(key, value);
		}
	}

	return result;
};

const deepMerge = (...sources) => {
	let returnValue = {};
	let headers = {};

	for (const source of sources) {
		if (Array.isArray(source)) {
			if (!(Array.isArray(returnValue))) {
				returnValue = [];
			}

			returnValue = [...returnValue, ...source];
		} else if (isObject(source)) {
			for (let [key, value] of Object.entries(source)) {
				if (isObject(value) && Reflect.has(returnValue, key)) {
					value = deepMerge(returnValue[key], value);
				}

				returnValue = {...returnValue, [key]: value};
			}

			if (isObject(source.headers)) {
				headers = mergeHeaders(headers, source.headers);
			}
		}

		returnValue.headers = headers;
	}

	return returnValue;
};

const requestMethods = [
	'get',
	'post',
	'put',
	'patch',
	'head',
	'delete'
];

const responseTypes = {
	json: 'application/json',
	text: 'text/*',
	formData: 'multipart/form-data',
	arrayBuffer: '*/*',
	blob: '*/*'
};

const retryMethods = [
	'get',
	'put',
	'head',
	'delete',
	'options',
	'trace'
];

const retryStatusCodes = [
	408,
	413,
	429,
	500,
	502,
	503,
	504
];

const retryAfterStatusCodes = [
	413,
	429,
	503
];

const stop = Symbol('stop');

class HTTPError extends Error {
	constructor(response) {
		// Set the message to the status text, such as Unauthorized,
		// with some fallbacks. This message should never be undefined.
		super(
			response.statusText ||
			String(
				(response.status === 0 || response.status) ?
					response.status : 'Unknown response error'
			)
		);
		this.name = 'HTTPError';
		this.response = response;
	}
}

class TimeoutError extends Error {
	constructor(request) {
		super('Request timed out');
		this.name = 'TimeoutError';
		this.request = request;
	}
}

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

// `Promise.race()` workaround (#91)
const timeout = (request, abortController, options) =>
	new Promise((resolve, reject) => {
		const timeoutID = setTimeout(() => {
			if (abortController) {
				abortController.abort();
			}

			reject(new TimeoutError(request));
		}, options.timeout);

		/* eslint-disable promise/prefer-await-to-then */
		options.fetch(request)
			.then(resolve)
			.catch(reject)
			.then(() => {
				clearTimeout(timeoutID);
			});
		/* eslint-enable promise/prefer-await-to-then */
	});

const normalizeRequestMethod = input => requestMethods.includes(input) ? input.toUpperCase() : input;

const defaultRetryOptions = {
	limit: 2,
	methods: retryMethods,
	statusCodes: retryStatusCodes,
	afterStatusCodes: retryAfterStatusCodes
};

const normalizeRetryOptions = (retry = {}) => {
	if (typeof retry === 'number') {
		return {
			...defaultRetryOptions,
			limit: retry
		};
	}

	if (retry.methods && !Array.isArray(retry.methods)) {
		throw new Error('retry.methods must be an array');
	}

	if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
		throw new Error('retry.statusCodes must be an array');
	}

	return {
		...defaultRetryOptions,
		...retry,
		afterStatusCodes: retryAfterStatusCodes
	};
};

// The maximum value of a 32bit int (see issue #117)
const maxSafeTimeout = 2147483647;

class Ky {
	constructor(input, options = {}) {
		this._retryCount = 0;
		this._input = input;
		this._options = {
			// TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
			credentials: this._input.credentials || 'same-origin',
			...options,
			headers: mergeHeaders(this._input.headers, options.headers),
			hooks: deepMerge({
				beforeRequest: [],
				beforeRetry: [],
				afterResponse: []
			}, options.hooks),
			method: normalizeRequestMethod(options.method || this._input.method),
			prefixUrl: String(options.prefixUrl || ''),
			retry: normalizeRetryOptions(options.retry),
			throwHttpErrors: options.throwHttpErrors !== false,
			timeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,
			fetch: options.fetch || globals.fetch
		};

		if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globals.Request)) {
			throw new TypeError('`input` must be a string, URL, or Request');
		}

		if (this._options.prefixUrl && typeof this._input === 'string') {
			if (this._input.startsWith('/')) {
				throw new Error('`input` must not begin with a slash when using `prefixUrl`');
			}

			if (!this._options.prefixUrl.endsWith('/')) {
				this._options.prefixUrl += '/';
			}

			this._input = this._options.prefixUrl + this._input;
		}

		if (supportsAbortController) {
			this.abortController = new globals.AbortController();
			if (this._options.signal) {
				this._options.signal.addEventListener('abort', () => {
					this.abortController.abort();
				});
			}

			this._options.signal = this.abortController.signal;
		}

		this.request = new globals.Request(this._input, this._options);

		if (this._options.searchParams) {
			const searchParams = '?' + new URLSearchParams(this._options.searchParams).toString();
			const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);

			// To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one
			if (((supportsFormData && this._options.body instanceof globals.FormData) || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {
				this.request.headers.delete('content-type');
			}

			this.request = new globals.Request(new globals.Request(url, this.request), this._options);
		}

		if (this._options.json !== undefined) {
			this._options.body = JSON.stringify(this._options.json);
			this.request.headers.set('content-type', 'application/json');
			this.request = new globals.Request(this.request, {body: this._options.body});
		}

		const fn = async () => {
			if (this._options.timeout > maxSafeTimeout) {
				throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
			}

			await delay(1);
			let response = await this._fetch();

			for (const hook of this._options.hooks.afterResponse) {
				// eslint-disable-next-line no-await-in-loop
				const modifiedResponse = await hook(
					this.request,
					this._options,
					this._decorateResponse(response.clone())
				);

				if (modifiedResponse instanceof globals.Response) {
					response = modifiedResponse;
				}
			}

			this._decorateResponse(response);

			if (!response.ok && this._options.throwHttpErrors) {
				throw new HTTPError(response);
			}

			// If `onDownloadProgress` is passed, it uses the stream API internally
			/* istanbul ignore next */
			if (this._options.onDownloadProgress) {
				if (typeof this._options.onDownloadProgress !== 'function') {
					throw new TypeError('The `onDownloadProgress` option must be a function');
				}

				if (!supportsStreams) {
					throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
				}

				return this._stream(response.clone(), this._options.onDownloadProgress);
			}

			return response;
		};

		const isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());
		const result = isRetriableMethod ? this._retry(fn) : fn();

		for (const [type, mimeType] of Object.entries(responseTypes)) {
			result[type] = async () => {
				this.request.headers.set('accept', this.request.headers.get('accept') || mimeType);

				const response = (await result).clone();

				if (type === 'json') {
					if (response.status === 204) {
						return '';
					}

					if (options.parseJson) {
						return options.parseJson(await response.text());
					}
				}

				return response[type]();
			};
		}

		return result;
	}

	_calculateRetryDelay(error) {
		this._retryCount++;

		if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
			if (error instanceof HTTPError) {
				if (!this._options.retry.statusCodes.includes(error.response.status)) {
					return 0;
				}

				const retryAfter = error.response.headers.get('Retry-After');
				if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
					let after = Number(retryAfter);
					if (Number.isNaN(after)) {
						after = Date.parse(retryAfter) - Date.now();
					} else {
						after *= 1000;
					}

					if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {
						return 0;
					}

					return after;
				}

				if (error.response.status === 413) {
					return 0;
				}
			}

			const BACKOFF_FACTOR = 0.3;
			return BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000;
		}

		return 0;
	}

	_decorateResponse(response) {
		if (this._options.parseJson) {
			response.json = async () => {
				return this._options.parseJson(await response.text());
			};
		}

		return response;
	}

	async _retry(fn) {
		try {
			return await fn();
		} catch (error) {
			const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
			if (ms !== 0 && this._retryCount > 0) {
				await delay(ms);

				for (const hook of this._options.hooks.beforeRetry) {
					// eslint-disable-next-line no-await-in-loop
					const hookResult = await hook({
						request: this.request,
						options: this._options,
						error,
						retryCount: this._retryCount
					});

					// If `stop` is returned from the hook, the retry process is stopped
					if (hookResult === stop) {
						return;
					}
				}

				return this._retry(fn);
			}

			if (this._options.throwHttpErrors) {
				throw error;
			}
		}
	}

	async _fetch() {
		for (const hook of this._options.hooks.beforeRequest) {
			// eslint-disable-next-line no-await-in-loop
			const result = await hook(this.request, this._options);

			if (result instanceof Request) {
				this.request = result;
				break;
			}

			if (result instanceof Response) {
				return result;
			}
		}

		if (this._options.timeout === false) {
			return this._options.fetch(this.request.clone());
		}

		return timeout(this.request.clone(), this.abortController, this._options);
	}

	/* istanbul ignore next */
	_stream(response, onDownloadProgress) {
		const totalBytes = Number(response.headers.get('content-length')) || 0;
		let transferredBytes = 0;

		return new globals.Response(
			new globals.ReadableStream({
				start(controller) {
					const reader = response.body.getReader();

					if (onDownloadProgress) {
						onDownloadProgress({percent: 0, transferredBytes: 0, totalBytes}, new Uint8Array());
					}

					async function read() {
						const {done, value} = await reader.read();
						if (done) {
							controller.close();
							return;
						}

						if (onDownloadProgress) {
							transferredBytes += value.byteLength;
							const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
							onDownloadProgress({percent, transferredBytes, totalBytes}, value);
						}

						controller.enqueue(value);
						read();
					}

					read();
				}
			})
		);
	}
}

const validateAndMerge = (...sources) => {
	for (const source of sources) {
		if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {
			throw new TypeError('The `options` argument must be an object');
		}
	}

	return deepMerge({}, ...sources);
};

const createInstance = defaults => {
	const ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));

	for (const method of requestMethods) {
		ky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, {method}));
	}

	ky.HTTPError = HTTPError;
	ky.TimeoutError = TimeoutError;
	ky.create = newDefaults => createInstance(validateAndMerge(newDefaults));
	ky.extend = newDefaults => createInstance(validateAndMerge(defaults, newDefaults));
	ky.stop = stop;

	return ky;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createInstance());


/***/ }),

/***/ "../../node_modules/loadjs/dist/loadjs.umd.js":
/*!****************************************************!*\
  !*** ../../node_modules/loadjs/dist/loadjs.umd.js ***!
  \****************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function() {
/**
 * Global dependencies.
 * @global {Object} document - DOM
 */

var devnull = function() {},
    bundleIdCache = {},
    bundleResultCache = {},
    bundleCallbackQueue = {};


/**
 * Subscribe to bundle load event.
 * @param {string[]} bundleIds - Bundle ids
 * @param {Function} callbackFn - The callback function
 */
function subscribe(bundleIds, callbackFn) {
  // listify
  bundleIds = bundleIds.push ? bundleIds : [bundleIds];

  var depsNotFound = [],
      i = bundleIds.length,
      numWaiting = i,
      fn,
      bundleId,
      r,
      q;

  // define callback function
  fn = function (bundleId, pathsNotFound) {
    if (pathsNotFound.length) depsNotFound.push(bundleId);

    numWaiting--;
    if (!numWaiting) callbackFn(depsNotFound);
  };

  // register callback
  while (i--) {
    bundleId = bundleIds[i];

    // execute callback if in result cache
    r = bundleResultCache[bundleId];
    if (r) {
      fn(bundleId, r);
      continue;
    }

    // add to callback queue
    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
    q.push(fn);
  }
}


/**
 * Publish bundle load event.
 * @param {string} bundleId - Bundle id
 * @param {string[]} pathsNotFound - List of files not found
 */
function publish(bundleId, pathsNotFound) {
  // exit if id isn't defined
  if (!bundleId) return;

  var q = bundleCallbackQueue[bundleId];

  // cache result
  bundleResultCache[bundleId] = pathsNotFound;

  // exit if queue is empty
  if (!q) return;

  // empty callback queue
  while (q.length) {
    q[0](bundleId, pathsNotFound);
    q.splice(0, 1);
  }
}


/**
 * Execute callbacks.
 * @param {Object or Function} args - The callback args
 * @param {string[]} depsNotFound - List of dependencies not found
 */
function executeCallbacks(args, depsNotFound) {
  // accept function as argument
  if (args.call) args = {success: args};

  // success and error callbacks
  if (depsNotFound.length) (args.error || devnull)(depsNotFound);
  else (args.success || devnull)(args);
}


/**
 * Load individual file.
 * @param {string} path - The file path
 * @param {Function} callbackFn - The callback function
 */
function loadFile(path, callbackFn, args, numTries) {
  var doc = document,
      async = args.async,
      maxTries = (args.numRetries || 0) + 1,
      beforeCallbackFn = args.before || devnull,
      pathname = path.replace(/[\?|#].*$/, ''),
      pathStripped = path.replace(/^(css|img)!/, ''),
      isLegacyIECss,
      e;

  numTries = numTries || 0;

  if (/(^css!|\.css$)/.test(pathname)) {
    // css
    e = doc.createElement('link');
    e.rel = 'stylesheet';
    e.href = pathStripped;

    // tag IE9+
    isLegacyIECss = 'hideFocus' in e;

    // use preload in IE Edge (to detect load errors)
    if (isLegacyIECss && e.relList) {
      isLegacyIECss = 0;
      e.rel = 'preload';
      e.as = 'style';
    }
  } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
    // image
    e = doc.createElement('img');
    e.src = pathStripped;    
  } else {
    // javascript
    e = doc.createElement('script');
    e.src = path;
    e.async = async === undefined ? true : async;
  }

  e.onload = e.onerror = e.onbeforeload = function (ev) {
    var result = ev.type[0];

    // treat empty stylesheets as failures to get around lack of onerror
    // support in IE9-11
    if (isLegacyIECss) {
      try {
        if (!e.sheet.cssText.length) result = 'e';
      } catch (x) {
        // sheets objects created from load errors don't allow access to
        // `cssText` (unless error is Code:18 SecurityError)
        if (x.code != 18) result = 'e';
      }
    }

    // handle retries in case of load failure
    if (result == 'e') {
      // increment counter
      numTries += 1;

      // exit function and try again
      if (numTries < maxTries) {
        return loadFile(path, callbackFn, args, numTries);
      }
    } else if (e.rel == 'preload' && e.as == 'style') {
      // activate preloaded stylesheets
      return e.rel = 'stylesheet'; // jshint ignore:line
    }
    
    // execute callback
    callbackFn(path, result, ev.defaultPrevented);
  };

  // add to document (unless callback returns `false`)
  if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);
}


/**
 * Load multiple files.
 * @param {string[]} paths - The file paths
 * @param {Function} callbackFn - The callback function
 */
function loadFiles(paths, callbackFn, args) {
  // listify paths
  paths = paths.push ? paths : [paths];

  var numWaiting = paths.length,
      x = numWaiting,
      pathsNotFound = [],
      fn,
      i;

  // define callback function
  fn = function(path, result, defaultPrevented) {
    // handle error
    if (result == 'e') pathsNotFound.push(path);

    // handle beforeload event. If defaultPrevented then that means the load
    // will be blocked (ex. Ghostery/ABP on Safari)
    if (result == 'b') {
      if (defaultPrevented) pathsNotFound.push(path);
      else return;
    }

    numWaiting--;
    if (!numWaiting) callbackFn(pathsNotFound);
  };

  // load scripts
  for (i=0; i < x; i++) loadFile(paths[i], fn, args);
}


/**
 * Initiate script load and register bundle.
 * @param {(string|string[])} paths - The file paths
 * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success
 *   callback or (3) object literal with success/error arguments, numRetries,
 *   etc.
 * @param {(Function|Object)} [arg2] - The (1) success callback or (2) object
 *   literal with success/error arguments, numRetries, etc.
 */
function loadjs(paths, arg1, arg2) {
  var bundleId,
      args;

  // bundleId (if string)
  if (arg1 && arg1.trim) bundleId = arg1;

  // args (default is {})
  args = (bundleId ? arg2 : arg1) || {};

  // throw error if bundle is already defined
  if (bundleId) {
    if (bundleId in bundleIdCache) {
      throw "LoadJS";
    } else {
      bundleIdCache[bundleId] = true;
    }
  }

  function loadFn(resolve, reject) {
    loadFiles(paths, function (pathsNotFound) {
      // execute callbacks
      executeCallbacks(args, pathsNotFound);
      
      // resolve Promise
      if (resolve) {
        executeCallbacks({success: resolve, error: reject}, pathsNotFound);
      }

      // publish bundle load event
      publish(bundleId, pathsNotFound);
    }, args);
  }
  
  if (args.returnPromise) return new Promise(loadFn);
  else loadFn();
}


/**
 * Execute callbacks when dependencies have been satisfied.
 * @param {(string|string[])} deps - List of bundle ids
 * @param {Object} args - success/error arguments
 */
loadjs.ready = function ready(deps, args) {
  // subscribe to bundle load event
  subscribe(deps, function (depsNotFound) {
    // execute callbacks
    executeCallbacks(args, depsNotFound);
  });

  return loadjs;
};


/**
 * Manually satisfy bundle dependencies.
 * @param {string} bundleId - The bundle id
 */
loadjs.done = function done(bundleId) {
  publish(bundleId, []);
};


/**
 * Reset loadjs dependencies statuses
 */
loadjs.reset = function reset() {
  bundleIdCache = {};
  bundleResultCache = {};
  bundleCallbackQueue = {};
};


/**
 * Determine if bundle has already been defined
 * @param String} bundleId - The bundle id
 */
loadjs.isDefined = function isDefined(bundleId) {
  return bundleId in bundleIdCache;
};


// export
return loadjs;

}));


/***/ }),

/***/ "../../node_modules/lodash/_Hash.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/_Hash.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(/*! ./_hashClear */ "../../node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "../../node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "../../node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "../../node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "../../node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "../../node_modules/lodash/_ListCache.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_ListCache.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "../../node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "../../node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "../../node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "../../node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "../../node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "../../node_modules/lodash/_Map.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/_Map.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "../../node_modules/lodash/_MapCache.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_MapCache.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "../../node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "../../node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "../../node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "../../node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "../../node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "../../node_modules/lodash/_Symbol.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/_Symbol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "../../node_modules/lodash/_apply.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/_apply.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "../../node_modules/lodash/_arrayLikeKeys.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_arrayLikeKeys.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "../../node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "../../node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "../../node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "../../node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "../../node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "../../node_modules/lodash/_arrayMap.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_arrayMap.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "../../node_modules/lodash/_arrayPush.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_arrayPush.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "../../node_modules/lodash/_arrayReduce.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_arrayReduce.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "../../node_modules/lodash/_asciiToArray.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_asciiToArray.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),

/***/ "../../node_modules/lodash/_asciiWords.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_asciiWords.js ***!
  \************************************************/
/***/ ((module) => {

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;


/***/ }),

/***/ "../../node_modules/lodash/_assignValue.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_assignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../../node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "../../node_modules/lodash/_assocIndexOf.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_assocIndexOf.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "../../node_modules/lodash/_baseAssignValue.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_baseAssignValue.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "../../node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "../../node_modules/lodash/_baseAt.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/_baseAt.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var get = __webpack_require__(/*! ./get */ "../../node_modules/lodash/get.js");

/**
 * The base implementation of `_.at` without support for individual paths.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {string[]} paths The property paths to pick.
 * @returns {Array} Returns the picked elements.
 */
function baseAt(object, paths) {
  var index = -1,
      length = paths.length,
      result = Array(length),
      skip = object == null;

  while (++index < length) {
    result[index] = skip ? undefined : get(object, paths[index]);
  }
  return result;
}

module.exports = baseAt;


/***/ }),

/***/ "../../node_modules/lodash/_baseFindIndex.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_baseFindIndex.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "../../node_modules/lodash/_baseFlatten.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_baseFlatten.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "../../node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "../../node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "../../node_modules/lodash/_baseGet.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_baseGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "../../node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "../../node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "../../node_modules/lodash/_baseGetTag.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_baseGetTag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "../../node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "../../node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "../../node_modules/lodash/_baseIndexOf.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_baseIndexOf.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "../../node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "../../node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "../../node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsArguments.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_baseIsArguments.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsNaN.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseIsNaN.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsNative.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_baseIsNative.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "../../node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "../../node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "../../node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "../../node_modules/lodash/_baseIsTypedArray.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/_baseIsTypedArray.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "../../node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "../../node_modules/lodash/_baseKeys.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_baseKeys.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "../../node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "../../node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "../../node_modules/lodash/_baseKeysIn.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_baseKeysIn.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "../../node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "../../node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "../../node_modules/lodash/_basePropertyOf.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_basePropertyOf.js ***!
  \****************************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),

/***/ "../../node_modules/lodash/_baseRest.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_baseRest.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "../../node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "../../node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "../../node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "../../node_modules/lodash/_baseSet.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_baseSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "../../node_modules/lodash/_assignValue.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "../../node_modules/lodash/_castPath.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "../../node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "../../node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "../../node_modules/lodash/_baseSetToString.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_baseSetToString.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(/*! ./constant */ "../../node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "../../node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "../../node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "../../node_modules/lodash/_baseSlice.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseSlice.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),

/***/ "../../node_modules/lodash/_baseTimes.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseTimes.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "../../node_modules/lodash/_baseToString.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_baseToString.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "../../node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "../../node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "../../node_modules/lodash/_baseTrim.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_baseTrim.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "../../node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "../../node_modules/lodash/_baseUnary.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_baseUnary.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "../../node_modules/lodash/_baseValues.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_baseValues.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "../../node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "../../node_modules/lodash/_castPath.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_castPath.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "../../node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "../../node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "../../node_modules/lodash/_castSlice.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_castSlice.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSlice = __webpack_require__(/*! ./_baseSlice */ "../../node_modules/lodash/_baseSlice.js");

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


/***/ }),

/***/ "../../node_modules/lodash/_charsEndIndex.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_charsEndIndex.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "../../node_modules/lodash/_baseIndexOf.js");

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsEndIndex;


/***/ }),

/***/ "../../node_modules/lodash/_charsStartIndex.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_charsStartIndex.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "../../node_modules/lodash/_baseIndexOf.js");

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

module.exports = charsStartIndex;


/***/ }),

/***/ "../../node_modules/lodash/_copyObject.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_copyObject.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "../../node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "../../node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "../../node_modules/lodash/_coreJsData.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_coreJsData.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "../../node_modules/lodash/_createAssigner.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_createAssigner.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "../../node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "../../node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "../../node_modules/lodash/_createCaseFirst.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_createCaseFirst.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castSlice = __webpack_require__(/*! ./_castSlice */ "../../node_modules/lodash/_castSlice.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "../../node_modules/lodash/_hasUnicode.js"),
    stringToArray = __webpack_require__(/*! ./_stringToArray */ "../../node_modules/lodash/_stringToArray.js"),
    toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js");

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;


/***/ }),

/***/ "../../node_modules/lodash/_createCompounder.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/_createCompounder.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "../../node_modules/lodash/_arrayReduce.js"),
    deburr = __webpack_require__(/*! ./deburr */ "../../node_modules/lodash/deburr.js"),
    words = __webpack_require__(/*! ./words */ "../../node_modules/lodash/words.js");

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;


/***/ }),

/***/ "../../node_modules/lodash/_customDefaultsAssignIn.js":
/*!************************************************************!*\
  !*** ../../node_modules/lodash/_customDefaultsAssignIn.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;


/***/ }),

/***/ "../../node_modules/lodash/_deburrLetter.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_deburrLetter.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePropertyOf = __webpack_require__(/*! ./_basePropertyOf */ "../../node_modules/lodash/_basePropertyOf.js");

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;


/***/ }),

/***/ "../../node_modules/lodash/_defineProperty.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_defineProperty.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "../../node_modules/lodash/_escapeHtmlChar.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_escapeHtmlChar.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePropertyOf = __webpack_require__(/*! ./_basePropertyOf */ "../../node_modules/lodash/_basePropertyOf.js");

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
var escapeHtmlChar = basePropertyOf(htmlEscapes);

module.exports = escapeHtmlChar;


/***/ }),

/***/ "../../node_modules/lodash/_escapeStringChar.js":
/*!******************************************************!*\
  !*** ../../node_modules/lodash/_escapeStringChar.js ***!
  \******************************************************/
/***/ ((module) => {

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */
function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

module.exports = escapeStringChar;


/***/ }),

/***/ "../../node_modules/lodash/_flatRest.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_flatRest.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var flatten = __webpack_require__(/*! ./flatten */ "../../node_modules/lodash/flatten.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "../../node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "../../node_modules/lodash/_setToString.js");

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ "../../node_modules/lodash/_freeGlobal.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_freeGlobal.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "../../node_modules/lodash/_getMapData.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_getMapData.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "../../node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "../../node_modules/lodash/_getNative.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_getNative.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "../../node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "../../node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "../../node_modules/lodash/_getPrototype.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_getPrototype.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "../../node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "../../node_modules/lodash/_getRawTag.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_getRawTag.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "../../node_modules/lodash/_getValue.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_getValue.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "../../node_modules/lodash/_hasUnicode.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_hasUnicode.js ***!
  \************************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),

/***/ "../../node_modules/lodash/_hasUnicodeWord.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_hasUnicodeWord.js ***!
  \****************************************************/
/***/ ((module) => {

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;


/***/ }),

/***/ "../../node_modules/lodash/_hashClear.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_hashClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "../../node_modules/lodash/_hashDelete.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_hashDelete.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "../../node_modules/lodash/_hashGet.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_hashGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "../../node_modules/lodash/_hashHas.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_hashHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "../../node_modules/lodash/_hashSet.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_hashSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "../../node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "../../node_modules/lodash/_isFlattenable.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_isFlattenable.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "../../node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "../../node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "../../node_modules/lodash/_isIndex.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_isIndex.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "../../node_modules/lodash/_isIterateeCall.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_isIterateeCall.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "../../node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../../node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "../../node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "../../node_modules/lodash/_isKey.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/_isKey.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "../../node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "../../node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "../../node_modules/lodash/_isKeyable.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/_isKeyable.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "../../node_modules/lodash/_isMasked.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_isMasked.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "../../node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "../../node_modules/lodash/_isPrototype.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_isPrototype.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheClear.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_listCacheClear.js ***!
  \****************************************************/
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheDelete.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_listCacheDelete.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheGet.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_listCacheGet.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheHas.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_listCacheHas.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "../../node_modules/lodash/_listCacheSet.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_listCacheSet.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "../../node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheClear.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheClear.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(/*! ./_Hash */ "../../node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "../../node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "../../node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheDelete.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheDelete.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheGet.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheGet.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheHas.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheHas.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "../../node_modules/lodash/_mapCacheSet.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_mapCacheSet.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "../../node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "../../node_modules/lodash/_memoizeCapped.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_memoizeCapped.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(/*! ./memoize */ "../../node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "../../node_modules/lodash/_nativeCreate.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_nativeCreate.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "../../node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "../../node_modules/lodash/_nativeKeys.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_nativeKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "../../node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "../../node_modules/lodash/_nativeKeysIn.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_nativeKeysIn.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "../../node_modules/lodash/_nodeUtil.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_nodeUtil.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../../node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "../../node_modules/lodash/_objectToString.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_objectToString.js ***!
  \****************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "../../node_modules/lodash/_overArg.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/_overArg.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "../../node_modules/lodash/_overRest.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_overRest.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "../../node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "../../node_modules/lodash/_reEscape.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_reEscape.js ***!
  \**********************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

module.exports = reEscape;


/***/ }),

/***/ "../../node_modules/lodash/_reEvaluate.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/_reEvaluate.js ***!
  \************************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

module.exports = reEvaluate;


/***/ }),

/***/ "../../node_modules/lodash/_reInterpolate.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_reInterpolate.js ***!
  \***************************************************/
/***/ ((module) => {

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

module.exports = reInterpolate;


/***/ }),

/***/ "../../node_modules/lodash/_root.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/_root.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "../../node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "../../node_modules/lodash/_setToString.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/_setToString.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "../../node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "../../node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "../../node_modules/lodash/_shortOut.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_shortOut.js ***!
  \**********************************************/
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "../../node_modules/lodash/_strictIndexOf.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_strictIndexOf.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "../../node_modules/lodash/_stringToArray.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash/_stringToArray.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiToArray = __webpack_require__(/*! ./_asciiToArray */ "../../node_modules/lodash/_asciiToArray.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "../../node_modules/lodash/_hasUnicode.js"),
    unicodeToArray = __webpack_require__(/*! ./_unicodeToArray */ "../../node_modules/lodash/_unicodeToArray.js");

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),

/***/ "../../node_modules/lodash/_stringToPath.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_stringToPath.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "../../node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "../../node_modules/lodash/_toKey.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/_toKey.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "../../node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "../../node_modules/lodash/_toSource.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/_toSource.js ***!
  \**********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "../../node_modules/lodash/_trimmedEndIndex.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/_trimmedEndIndex.js ***!
  \*****************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "../../node_modules/lodash/_unicodeToArray.js":
/*!****************************************************!*\
  !*** ../../node_modules/lodash/_unicodeToArray.js ***!
  \****************************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),

/***/ "../../node_modules/lodash/_unicodeWords.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/_unicodeWords.js ***!
  \**************************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;


/***/ }),

/***/ "../../node_modules/lodash/assignInWith.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/assignInWith.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "../../node_modules/lodash/_copyObject.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "../../node_modules/lodash/_createAssigner.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "../../node_modules/lodash/keysIn.js");

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;


/***/ }),

/***/ "../../node_modules/lodash/at.js":
/*!***************************************!*\
  !*** ../../node_modules/lodash/at.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAt = __webpack_require__(/*! ./_baseAt */ "../../node_modules/lodash/_baseAt.js"),
    flatRest = __webpack_require__(/*! ./_flatRest */ "../../node_modules/lodash/_flatRest.js");

/**
 * Creates an array of values corresponding to `paths` of `object`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Array} Returns the picked values.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
 *
 * _.at(object, ['a[0].b.c', 'a[1]']);
 * // => [3, 4]
 */
var at = flatRest(baseAt);

module.exports = at;


/***/ }),

/***/ "../../node_modules/lodash/attempt.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/attempt.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "../../node_modules/lodash/_apply.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "../../node_modules/lodash/_baseRest.js"),
    isError = __webpack_require__(/*! ./isError */ "../../node_modules/lodash/isError.js");

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = baseRest(function(func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

module.exports = attempt;


/***/ }),

/***/ "../../node_modules/lodash/camelCase.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/camelCase.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var capitalize = __webpack_require__(/*! ./capitalize */ "../../node_modules/lodash/capitalize.js"),
    createCompounder = __webpack_require__(/*! ./_createCompounder */ "../../node_modules/lodash/_createCompounder.js");

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

module.exports = camelCase;


/***/ }),

/***/ "../../node_modules/lodash/capitalize.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/capitalize.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js"),
    upperFirst = __webpack_require__(/*! ./upperFirst */ "../../node_modules/lodash/upperFirst.js");

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;


/***/ }),

/***/ "../../node_modules/lodash/constant.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/constant.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "../../node_modules/lodash/deburr.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/deburr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var deburrLetter = __webpack_require__(/*! ./_deburrLetter */ "../../node_modules/lodash/_deburrLetter.js"),
    toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js");

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),

/***/ "../../node_modules/lodash/eq.js":
/*!***************************************!*\
  !*** ../../node_modules/lodash/eq.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "../../node_modules/lodash/escape.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/escape.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escapeHtmlChar = __webpack_require__(/*! ./_escapeHtmlChar */ "../../node_modules/lodash/_escapeHtmlChar.js"),
    toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js");

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */
function escape(string) {
  string = toString(string);
  return (string && reHasUnescapedHtml.test(string))
    ? string.replace(reUnescapedHtml, escapeHtmlChar)
    : string;
}

module.exports = escape;


/***/ }),

/***/ "../../node_modules/lodash/flatten.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/flatten.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "../../node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "../../node_modules/lodash/get.js":
/*!****************************************!*\
  !*** ../../node_modules/lodash/get.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "../../node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "../../node_modules/lodash/identity.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/identity.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "../../node_modules/lodash/isArguments.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/isArguments.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "../../node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "../../node_modules/lodash/isArray.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/isArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "../../node_modules/lodash/isArrayLike.js":
/*!************************************************!*\
  !*** ../../node_modules/lodash/isArrayLike.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "../../node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "../../node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "../../node_modules/lodash/isBuffer.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/isBuffer.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "../../node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "../../node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "../../node_modules/lodash/isError.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/isError.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "../../node_modules/lodash/isPlainObject.js");

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';

/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */
function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag || tag == domExcTag ||
    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
}

module.exports = isError;


/***/ }),

/***/ "../../node_modules/lodash/isFunction.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/isFunction.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "../../node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "../../node_modules/lodash/isLength.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/isLength.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "../../node_modules/lodash/isObject.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/isObject.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "../../node_modules/lodash/isObjectLike.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/isObjectLike.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "../../node_modules/lodash/isPlainObject.js":
/*!**************************************************!*\
  !*** ../../node_modules/lodash/isPlainObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "../../node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "../../node_modules/lodash/isSymbol.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/isSymbol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "../../node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "../../node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "../../node_modules/lodash/isTypedArray.js":
/*!*************************************************!*\
  !*** ../../node_modules/lodash/isTypedArray.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "../../node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "../../node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "../../node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "../../node_modules/lodash/keys.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/keys.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "../../node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "../../node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../../node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "../../node_modules/lodash/keysIn.js":
/*!*******************************************!*\
  !*** ../../node_modules/lodash/keysIn.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "../../node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "../../node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "../../node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "../../node_modules/lodash/memoize.js":
/*!********************************************!*\
  !*** ../../node_modules/lodash/memoize.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "../../node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "../../node_modules/lodash/set.js":
/*!****************************************!*\
  !*** ../../node_modules/lodash/set.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSet = __webpack_require__(/*! ./_baseSet */ "../../node_modules/lodash/_baseSet.js");

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),

/***/ "../../node_modules/lodash/stubFalse.js":
/*!**********************************************!*\
  !*** ../../node_modules/lodash/stubFalse.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "../../node_modules/lodash/template.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/template.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignInWith = __webpack_require__(/*! ./assignInWith */ "../../node_modules/lodash/assignInWith.js"),
    attempt = __webpack_require__(/*! ./attempt */ "../../node_modules/lodash/attempt.js"),
    baseValues = __webpack_require__(/*! ./_baseValues */ "../../node_modules/lodash/_baseValues.js"),
    customDefaultsAssignIn = __webpack_require__(/*! ./_customDefaultsAssignIn */ "../../node_modules/lodash/_customDefaultsAssignIn.js"),
    escapeStringChar = __webpack_require__(/*! ./_escapeStringChar */ "../../node_modules/lodash/_escapeStringChar.js"),
    isError = __webpack_require__(/*! ./isError */ "../../node_modules/lodash/isError.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "../../node_modules/lodash/_isIterateeCall.js"),
    keys = __webpack_require__(/*! ./keys */ "../../node_modules/lodash/keys.js"),
    reInterpolate = __webpack_require__(/*! ./_reInterpolate */ "../../node_modules/lodash/_reInterpolate.js"),
    templateSettings = __webpack_require__(/*! ./templateSettings */ "../../node_modules/lodash/templateSettings.js"),
    toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js");

/** Error message constants. */
var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

/** Used to ensure capturing order of template delimiters. */
var reNoMatch = /($^)/;

/** Used to match unescaped characters in compiled string literals. */
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */
function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }
  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);

  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);

  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '";

  // Compile the regexp to match each delimiter.
  var reDelimiters = RegExp(
    (options.escape || reNoMatch).source + '|' +
    interpolate.source + '|' +
    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
    (options.evaluate || reNoMatch).source + '|$'
  , 'g');

  // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL = hasOwnProperty.call(options, 'sourceURL')
    ? ('//# sourceURL=' +
       (options.sourceURL + '').replace(/\s/g, ' ') +
       '\n')
    : '';

  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);

    // Escape characters that can't be included in string literals.
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

    // Replace delimiters with snippets.
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match.length;

    // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.
    return match;
  });

  source += "';\n";

  // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable = hasOwnProperty.call(options, 'variable') && options.variable;
  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  }
  // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }

  // Cleanup code by stripping empty strings.
  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
    .replace(reEmptyStringMiddle, '$1')
    .replace(reEmptyStringTrailing, '$1;');

  // Frame code as the function body.
  source = 'function(' + (variable || 'obj') + ') {\n' +
    (variable
      ? ''
      : 'obj || (obj = {});\n'
    ) +
    "var __t, __p = ''" +
    (isEscaping
       ? ', __e = _.escape'
       : ''
    ) +
    (isEvaluating
      ? ', __j = Array.prototype.join;\n' +
        "function print() { __p += __j.call(arguments, '') }\n"
      : ';\n'
    ) +
    source +
    'return __p\n}';

  var result = attempt(function() {
    return Function(importsKeys, sourceURL + 'return ' + source)
      .apply(undefined, importsValues);
  });

  // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source = source;
  if (isError(result)) {
    throw result;
  }
  return result;
}

module.exports = template;


/***/ }),

/***/ "../../node_modules/lodash/templateSettings.js":
/*!*****************************************************!*\
  !*** ../../node_modules/lodash/templateSettings.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var escape = __webpack_require__(/*! ./escape */ "../../node_modules/lodash/escape.js"),
    reEscape = __webpack_require__(/*! ./_reEscape */ "../../node_modules/lodash/_reEscape.js"),
    reEvaluate = __webpack_require__(/*! ./_reEvaluate */ "../../node_modules/lodash/_reEvaluate.js"),
    reInterpolate = __webpack_require__(/*! ./_reInterpolate */ "../../node_modules/lodash/_reInterpolate.js");

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {

  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {

    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': { 'escape': escape }
  }
};

module.exports = templateSettings;


/***/ }),

/***/ "../../node_modules/lodash/toString.js":
/*!*********************************************!*\
  !*** ../../node_modules/lodash/toString.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(/*! ./_baseToString */ "../../node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "../../node_modules/lodash/trim.js":
/*!*****************************************!*\
  !*** ../../node_modules/lodash/trim.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(/*! ./_baseToString */ "../../node_modules/lodash/_baseToString.js"),
    baseTrim = __webpack_require__(/*! ./_baseTrim */ "../../node_modules/lodash/_baseTrim.js"),
    castSlice = __webpack_require__(/*! ./_castSlice */ "../../node_modules/lodash/_castSlice.js"),
    charsEndIndex = __webpack_require__(/*! ./_charsEndIndex */ "../../node_modules/lodash/_charsEndIndex.js"),
    charsStartIndex = __webpack_require__(/*! ./_charsStartIndex */ "../../node_modules/lodash/_charsStartIndex.js"),
    stringToArray = __webpack_require__(/*! ./_stringToArray */ "../../node_modules/lodash/_stringToArray.js"),
    toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js");

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return baseTrim(string);
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

module.exports = trim;


/***/ }),

/***/ "../../node_modules/lodash/upperFirst.js":
/*!***********************************************!*\
  !*** ../../node_modules/lodash/upperFirst.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createCaseFirst = __webpack_require__(/*! ./_createCaseFirst */ "../../node_modules/lodash/_createCaseFirst.js");

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;


/***/ }),

/***/ "../../node_modules/lodash/words.js":
/*!******************************************!*\
  !*** ../../node_modules/lodash/words.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiWords = __webpack_require__(/*! ./_asciiWords */ "../../node_modules/lodash/_asciiWords.js"),
    hasUnicodeWord = __webpack_require__(/*! ./_hasUnicodeWord */ "../../node_modules/lodash/_hasUnicodeWord.js"),
    toString = __webpack_require__(/*! ./toString */ "../../node_modules/lodash/toString.js"),
    unicodeWords = __webpack_require__(/*! ./_unicodeWords */ "../../node_modules/lodash/_unicodeWords.js");

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),

/***/ "../../node_modules/ms/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ms/index.js ***!
  \**************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "../../node_modules/nanoid/index.browser.js":
/*!**************************************************!*\
  !*** ../../node_modules/nanoid/index.browser.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customAlphabet": () => (/* binding */ customAlphabet),
/* harmony export */   "customRandom": () => (/* binding */ customRandom),
/* harmony export */   "nanoid": () => (/* binding */ nanoid),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "urlAlphabet": () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet)
/* harmony export */ });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "../../node_modules/nanoid/url-alphabet/index.js");

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')


/***/ }),

/***/ "../../node_modules/nanoid/url-alphabet/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/nanoid/url-alphabet/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "urlAlphabet": () => (/* binding */ urlAlphabet)
/* harmony export */ });
const urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Ridge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ridge */ "./src/Ridge.js");

window.Ridge = _Ridge__WEBPACK_IMPORTED_MODULE_0__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Ridge__WEBPACK_IMPORTED_MODULE_0__["default"]);
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQseUJBQXlCO0FBQzlFOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7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QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pLcUQ7QUFDOUM7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7O0FDaENJO0FBQ1A7Ozs7Ozs7VUNEQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUVBdlgsTUFBTSxDQUFDWixLQUFQLEdBQWVBLDhDQUFmO0FBQ0EsaUVBQWVBLDhDQUFmLEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uL2V4dGVybmFscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4vc3JjL1JpZGdlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi9zcmMvZWxlbWVudC9FbGVtZW50V3JhcHBlci5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4vc3JjL2VsZW1lbnQvUGFnZUVsZW1lbnRNYW5hZ2VyLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi9zcmMvbG9hZGVyL0VsZW1lbnRMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uL3NyYy9yZW5kZXIvUmVhY3RSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4vc3JjL3JlbmRlci9SZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4vc3JjL3JlbmRlci9WYW5pbGxhUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uL3NyYy90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4vc3JjL3V0aWxzL2V4cHIuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uL3NyYy91dGlscy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9reS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2FkanMvZGlzdC9sb2FkanMudW1kLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpV29yZHMuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBdC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5T2YuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVHJpbS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RTbGljZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NoYXJzRW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jaGFyc1N0YXJ0SW5kZXguanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ2FzZUZpcnN0LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ29tcG91bmRlci5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWJ1cnJMZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VzY2FwZUh0bWxDaGFyLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNVbmljb2RlV29yZC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yZUVzY2FwZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3JlRXZhbHVhdGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yZUludGVycG9sYXRlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL190cmltbWVkRW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL191bmljb2RlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVXb3Jkcy5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXNzaWduSW5XaXRoLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9hdC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXR0ZW1wdC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2FtZWxDYXNlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jYXBpdGFsaXplLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGVidXJyLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXNjYXBlLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Vycm9yLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zZXQuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RlbXBsYXRlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90cmltLmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC91cHBlckZpcnN0LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC93b3Jkcy5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lLy4uLy4uL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmpzIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3JpZGdlLXJ1bnRpbWUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yaWRnZS1ydW50aW1lL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vcmlkZ2UtcnVudGltZS8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICBleHRlcm5hbHM6IFtcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAncmVhY3QnLFxyXG4gICAgICByb290OiAnUmVhY3QnLFxyXG4gICAgICBkaXN0OiAncmVhY3QvdW1kL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAncmVhY3QtZG9tJyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBbJ3JlYWN0J10sXHJcbiAgICAgIHJvb3Q6ICdSZWFjdERPTScsXHJcbiAgICAgIGRpc3Q6ICdyZWFjdC1kb20vdW1kL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ3Z1ZScsXHJcbiAgICAgIHJvb3Q6ICdWdWUnLFxyXG4gICAgICBkaXN0OiAndnVlL2Rpc3QvdnVlLm1pbi5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ2VjaGFydHMnLFxyXG4gICAgICByb290OiAnZWNoYXJ0cycsXHJcbiAgICAgIGRpc3Q6ICdlY2hhcnRzL2Rpc3QvZWNoYXJ0cy5taW4uanMnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBtb2R1bGU6ICdlY2hhcnRzLWdsJyxcclxuICAgICAgcm9vdDogJ2VjaGFydHMtZ2wnLFxyXG4gICAgICBkZXBlbmRlbmNpZXM6IFsnZWNoYXJ0cyddLFxyXG4gICAgICBkaXN0OiAnZWNoYXJ0cy1nbC9kaXN0L2VjaGFydHMtZ2wubWluLmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnaGlnaGNoYXJ0cycsXHJcbiAgICAgIHJvb3Q6ICdIaWdoY2hhcnRzJyxcclxuICAgICAgZGlzdDogJ2hpZ2hjaGFydHMvaGlnaGNoYXJ0cy5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ2hpZ2hjaGFydHMvaGlnaHN0b2NrJyxcclxuICAgICAgcm9vdDogJ0hpZ2hjaGFydHMnLFxyXG4gICAgICBkaXN0OiAnaGlnaGNoYXJ0cy9oaWdoc3RvY2suanMnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBtb2R1bGU6ICdoaWdoY2hhcnRzL2hpZ2hjaGFydHMtbW9yZScsXHJcbiAgICAgIGRlcGVuZGVuY2llczogWydoaWdoY2hhcnRzJ10sXHJcbiAgICAgIGRpc3Q6ICdoaWdoY2hhcnRzL2hpZ2hjaGFydHMtbW9yZS5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ2hpZ2hjaGFydHMvaGlnaGNoYXJ0cy0zZCcsXHJcbiAgICAgIGRlcGVuZGVuY2llczogWydoaWdoY2hhcnRzJ10sXHJcbiAgICAgIGRpc3Q6ICdoaWdoY2hhcnRzL2hpZ2hjaGFydHMtM2QuanMnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBtb2R1bGU6ICdoaWdoY2hhcnRzL21vZHVsZXMvZnVubmVsM2QnLFxyXG4gICAgICBkZXBlbmRlbmNpZXM6IFsnaGlnaGNoYXJ0cyddLFxyXG4gICAgICBkaXN0OiAnaGlnaGNoYXJ0cy9tb2R1bGVzL2Z1bm5lbDNkLmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnaGlnaGNoYXJ0cy9tb2R1bGVzL2N5bGluZGVyJyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBbJ2hpZ2hjaGFydHMnXSxcclxuICAgICAgZGlzdDogJ2hpZ2hjaGFydHMvbW9kdWxlcy9jeWxpbmRlci5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ2hpZ2hjaGFydHMvbW9kdWxlcy90cmVlbWFwJyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBbJ2hpZ2hjaGFydHMnXSxcclxuICAgICAgZGlzdDogJ2hpZ2hjaGFydHMvbW9kdWxlcy90cmVlbWFwLmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnYml6Y2hhcnRzJyxcclxuICAgICAgcm9vdDogJ0JpekNoYXJ0cycsXHJcbiAgICAgIGRpc3Q6ICdiaXpjaGFydHMvdW1kL0JpekNoYXJ0cy5taW4uanMnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBtb2R1bGU6ICdyZWFjdC1oaWdoY2hhcnRzJyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBbJ2hpZ2hjaGFydHMnXSxcclxuICAgICAgcm9vdDogJ1JlYWN0SGlnaGNoYXJ0cycsXHJcbiAgICAgIGRpc3Q6ICdyZWFjdC1oaWdoY2hhcnRzL1JlYWN0SGlnaGNoYXJ0cy5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ3NuYXBzdmcnLFxyXG4gICAgICByb290OiAnU25hcCcsXHJcbiAgICAgIGRpc3Q6ICdzbmFwc3ZnL2Rpc3Qvc25hcC5zdmctbWluLmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnQGFudHYvZGF0YS1zZXQnLFxyXG4gICAgICByb290OiAnRGF0YVNldCcsXHJcbiAgICAgIGRpc3Q6ICdAYW50di9kYXRhLXNldC9kaXN0L2RhdGEtc2V0LmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnQGFudC1kZXNpZ24vaWNvbnMnLFxyXG4gICAgICByb290OiAnaWNvbnMnLFxyXG4gICAgICBkZXBlbmRlbmNpZXM6IFsnYW50ZCddLFxyXG4gICAgICBkaXN0OiAnQGFudC1kZXNpZ24vaWNvbnMvZGlzdC9pbmRleC51bWQubWluLmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnbW9tZW50L2xvY2FsZS96aC1jbicsXHJcbiAgICAgIHJvb3Q6ICdtb21lbnRfbG9jYWxlX3poLWNuJyxcclxuICAgICAgZGlzdDogJ21vbWVudC9sb2NhbGUvemgtY24uanMnLFxyXG4gICAgICBkZXBlbmRlbmNpZXM6IFsnbW9tZW50J11cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ21vbWVudCcsXHJcbiAgICAgIHJvb3Q6ICdtb21lbnQnLFxyXG4gICAgICBkaXN0OiAnbW9tZW50L21pbi9tb21lbnQtd2l0aC1sb2NhbGVzLm1pbi5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ2FudGQvZGlzdC9hbnRkLmNzcycsXHJcbiAgICAgIHJvb3Q6ICdhbnRkX2NzcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ2FudGQvZGlzdC9hbnRkLXdpdGgtbG9jYWxlcycsXHJcbiAgICAgIHJvb3Q6ICdhbnRkJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnYW50ZCcsXHJcbiAgICAgIHJvb3Q6ICdhbnRkJyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBbJ3JlYWN0JywgJ3JlYWN0LWRvbScsICdtb21lbnQnXSxcclxuICAgICAgZGlzdDogJ2FudGQvZGlzdC9hbnRkLm1pbi5qcycsXHJcbiAgICAgIHN0eWxlOiAnYW50ZC9kaXN0L2FudGQudmFyaWFibGUubWluLmNzcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ2xvZGFzaCcsXHJcbiAgICAgIHJvb3Q6ICdfJyxcclxuICAgICAgZGlzdDogJ2xvZGFzaC9sb2Rhc2gubWluLmpzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbW9kdWxlOiAnYXhpb3MnLFxyXG4gICAgICByb290OiAnYXhpb3MnLFxyXG4gICAgICBkaXN0OiAnYXhpb3MvZGlzdC9heGlvcy5taW4uanMnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBtb2R1bGU6ICdodG1sMmNhbnZhcycsXHJcbiAgICAgIHJvb3Q6ICdodG1sMmNhbnZhcycsXHJcbiAgICAgIGRpc3Q6ICdodG1sMmNhbnZhcy9kaXN0L2h0bWwyY2FudmFzLm1pbi5qcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZTogJ0Bkb3V5aW5mZS9zZW1pLXVpJyxcclxuICAgICAgcm9vdDogJ1NlbWlVSScsXHJcbiAgICAgIGRlcGVuZGVuY2llczogWydyZWFjdCcsICdyZWFjdC1kb20nXSxcclxuICAgICAgc3R5bGU6ICdAZG91eWluZmUvc2VtaS11aS9kaXN0L2Nzcy9zZW1pLm1pbi5jc3MnLFxyXG4gICAgICBkaXN0OiAnQGRvdXlpbmZlL3NlbWktdWkvZGlzdC91bWQvc2VtaS11aS5taW4uanMnXHJcbiAgICB9XHJcbiAgXVxyXG59XHJcbiIsImltcG9ydCBFbGVtZW50TG9hZGVyIGZyb20gJy4vbG9hZGVyL0VsZW1lbnRMb2FkZXInXHJcbmltcG9ydCBQYWdlRWxlbWVudE1hbmFnZXIgZnJvbSAnLi9lbGVtZW50L1BhZ2VFbGVtZW50TWFuYWdlcidcclxuLyoqXHJcbiAqIFRoZSBSaWRnZSBQbGF0Zm9ybSBSdW50aW1lXHJcbiAqL1xyXG5jbGFzcyBSaWRnZSB7XHJcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xyXG4gICAgY29uc3QgYmFzZVVybCA9IG9wdHMuYmFzZVVybCA/PyAnL25wbV9wYWNrYWdlcydcclxuICAgIGNvbnN0IHVucGtnVXJsID0gb3B0cy51bmtwZ1VybCA/PyBiYXNlVXJsXHJcbiAgICBjb25zdCBkZWJ1Z1VybCA9IG9wdHMuZGVidWdVcmxcclxuXHJcbiAgICB0aGlzLmxvYWRlciA9IG5ldyBFbGVtZW50TG9hZGVyKHtcclxuICAgICAgYmFzZVVybCxcclxuICAgICAgZGVidWdVcmwsXHJcbiAgICAgIHVucGtnVXJsXHJcbiAgICB9KVxyXG4gICAgdGhpcy5wYWdlRWxlbWVudE1hbmFnZXJzID0ge31cclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyBsb2FkIChqc29uKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBSaWRnZSgpXHJcbiAgICB3aW5kb3cucmlkZ2UgPSBpbnN0YW5jZVxyXG5cclxuICAgIGNvbnN0IGpzb25PYmplY3QgPSBhd2FpdCBpbnN0YW5jZS5sb2FkZXIubG9hZEpTT04oanNvbilcclxuICAgIGluc3RhbmNlLmxvYWRQYWdlKG51bGwsIGpzb25PYmplY3QpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDpgJrnlKjlupPlip/og73vvJog5Yqg6L2957uE5Lu2XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudFBhdGgg57uE5Lu26Lev5b6EXHJcbiAgICogQHJldHVybnMg57uE5Lu25a6a5LmJ5L+h5oGvXHJcbiAgICovXHJcbiAgbG9hZENvbXBvbmVudCAoY29tcG9uZW50UGF0aCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG9hZGVyLmxvYWRDb21wb25lbnQoY29tcG9uZW50UGF0aClcclxuICB9XHJcblxyXG4gIGxvYWRQYWdlIChlbCwgcGFnZUNvbmZpZykge1xyXG4gICAgY29uc3QgcGFnZU1hbmFnZXIgPSBuZXcgUGFnZUVsZW1lbnRNYW5hZ2VyKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFnZUNvbmZpZykpLCB0aGlzKVxyXG4gICAgcGFnZU1hbmFnZXIubW91bnQoZWwgfHwgZG9jdW1lbnQuYm9keSlcclxuICAgIHJldHVybiBwYWdlTWFuYWdlclxyXG4gIH1cclxuXHJcbiAgY3JlYXRlUGFnZU1hbmFnZXIgKHBhZ2VDb25maWcpIHtcclxuICAgIGNvbnN0IHBhZ2VNYW5hZ2VyID0gbmV3IFBhZ2VFbGVtZW50TWFuYWdlcihwYWdlQ29uZmlnLCB0aGlzKVxyXG5cclxuICAgIHJldHVybiBwYWdlTWFuYWdlclxyXG4gIH1cclxuXHJcbiAgZ2V0UGFnZUVsZW1lbnRNYW5hZ2VyIChpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFnZUVsZW1lbnRNYW5hZ2Vyc1tpZF1cclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyTWV0aG9kIChuYW1lLCBtZXRob2QpIHtcclxuICAgIHRoaXNbbmFtZV0gPSBtZXRob2RcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJpZGdlXHJcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1ZydcclxuaW1wb3J0IFJlYWN0UmVuZGVyZXIgZnJvbSAnLi4vcmVuZGVyL1JlYWN0UmVuZGVyZXInXHJcbmltcG9ydCBWYW5pbGxhUmVuZGVyIGZyb20gJy4uL3JlbmRlci9WYW5pbGxhUmVuZGVyZXInXHJcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuLi90ZW1wbGF0ZSdcclxuaW1wb3J0IGxvZGFzaFNldCBmcm9tICdsb2Rhc2gvc2V0J1xyXG5jb25zdCBsb2cgPSBkZWJ1ZygncmlkZ2U6ZWwtd3JhcHBlcicpXHJcbmNvbnN0IGVycm9yID0gZGVidWcoJ3JpZGdlOmVycm9yJylcclxuXHJcbi8qKlxyXG4gKiDnu4Tku7blsIHoo4XnsbtcclxuICovXHJcbmNsYXNzIEVsZW1lbnRXcmFwcGVyIHtcclxuICBjb25zdHJ1Y3RvciAoe1xyXG4gICAgY29uZmlnLFxyXG4gICAgcGFnZU1hbmFnZXJcclxuICB9KSB7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xyXG4gICAgdGhpcy5pZCA9IGNvbmZpZy5pZFxyXG4gICAgdGhpcy5jb21wb25lbnRQYXRoID0gY29uZmlnLnBhdGhcclxuXHJcbiAgICB0aGlzLnBhZ2VNYW5hZ2VyID0gcGFnZU1hbmFnZXJcclxuXHJcbiAgICAvLyDns7vnu5/lhoXnva7lsZ7mgKdcclxuICAgIHRoaXMuc3lzdGVtUHJvcGVydGllcyA9IHtcclxuICAgICAgX19yaWRnZTogcGFnZU1hbmFnZXIucmlkZ2UsXHJcbiAgICAgIF9fcGFnZU1hbmFnZXI6IHBhZ2VNYW5hZ2VyLFxyXG4gICAgICBfX2VsZW1lbnRXcmFwcGVyOiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyDlrZjmlL7orqHnrpflgLzjgIHov5DooYzml7bphY3nva7mm7TmlrDlgLxcclxuICAgIHRoaXMucHJvcGVydGllcyA9IHt9XHJcbiAgICAvLyDnu4Tku7bnmoRzY29wZeWAvOaVsOaNrlxyXG4gICAgdGhpcy5zY29wZVZhcmlhYmxlVmFsdWVzID0ge31cclxuICB9XHJcblxyXG4gIHNldE1vZGUgKG1vZGUpIHtcclxuICAgIHRoaXMubW9kZSA9IG1vZGVcclxuICAgIHRoaXMuc3lzdGVtUHJvcGVydGllcy5fX21vZGUgPSBtb2RlXHJcbiAgICB0aGlzLmZvcmNlVXBkYXRlKClcclxuICB9XHJcblxyXG4gIGlzUm9vdCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGFyZW50ID09IG51bGxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOWkjeWItue7hOS7tuWunuS+i1xyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgY2xvbmUgKCkge1xyXG4gICAgY29uc3QgY2xvbmVkID0gbmV3IEVsZW1lbnRXcmFwcGVyKHtcclxuICAgICAgY29uZmlnOiB0aGlzLnRvSlNPTigpLFxyXG4gICAgICBwYWdlTWFuYWdlcjogdGhpcy5wYWdlTWFuYWdlclxyXG4gICAgfSlcclxuICAgIGlmICh0aGlzLmNvbXBvbmVudERlZmluaXRpb24pIHtcclxuICAgICAgY2xvbmVkLmNvbXBvbmVudERlZmluaXRpb24gPSB0aGlzLmNvbXBvbmVudERlZmluaXRpb25cclxuICAgICAgY2xvbmVkLnByZWxvYWRlZCA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2xvbmVkLmNvbmZpZy5wcm9wcy5jaGlsZHJlbikge1xyXG4gICAgICBjbG9uZWQuY29uZmlnLnByb3BzLmNoaWxkcmVuID0gY2xvbmVkLmNvbmZpZy5wcm9wcy5jaGlsZHJlbi5tYXAod3JhcHBlcklkID0+IHtcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZU5vZGUgPSB0aGlzLnBhZ2VNYW5hZ2VyLmdldEVsZW1lbnQod3JhcHBlcklkKVxyXG4gICAgICAgIGNvbnN0IGNsb25lZENoaWxkID0gdGVtcGxhdGVOb2RlLmNsb25lKClcclxuICAgICAgICBjbG9uZWRDaGlsZC5wYXJlbnRXcmFwcGVyID0gY2xvbmVkXHJcbiAgICAgICAgcmV0dXJuIGNsb25lZENoaWxkXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICAvLyBUT0RPXHJcbiAgICByZXR1cm4gY2xvbmVkXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDliqDovb3nu4Tku7bku6PnoIHjgIHmjInku6PnoIHliJ3lp4vljJblsZ7mgKdcclxuICAgKi9cclxuICBhc3luYyBwcmVsb2FkIChkZWVwUHJlbG9hZCkge1xyXG4gICAgaWYgKHRoaXMucHJlbG9hZGVkKSByZXR1cm5cclxuXHJcbiAgICB0aGlzLnNldFN0YXR1cygnTG9hZGluZycpXHJcbiAgICB0aGlzLmNvbXBvbmVudERlZmluaXRpb24gPSBhd2FpdCB0aGlzLmxvYWRDb21wb25lbnREZWZpbml0aW9uKClcclxuXHJcbiAgICBpZiAoZGVlcFByZWxvYWQpIHtcclxuICAgICAgaWYgKHRoaXMuY29uZmlnLnByb3BzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZElkIG9mIHRoaXMuY29uZmlnLnByb3BzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZFdyYXBwZXIgPSB0aGlzLnBhZ2VNYW5hZ2VyLmdldEVsZW1lbnQoY2hpbGRJZClcclxuICAgICAgICAgIGF3YWl0IGNoaWxkV3JhcHBlci5wcmVsb2FkKGRlZXBQcmVsb2FkKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY29tcG9uZW50RGVmaW5pdGlvbikge1xyXG4gICAgICB0aGlzLnJlbW92ZVN0YXR1cygnTG9hZGluZycpXHJcbiAgICAgIHRoaXMucHJlbG9hZGVkID0gdHJ1ZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zZXRTdGF0dXMoJ0Vycm9yJylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGxvYWRDb21wb25lbnREZWZpbml0aW9uICgpIHtcclxuICAgIC8vIOWKoOi9vee7hOS7tuWumuS5ieS/oeaBr1xyXG4gICAgaWYgKHRoaXMuY29tcG9uZW50UGF0aCkge1xyXG4gICAgICBjb25zdCBjb21wb25lbnREZWZpbml0aW9uID0gYXdhaXQgdGhpcy5wYWdlTWFuYWdlci5yaWRnZS5sb2FkQ29tcG9uZW50KHRoaXMuY29tcG9uZW50UGF0aClcclxuXHJcbiAgICAgIGlmICghY29tcG9uZW50RGVmaW5pdGlvbiB8fCAhY29tcG9uZW50RGVmaW5pdGlvbi5jb21wb25lbnQpIHtcclxuICAgICAgICBsb2coJ+WKoOi9veWbvuWFg+Wksei0pTog5pyq6I635Y+W57uE5Lu2JywgdGhpcy5jb21wb25lbnRQYXRoKVxyXG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKCfliqDovb3lpLHotKUnKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbXBvbmVudERlZmluaXRpb25cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFwcGVuZENoaWxkICh3cmFwcGVyKSB7XHJcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2god3JhcHBlcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOWIneWni+WMlue7hOS7tuWxnuaAp+OAgeS6i+S7tlxyXG4gICAqL1xyXG4gIGluaXRQcm9wc0FuZEV2ZW50cyAoKSB7XHJcbiAgICB0aGlzLnNsb3RQcm9wcyA9IFtdXHJcblxyXG4gICAgaWYgKHRoaXMuY29uZmlnLnBhcmVudCAmJiAhdGhpcy5wYXJlbnRXcmFwcGVyKSB7XHJcbiAgICAgIHRoaXMucGFyZW50V3JhcHBlciA9IHRoaXMucGFnZU1hbmFnZXIuZ2V0RWxlbWVudCh0aGlzLmNvbmZpZy5wYXJlbnQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8g5p6a5Li+44CB5aSE55CG5omA5pyJ5bGe5oCn5a6a5LmJXHJcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgdGhpcy5jb21wb25lbnREZWZpbml0aW9uLnByb3BzIHx8IFtdKSB7XHJcbiAgICAgIC8vIOe8lui+keWZqOWIneWni+WMluWIm+W7uuaXtue7meS4gOasoem7mOiupOWAvFxyXG4gICAgICBpZiAodGhpcy5jb25maWcuaXNOZXcpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcucHJvcHNbcHJvcC5uYW1lXSA9PSBudWxsICYmIHByb3AudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5jb25maWcucHJvcHNbcHJvcC5uYW1lXSA9IHByb3AudmFsdWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIOWkhOeQhuWxnuaAp+eahGlucHV05oOF5Ya1IOexu+S8vCB2dWXnmoQgdi1tb2RlbFxyXG4gICAgICBpZiAocHJvcC5uYW1lID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmlucHV0ID0gdmFsID0+IHtcclxuICAgICAgICAgIHRoaXMuZW1pdCgnaW5wdXQnLCB2YWwpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHJvcC5pbnB1dCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIGlucHV055u45b2T5LqOdi1tb2RlbO+8jOWPquiDveiuvue9ruWIsOS4gOS4quWxnuaAp+S4iumdolxyXG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9ICdzZXQnICsgcHJvcC5uYW1lLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5uYW1lLnN1YnN0cigxKVxyXG5cclxuICAgICAgICAvLyDlvZPlj4zlkJHnu5Hlrprml7bvvIwg6I635Y+W5Yqo5oCB57uR5a6a6YOo5YiG6YWN572u55qE5bGe5oCn5YC8XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW2V2ZW50TmFtZV0gPSB2YWwgPT4ge1xyXG4gICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgdmFsKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHByb3AubmFtZSA9PT0gJ2NoaWxkcmVuJykge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXVxyXG4gICAgICAgIHRoaXMuaXNDb250YWluZXIgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdjb250YWluZXInKVxyXG5cclxuICAgICAgICAvLyDlhpnlhaXlrZDnuqfnmoTlhbfkvZPljIXoo4XnsbtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5wcm9wcy5jaGlsZHJlbikpIHtcclxuICAgICAgICAgIHRoaXMuY29uZmlnLnByb3BzLmNoaWxkcmVuID0gdGhpcy5jb25maWcucHJvcHMuY2hpbGRyZW4ubWFwKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFnZU1hbmFnZXIuZ2V0RWxlbWVudChlbGVtZW50KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiBlbGVtZW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pLmZpbHRlcihjaGlsZCA9PiBjaGlsZClcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvcC50eXBlID09PSAnc2xvdCcpIHtcclxuICAgICAgICB0aGlzLmlzQ29udGFpbmVyID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMuc2xvdFByb3BzLnB1c2gocHJvcC5uYW1lKVxyXG4gICAgICAgIC8vIOWGmeWFpXNsb3TnmoTljIXoo4XnsbtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcucHJvcHNbcHJvcC5uYW1lXSAmJiB0eXBlb2YgdGhpcy5jb25maWcucHJvcHNbcHJvcC5uYW1lXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHRoaXMuY29uZmlnLnByb3BzW3Byb3AubmFtZV0gPSB0aGlzLnBhZ2VNYW5hZ2VyLmdldEVsZW1lbnQodGhpcy5jb25maWcucHJvcHNbcHJvcC5uYW1lXSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIOS6i+S7tuexu+WxnuaAp+WGmeWFpe+8jERPTeWIneWni+WMluWQjuS6i+S7tuaJjeiDveaMguWIsOa6kOWktFxyXG4gICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLmNvbXBvbmVudERlZmluaXRpb24uZXZlbnRzIHx8IFtdKSB7XHJcbiAgICAgIHRoaXMucHJvcGVydGllc1tldmVudC5uYW1lXSA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50Lm5hbWUsIC4uLmFyZ3MpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdlZGl0Jykge1xyXG4gICAgICB0aGlzLnVwZGF0ZUV4cHJlc3Npb25lZFByb3BlcnRpZXMoKVxyXG4gICAgfVxyXG4gICAgZGVsZXRlIHRoaXMuY29uZmlnLmlzTmV3XHJcbiAgfVxyXG5cclxuICBpc01vdW50ZWQgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWwgIT0gbnVsbFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDmiafooYznu4Tku7bliJ3mrKHliqDovb0gbW91bnTliLDlhbfkvZNET03lhYPntKBcclxuICAgICAqL1xyXG4gIG1vdW50IChlbCkge1xyXG4gICAgdGhpcy5lbCA9IGVsXHJcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3JpZGdlLWVsZW1lbnQnKVxyXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ3JpZGdlLWlkJywgdGhpcy5pZClcclxuICAgIHRoaXMuZWwuZWxlbWVudFdyYXBwZXIgPSB0aGlzXHJcbiAgICB0aGlzLmZvcmNlVXBkYXRlU3R5bGUoKVxyXG5cclxuICAgIGlmICghdGhpcy5wcmVsb2FkZWQpIHtcclxuICAgICAgdGhpcy5wcmVsb2FkKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pbml0UHJvcHNBbmRFdmVudHMoKVxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLmNyZWF0ZVJlbmRlcmVyKClcclxuICAgICAgfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaW5pdFByb3BzQW5kRXZlbnRzKClcclxuICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMuY3JlYXRlUmVuZGVyZXIoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5tb3VudCAoKSB7XHJcbiAgICBpZiAodGhpcy5jaGlsZHJlbiAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkV3JhcHBlciBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgY2hpbGRXcmFwcGVyLnVubW91bnQoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xyXG4gICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKVxyXG4gICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbFxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWwpXHJcbiAgICAgIHRoaXMuZWwgPSBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDosIPnlKjnu4Tku7bkvp3miZjnmoTmioDmnK/moYbmnrbmuLLmn5PlhoXlrrlcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xyXG4gIGNyZWF0ZVJlbmRlcmVyICgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudERlZmluaXRpb24udHlwZSA9PT0gJ3ZhbmlsbGEnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWYW5pbGxhUmVuZGVyKHRoaXMuY29tcG9uZW50RGVmaW5pdGlvbi5jb21wb25lbnQsIHRoaXMuZWwsIHRoaXMuZ2V0UHJvcGVydGllcygpKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVhY3RSZW5kZXJlcih0aGlzLmNvbXBvbmVudERlZmluaXRpb24uY29tcG9uZW50LCB0aGlzLmVsLCB0aGlzLmdldFByb3BlcnRpZXMoKSlcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBlcnJvcignY3JlYXRlIHJlbmRlciBlcnJvcicsIGUpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgZ2V0UHJvcGVydGllcyAoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcucHJvcHMsIHRoaXMuc3lzdGVtUHJvcGVydGllcywgdGhpcy5wcm9wZXJ0aWVzKVxyXG4gIH1cclxuXHJcbiAgZm9yY2VVcGRhdGVTdHlsZSAoKSB7XHJcbiAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICBpZiAodGhpcy5jb25maWcucHJvcHMuY292ZXJDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gJzEwMCUnXHJcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcclxuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xyXG4gICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IDBcclxuICAgICAgICB0aGlzLmVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnXHJcbiAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSAwXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5lbC5zdHlsZS53aWR0aCA9IHRoaXMuY29uZmlnLnN0eWxlLndpZHRoID8gKHRoaXMuY29uZmlnLnN0eWxlLndpZHRoICsgJ3B4JykgOiAnJ1xyXG4gICAgICAgIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb25maWcuc3R5bGUuaGVpZ2h0ID8gKHRoaXMuY29uZmlnLnN0eWxlLmhlaWdodCArICdweCcpIDogJydcclxuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5jb25maWcuc3R5bGUucG9zaXRpb25cclxuICAgICAgICBpZiAodGhpcy5jb25maWcuc3R5bGUucG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcclxuICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IDBcclxuICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gMFxyXG4gICAgICAgICAgdGhpcy5lbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dGhpcy5jb25maWcuc3R5bGUueH1weCwgJHt0aGlzLmNvbmZpZy5zdHlsZS55fXB4KWBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5lbC5zdHlsZS50cmFuc2Zvcm0gPSAnJ1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ2VkaXQnKSB7XHJcbiAgICAgICAgdGhpcy5lbC5zdHlsZS52aXNpYmlsaXR5ID0gdGhpcy5jb25maWcuc3R5bGUudmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXHJcbiAgICAgICAgZm9yIChjb25zdCBzdHlsZU5hbWUgb2YgT2JqZWN0LmtleXModGhpcy5jb25maWcuc3R5bGVFeCB8fCB7fSkpIHtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGVtcGxhdGUodGhpcy5jb25maWcuc3R5bGVFeFtzdHlsZU5hbWVdLCB0aGlzLmdldFZhcmlhYmxlQ29udGV4dCgpKVxyXG4gICAgICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ3dpZHRoJykge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdmFsdWUgKyAncHgnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc3R5bGVOYW1lID09PSAndmlzaWJsZScpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS52aXNpYmlsaXR5ID0gdmFsdWUgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmVsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlUHJvcGVydGllcyAocHJvcHMpIHtcclxuICAgIGlmIChwcm9wcykge1xyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMucHJvcGVydGllcywgcHJvcHMpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxvZygndXBkYXRlUHJvcHMnLCB0aGlzLmlkLCB0aGlzLnByb3BlcnRpZXMpXHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHModGhpcy5nZXRQcm9wZXJ0aWVzKCkpXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2coJ+eUqOWxnuaAp+a4suafk+e7hOS7tuWHuumUmScsIGUpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvZygndXBkYXRlUHJvcHMgdW1vdW50ZWQnLCB0aGlzLmlkKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0U2NvcGVWYXJpYWJsZVZhbHVlcyAoc2NvcGVWYXJpYWJsZVZhbHVlcykge1xyXG4gICAgdGhpcy5zY29wZVZhcmlhYmxlVmFsdWVzID0gc2NvcGVWYXJpYWJsZVZhbHVlc1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlU2NvcGVWYXJpYWJsZVZhbHVlcyAodXBkYXRlZCkge1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnNjb3BlVmFyaWFibGVWYWx1ZXMsIHVwZGF0ZWQpXHJcbiAgfVxyXG5cclxuICBnZXRTY29wZVZhcmlhYmxlVmFsdWVzICgpIHtcclxuICAgIGlmICh0aGlzLnBhcmVudFdyYXBwZXIpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5wYXJlbnRXcmFwcGVyLmdldFNjb3BlVmFyaWFibGVWYWx1ZXMoKSwgdGhpcy5zY29wZVZhcmlhYmxlVmFsdWVzKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NvcGVWYXJpYWJsZVZhbHVlc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDojrflj5blvZPliY3nu4Tku7blj6/op4HnmoTkuIrkuIvmloflj5jph4/kv6Hmga9cclxuICAgICAqL1xyXG4gIGdldFZhcmlhYmxlQ29udGV4dCAoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxcclxuICAgICAgdGhpcy5wYWdlTWFuYWdlci5nZXRWYXJpYWJsZVZhbHVlcygpLFxyXG4gICAgICB0aGlzLmdldFNjb3BlVmFyaWFibGVWYWx1ZXMoKVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog5by65Yi26YeN5paw6K6h566X5bGe5oCn5bm25pu05paw57uE5Lu25pi+56S6XHJcbiAgICovXHJcbiAgYXN5bmMgZm9yY2VVcGRhdGVQcm9wcyAoKSB7XHJcbiAgICBpZiAodGhpcy5tb2RlICE9PSAnZWRpdCcpIHtcclxuICAgICAgdGhpcy51cGRhdGVFeHByZXNzaW9uZWRQcm9wZXJ0aWVzKClcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKCdmb3JjZVVwZGF0ZScsIHRoaXMucHJvcGVydGllcylcclxuICAgIGF3YWl0IHRoaXMudXBkYXRlUHJvcGVydGllcygpXHJcbiAgfVxyXG5cclxuICBhc3luYyBmb3JjZVVwZGF0ZSAoKSB7XHJcbiAgICB0aGlzLmZvcmNlVXBkYXRlU3R5bGUoKVxyXG4gICAgdGhpcy5mb3JjZVVwZGF0ZVByb3BzKClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOiuoeeul+aJgOacieihqOi+vuW8j+WAvFxyXG4gICAqL1xyXG4gIHVwZGF0ZUV4cHJlc3Npb25lZFByb3BlcnRpZXMgKCkge1xyXG4gICAgZm9yIChjb25zdCBwcm9wQmluZEtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy5wcm9wRXgpKSB7XHJcbiAgICAgIGlmICh0aGlzLmhhc0V4cHJlc3Npb24ocHJvcEJpbmRLZXkpKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW3Byb3BCaW5kS2V5XSA9IHRlbXBsYXRlKHRoaXMuY29uZmlnLnByb3BFeFtwcm9wQmluZEtleV0sIHRoaXMuZ2V0VmFyaWFibGVDb250ZXh0KCkpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhhc0V4cHJlc3Npb24gKHByb3BCaW5kS2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcucHJvcEV4W3Byb3BCaW5kS2V5XSAhPT0gJycgJiYgdGhpcy5jb25maWcucHJvcEV4W3Byb3BCaW5kS2V5XSAhPSBudWxsXHJcbiAgfVxyXG5cclxuICBpbnZva2UgKG1ldGhvZCwgYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaW52b2tlKG1ldGhvZCwgYXJncylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOe7hOS7tuagueaNruWvueW6lOWPmOmHj+WPmOWMlui/m+iAjOi/m+ihjOmHjeaWsOW4g+WxgOaIlua4suafk1xyXG4gICAqIEBwYXJhbSB7Kn0gdmFyaWFibGVOYW1lcyDlj5jliqjnmoTlj5jph49LZXlcclxuICAgKi9cclxuICByZWFjdEJ5ICh2YXJpYWJsZU5hbWVzKSB7XHJcbiAgICBpZiAodGhpcy5jb25maWdVc2VWYXJpYWJsZSh0aGlzLmNvbmZpZy5wcm9wRXgsIHZhcmlhYmxlTmFtZXMpKSB7XHJcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGVQcm9wcygpXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb25maWdVc2VWYXJpYWJsZSh0aGlzLmNvbmZpZy5zdHlsZUV4LCB2YXJpYWJsZU5hbWVzKSkge1xyXG4gICAgICB0aGlzLmZvcmNlVXBkYXRlU3R5bGUoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uZmlnVXNlVmFyaWFibGUgKGNvbmZpZywgdmFyaWFibGVOYW1lcykge1xyXG4gICAgbGV0IHVzZWQgPSBmYWxzZVxyXG4gICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIE9iamVjdC52YWx1ZXMoY29uZmlnKSkge1xyXG4gICAgICBpZiAodXNlZCkgYnJlYWtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgdmFyaWFibGVOYW1lIG9mIHZhcmlhYmxlTmFtZXMpIHtcclxuICAgICAgICBpZiAoZXhwcmVzc2lvbi5pbmRleE9mKHZhcmlhYmxlTmFtZSkgPiAtMSkge1xyXG4gICAgICAgICAgdXNlZCA9IHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1c2VkXHJcbiAgfVxyXG5cclxuICBlbWl0IChldmVudE5hbWUsIHBheWxvYWQpIHtcclxuICAgIGlmIChldmVudE5hbWUgPT09ICdpbnB1dCcgJiYgIXRoaXMuY29uZmlnLmV2ZW50c1tldmVudE5hbWVdKSB7XHJcbiAgICAgIC8vIOWkhOeQhuWPjOWQkee7keWumueahOaDheWGtVxyXG4gICAgICBpZiAodGhpcy5jb25maWcucHJvcEV4LnZhbHVlICYmIE9iamVjdC5rZXlzKHRoaXMuZ2V0VmFyaWFibGVDb250ZXh0KCkpLmluZGV4T2YodGhpcy5jb25maWcucHJvcEV4LnZhbHVlKSA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy5wYWdlTWFuYWdlci51cGRhdGVQYWdlVmFyaWFibGVWYWx1ZSh7XHJcbiAgICAgICAgICBbdGhpcy5jb25maWcucHJvcEV4LnZhbHVlXTogcGF5bG9hZFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jb25maWcuZXZlbnRzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgLy8g5aSE55CGaW5wdXQvdmFsdWXkuovku7ZcclxuICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgdGhpcy5jb25maWcuZXZlbnRzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICBpZiAoYWN0aW9uLm5hbWUgPT09ICdzZXR2YXInKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZUNvbnRleHQgPSB0aGlzLmdldFZhcmlhYmxlQ29udGV4dCgpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhcmlhYmxlVmFsdWUgPSB0ZW1wbGF0ZShhY3Rpb24udmFsdWUsIHZhcmlhYmxlQ29udGV4dClcclxuXHJcbiAgICAgICAgICAgIGlmIChhY3Rpb24udGFyZ2V0LmluZGV4T2YoJy4nKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgbG9kYXNoU2V0KHZhcmlhYmxlQ29udGV4dCwgYWN0aW9uLnRhcmdldCwgbmV3VmFyaWFibGVWYWx1ZSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLnBhZ2VNYW5hZ2VyLnVwZGF0ZVBhZ2VWYXJpYWJsZVZhbHVlKHtcclxuICAgICAgICAgICAgICAgIFthY3Rpb24udGFyZ2V0XTogbmV3VmFyaWFibGVWYWx1ZVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nKCdFdmVudCBBY3Rpb25bc2V0dmFyXSBFcnJvcicsIGUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDlupTnlKjmi6bmiKrlmajnmoTmi6bmiKrmlrnms5XvvIjlvILmraXvvIlcclxuICAgKiBAcGFyYW0geyp9IGhvb2tOYW1lXHJcbiAgICovXHJcbiAgYXN5bmMgYXBwbHlEZWNvcmF0ZSAoaG9va05hbWUpIHtcclxuICAgIGlmICh0aGlzLnBhZ2VNYW5hZ2VyICYmIHRoaXMucGFnZU1hbmFnZXIuZGVjb3JhdG9ycy5lbGVtZW50KSB7XHJcbiAgICAgIGZvciAoY29uc3QgZGVjb3JhdG9yIG9mIHRoaXMucGFnZU1hbmFnZXIuZGVjb3JhdG9ycy5lbGVtZW50KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRlY29yYXRvcltob29rTmFtZV0gJiYgYXdhaXQgZGVjb3JhdG9yW2hvb2tOYW1lXSh0aGlzKVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgICog5Li6RE9N5YWD57Sg57uR5a6a5Z+656GA55qE5Lqk5LqS5LqL5Lu2XHJcbiAgICAgKiBAcGFyYW0geyp9IGVsXHJcbiAgICAgKiBAcGFyYW0geyp9IGV2ZW50TmFtZVxyXG4gICAgICovXHJcbiAgYXR0YWNoRWxFdmVudCAoZWwsIGV2ZW50TmFtZSkge1xyXG4gICAgZWxbZXZlbnROYW1lXSA9IGV2ZW50ID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCB0aGlzLmNvbXBvbmVudENvbmZpZylcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign5LqL5Lu25aSE55CG5byC5bi4JywgZSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldFN0YXR1cyAoc3RhdHVzLCBlbCkge1xyXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXNcclxuICAgIHRoaXMuYWRkTWFza0xheWVyKHtcclxuICAgICAgZWw6IGVsIHx8IHRoaXMuZWwsXHJcbiAgICAgIG5hbWU6IHN0YXR1cyxcclxuICAgICAgY2xhc3NOYW1lOiAnc3RhdHVzLScgKyBzdGF0dXMsXHJcbiAgICAgIHpJbmRleDogLTFcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICByZW1vdmVTdGF0dXMgKHN0YXR1cywgZWwpIHtcclxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gc3RhdHVzKSB7XHJcbiAgICAgIHRoaXMuc3RhdHVzID0gbnVsbFxyXG4gICAgICB0aGlzLnJlbW92ZU1hc2tMYXllcihzdGF0dXMsIGVsIHx8IHRoaXMuZWwpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZW1vdmVNYXNrTGF5ZXIgKG5hbWUsIGVsKSB7XHJcbiAgICBpZiAoZWwgJiYgZWwucXVlcnlTZWxlY3RvcignW25hbWU9XCInICsgbmFtZSArICdcIl0nKSkge1xyXG4gICAgICBlbC5yZW1vdmVDaGlsZChlbC5xdWVyeVNlbGVjdG9yKCdbbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYWRkTWFza0xheWVyICh7XHJcbiAgICBlbCxcclxuICAgIG5hbWUsXHJcbiAgICB6SW5kZXgsXHJcbiAgICBjbGFzc05hbWUsXHJcbiAgICB0ZXh0LFxyXG4gICAgY29udGVudFxyXG4gIH0pIHtcclxuICAgIGlmICghZWwpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBpZiAoZWwucXVlcnlTZWxlY3RvcignW25hbWU9XCInICsgbmFtZSArICdcIl0nKSkge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGNvbnN0IGxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuXHJcbiAgICBsYXllci5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lKVxyXG5cclxuICAgIGxheWVyLmNsYXNzTGlzdC5hZGQoJ2xheWVyJylcclxuXHJcbiAgICBsYXllci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcclxuICAgIGxheWVyLnN0eWxlLmxlZnQgPSAwXHJcbiAgICBsYXllci5zdHlsZS5yaWdodCA9IDBcclxuICAgIGxheWVyLnN0eWxlLnRvcCA9IDBcclxuICAgIGxheWVyLnN0eWxlLmJvdHRvbSA9IDBcclxuXHJcbiAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgIGxheWVyLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxyXG4gICAgfVxyXG4gICAgaWYgKHpJbmRleCkge1xyXG4gICAgICBsYXllci5zdHlsZS56SW5kZXggPSB6SW5kZXhcclxuICAgIH1cclxuICAgIGxheWVyLmlubmVySFRNTCA9IGNvbnRlbnQgfHwgdGV4dCB8fCAnJ1xyXG4gICAgZWwuYXBwZW5kQ2hpbGQobGF5ZXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDkv67mlLnnu4Tku7bphY3nva7nmoTmoLflvI/kv6Hmga9cclxuICAgKiBAcGFyYW0geyp9IHN0eWxlXHJcbiAgICovXHJcbiAgc2V0U3R5bGUgKHN0eWxlKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLnN0eWxlLCBzdHlsZSlcclxuXHJcbiAgICB0aGlzLmZvcmNlVXBkYXRlU3R5bGUoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDnu4Tku7bphY3nva7kv6Hmga/lj5HnlJ/mlLnlj5jvvIzpgJrov4fnvJbovpHlmajphY3nva7pnaLmnb/kvKDlhaVcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0geyp9IGZpZWxkXHJcbiAgICAgKi9cclxuICBzZXRQcm9wc0NvbmZpZyAodmFsdWVzLCBmaWVsZCkge1xyXG4gICAgZm9yIChjb25zdCBrZXlQYXRoIG9mIE9iamVjdC5rZXlzKGZpZWxkKSkge1xyXG4gICAgICBjb25zdCBbdHlwZSwga2V5XSA9IGtleVBhdGguc3BsaXQoJy4nKVxyXG5cclxuICAgICAgaWYgKHR5cGUgPT09ICdwcm9wcycpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLnByb3BzLCB7XHJcbiAgICAgICAgICBba2V5XTogZmllbGRba2V5UGF0aF1cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdHlsZSh7XHJcbiAgICAgICAgICBba2V5XTogZmllbGRba2V5UGF0aF1cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlID09PSAncHJvcHNFeCcpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLnByb3BFeCwge1xyXG4gICAgICAgICAgW2tleV06IGZpZWxkW2tleVBhdGhdXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZSA9PT0gJ3N0eWxlRXgnKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZy5zdHlsZUV4LCB7XHJcbiAgICAgICAgICBba2V5XTogZmllbGRba2V5UGF0aF1cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoa2V5UGF0aCA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnLnRpdGxlID0gZmllbGRba2V5UGF0aF1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5mb3JjZVVwZGF0ZVN0eWxlKClcclxuXHJcbiAgICAvLyDnvJbovpHml7blv73nlaXliqjmgIHphY3nva7nmoTlsZ7mgKfjgIHkuovku7ZcclxuICAgIHRoaXMuYXBwbHlEZWNvcmF0ZSgnc2V0UHJvcHNDb25maWcnKS50aGVuKCgpID0+IHtcclxuICAgICAgdGhpcy5mb3JjZVVwZGF0ZVByb3BzKClcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBzZXRFdmVudHNDb25maWcgKHZhbHVlcywgdXBkYXRlKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLmV2ZW50cywgdmFsdWVzLmV2ZW50KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDojrflj5blsIHoo4XlsYLmoLflvI/vvIzljIXmi6wgIHgveS93aWR0aC9oZWlnaHQvdmlzaWJsZS9yb3RhdGVcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICBnZXRTdHlsZSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc3R5bGVcclxuICB9XHJcblxyXG4gIGdldENoaWxkcmVuSWRzICgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wcm9wcy5jaGlsZHJlbiB8fCBbXVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDorqHnrpfojrflj5bmj5Lmp73lrZDlhYPntKBcclxuICAgICAqIEByZXR1cm5zIEFycmF5IOWFg+e0oOWIl+ihqFxyXG4gICAgICovXHJcbiAgZ2V0U2xvdENoaWxkcmVuICgpIHtcclxuICAgIGlmICh0aGlzLnNsb3RQcm9wcykge1xyXG4gICAgICByZXR1cm4gdGhpcy5zbG90UHJvcHMubWFwKHByb3AgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBuYW1lOiBwcm9wLFxyXG4gICAgICAgICAgZWxlbWVudDogdGhpcy5jb25maWcucHJvcHNbcHJvcF1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW11cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRvSlNPTiAoKSB7XHJcbiAgICBpZiAodGhpcy5pc0NvbnRhaW5lcikge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZylcclxuICAgICAgcmVzdWx0LnByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcucHJvcHMpXHJcblxyXG4gICAgICAvLyDkv53lrZjml7ZjaGlsZHJlbuWPinNsb3RQcm9w5Y+q5L+d5a2YaWRcclxuICAgICAgaWYgKHRoaXMuY29uZmlnLnByb3BzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgcmVzdWx0LnByb3BzLmNoaWxkcmVuID0gdGhpcy5jb25maWcucHJvcHMuY2hpbGRyZW4uZmlsdGVyKG4gPT4gbikubWFwKGNoaWxkID0+IGNoaWxkLmlkKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnNsb3RQcm9wcyA/PyBbXSkge1xyXG4gICAgICAgIGlmIChyZXN1bHQucHJvcHNba2V5XSkge1xyXG4gICAgICAgICAgcmVzdWx0LnByb3BzW2tleV0gPSByZXN1bHQucHJvcHNba2V5XS5pZFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRWxlbWVudFdyYXBwZXJcclxuIiwiaW1wb3J0IEVsZW1lbnRXcmFwcGVyIGZyb20gJy4vRWxlbWVudFdyYXBwZXInXHJcbmltcG9ydCB7IHRyaW0sIG5hbm9pZCB9IGZyb20gJy4uL3V0aWxzL3N0cmluZydcclxuaW1wb3J0IHsgcGUsIHN0IH0gZnJvbSAnLi4vdXRpbHMvZXhwcidcclxuXHJcbmNsYXNzIFBhZ2VFbGVtZW50TWFuYWdlciB7XHJcbiAgY29uc3RydWN0b3IgKHBhZ2VDb25maWcsIHJpZGdlLCB3cmFwcGVyQ2xhc3MpIHtcclxuICAgIHRoaXMucGFnZUNvbmZpZyA9IHBhZ2VDb25maWdcclxuICAgIHRoaXMucmlkZ2UgPSByaWRnZVxyXG4gICAgdGhpcy5kZWNvcmF0b3JzID0ge31cclxuICAgIHRoaXMuRWxlbWVudFdyYXBwZXIgPSB3cmFwcGVyQ2xhc3MgfHwgRWxlbWVudFdyYXBwZXJcclxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDmoLnmja7pobXpnaLphY3nva7or7vlj5bpobXpnaLmjqfliLblr7nosaHnu5PmnoRcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIERPTSDmoLnlhYPntKBcclxuICAgKi9cclxuICBpbml0aWFsaXplICgpIHtcclxuICAgIHRoaXMuaWQgPSB0aGlzLnBhZ2VDb25maWcuaWRcclxuICAgIHRoaXMucGFnZVZhcmlhYmxlVmFsdWVzID0ge31cclxuXHJcbiAgICBmb3IgKGNvbnN0IHZhcmlhYmxlc0NvbmZpZyBvZiB0aGlzLnBhZ2VDb25maWcudmFyaWFibGVzIHx8IFtdKSB7XHJcbiAgICAgIGlmICh0cmltKHZhcmlhYmxlc0NvbmZpZy5uYW1lKSkge1xyXG4gICAgICAgIHRoaXMucGFnZVZhcmlhYmxlVmFsdWVzW3RyaW0odmFyaWFibGVzQ29uZmlnLm5hbWUpXSA9IHBlKHZhcmlhYmxlc0NvbmZpZy52YWx1ZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGFnZUVsZW1lbnRzID0ge31cclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnBhZ2VDb25maWcuZWxlbWVudHMpIHtcclxuICAgICAgY29uc3QgZWxlbWVudFdyYXBwZXIgPSBuZXcgdGhpcy5FbGVtZW50V3JhcHBlcih7XHJcbiAgICAgICAgcGFnZU1hbmFnZXI6IHRoaXMsXHJcbiAgICAgICAgY29uZmlnOiBlbGVtZW50XHJcbiAgICAgIH0pXHJcbiAgICAgIHRoaXMucGFnZUVsZW1lbnRzW2VsZW1lbnRXcmFwcGVyLmlkXSA9IGVsZW1lbnRXcmFwcGVyXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRQYWdlUHJvcGVydGllcyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29uZmlnLnByb3BlcnRpZXNcclxuICB9XHJcblxyXG4gIGdldFZhcmlhYmxlQ29uZmlnICgpIHtcclxuICAgIHJldHVybiB0aGlzLnBhZ2VDb25maWcudmFyaWFibGVzXHJcbiAgfVxyXG5cclxuICBnZXRWYXJpYWJsZVZhbHVlcyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYWdlVmFyaWFibGVWYWx1ZXNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOabtOaWsOmhtemdouWxnuaAp+mFjee9rlxyXG4gICAqIEBwYXJhbSB7fSBwcm9wZXJ0aWVzXHJcbiAgICovXHJcbiAgdXBkYXRlUGFnZVByb3BlcnRpZXMgKHByb3BlcnRpZXMpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYWdlQ29uZmlnLnByb3BlcnRpZXMsIHByb3BlcnRpZXMpXHJcbiAgICB0aGlzLnVwZGF0ZVJvb3RFbFN0eWxlKClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOabtOaWsOmhtemdouWPmOmHj+WPluWAvFxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVzIOaWsOeahOmhtemdouWPmOmHj+WvuVxyXG4gICAqL1xyXG4gIHVwZGF0ZVBhZ2VWYXJpYWJsZVZhbHVlICh2YWx1ZXMpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYWdlVmFyaWFibGVWYWx1ZXMsIHZhbHVlcylcclxuICAgIHRoaXMudXBkYXRlVmFyaWFibGVSZWxhdGVkKHZhbHVlcylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOabtOaWsOmhtemdouWPmOmHj+mFjee9rlxyXG4gICAqIEBwYXJhbSB7Kn0gbmFtZSDlkI3np7BcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIOWPmOmHj+WAvFxyXG4gICAqL1xyXG4gIHVwZGF0ZVZhcmlhYmxlQ29uZmlnICh2YXJpYWJsZXNDb25maWcpIHtcclxuICAgIHRoaXMucGFnZUNvbmZpZy52YXJpYWJsZXMgPSB2YXJpYWJsZXNDb25maWdcclxuXHJcbiAgICB0aGlzLnBhZ2VWYXJpYWJsZVZhbHVlcyA9IHt9XHJcblxyXG4gICAgZm9yIChjb25zdCBwdiBvZiB0aGlzLnBhZ2VDb25maWcudmFyaWFibGVzKSB7XHJcbiAgICAgIGlmICh0cmltKHB2Lm5hbWUpKSB7XHJcbiAgICAgICAgdGhpcy5wYWdlVmFyaWFibGVWYWx1ZXNbdHJpbShwdi5uYW1lKV0gPSBwZShwdi52YWx1ZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpXHJcbiAgfVxyXG5cclxuICBnZXRFbGVtZW50IChpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFnZUVsZW1lbnRzW2lkXVxyXG4gIH1cclxuXHJcbiAgZ2V0UGFnZUVsZW1lbnRzICgpIHtcclxuICAgIHJldHVybiB0aGlzLnBhZ2VFbGVtZW50c1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog5oyC6L295pW05Liq6aG16Z2i5YiwYm9keeaIluiAheagueWFg+e0oFxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwg5qC55YWD57SgXHJcbiAgICovXHJcbiAgYXN5bmMgbW91bnQgKGVsKSB7XHJcbiAgICBmb3IgKGNvbnN0IHdyYXBwZXIgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnBhZ2VFbGVtZW50cykuZmlsdGVyKGUgPT4gZS5pc1Jvb3QoKSkpIHtcclxuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICAgd3JhcHBlci5tb3VudChkaXYpXHJcbiAgICAgIGVsLmFwcGVuZENoaWxkKGRpdilcclxuICAgIH1cclxuICAgIHRoaXMuZWwgPSBlbFxyXG4gICAgdGhpcy51cGRhdGVSb290RWxTdHlsZSgpXHJcbiAgfVxyXG5cclxuICB1cGRhdGVSb290RWxTdHlsZSAoKSB7XHJcbiAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gdGhpcy5wYWdlQ29uZmlnLnByb3BlcnRpZXMud2lkdGggKyAncHgnXHJcbiAgICB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMucGFnZUNvbmZpZy5wcm9wZXJ0aWVzLmhlaWdodCArICdweCdcclxuICB9XHJcblxyXG4gIGFzeW5jIHVubW91bnQgKCkge1xyXG4gICAgZm9yIChjb25zdCB3cmFwcGVyIG9mIE9iamVjdC52YWx1ZXModGhpcy5wYWdlRWxlbWVudHMpLmZpbHRlcihlID0+IGUuaXNSb290KCkpKSB7XHJcbiAgICAgIHdyYXBwZXIudW5tb3VudCgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDpooTliqDovb3lj4rliJ3lp4vljJbpobXpnaLlhoXnmoTlhYPntKBcclxuICAgKi9cclxuICBhc3luYyBwcmVsb2FkICgpIHtcclxuICAgIGNvbnN0IGF3YWl0aW5ncyA9IFtdXHJcbiAgICBmb3IgKGNvbnN0IHdyYXBwZXIgb2YgdGhpcy5wYWdlRWxlbWVudHMpIHtcclxuICAgICAgYXdhaXRpbmdzLnB1c2goYXdhaXQgd3JhcHBlci5wcmVsb2FkKCkpXHJcbiAgICB9XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYXdhaXRpbmdzKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog5pW06aG15oyJ54Wn5Y+Y6YeP5ZKM5Yqo5oCB5pWw5o2u5a6M5YWo5pu05pawXHJcbiAgICovXHJcbiAgZm9yY2VVcGRhdGUgKCkge1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIE9iamVjdC52YWx1ZXModGhpcy5wYWdlRWxlbWVudHMpKSB7XHJcbiAgICAgIGVsZW1lbnQuZm9yY2VVcGRhdGUoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdXBkYXRlVmFyaWFibGVSZWxhdGVkICh2YXJpYWJsZXMpIHtcclxuICAgIGNvbnN0IHZhcmlhYmxlS2V5cyA9IE9iamVjdC5rZXlzKHZhcmlhYmxlcylcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBPYmplY3QudmFsdWVzKHRoaXMucGFnZUVsZW1lbnRzKSkge1xyXG4gICAgICBlbGVtZW50LnJlYWN0QnkodmFyaWFibGVLZXlzKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0TW9kZSAobW9kZSkge1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIE9iamVjdC52YWx1ZXModGhpcy5wYWdlRWxlbWVudHMpKSB7XHJcbiAgICAgIGVsZW1lbnQuc2V0TW9kZShtb2RlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAqIOS7jue7hOS7tuWumuS5ieeJh+auteWIm+W7uuS4gOS4qumhtemdouWFg+e0oOWunuS+i1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZnJhY3Rpb24g5p2l6IeqXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG4gIGNyZWF0ZUVsZW1lbnQgKGZyYWN0aW9uKSB7XHJcbiAgICAvLyDnlJ/miJDnu4Tku7blrprkuYlcclxuICAgIGNvbnN0IGVsZW1lbnRDb25maWcgPSB7XHJcbiAgICAgIHRpdGxlOiBmcmFjdGlvbi50aXRsZSxcclxuICAgICAgaWQ6IG5hbm9pZCg1KSxcclxuICAgICAgaXNOZXc6IHRydWUsXHJcbiAgICAgIHBhdGg6IGZyYWN0aW9uLmNvbXBvbmVudFBhdGgsXHJcbiAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgd2lkdGg6IGZyYWN0aW9uLndpZHRoID8/IDEwMCxcclxuICAgICAgICBoZWlnaHQ6IGZyYWN0aW9uLmhlaWdodCA/PyAxMDBcclxuICAgICAgfSxcclxuICAgICAgc3R5bGVFeDoge30sXHJcbiAgICAgIHByb3BzOiB7fSxcclxuICAgICAgcHJvcEV4OiB7fSxcclxuICAgICAgZXZlbnRzOiB7fVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRWxlbWVudFdyYXBwZXIoe1xyXG4gICAgICBjb25maWc6IGVsZW1lbnRDb25maWcsXHJcbiAgICAgIHBhZ2VNYW5hZ2VyOiB0aGlzXHJcbiAgICB9KVxyXG4gICAgd3JhcHBlci5zZXRNb2RlKCdlZGl0JylcclxuICAgIHRoaXMucGFnZUVsZW1lbnRzW3dyYXBwZXIuaWRdID0gd3JhcHBlclxyXG4gICAgcmV0dXJuIHdyYXBwZXJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOenu+WHuuS4gOS4quWFg+e0oO+8iOmAkuW9kui/m+ihjO+8iVxyXG4gICAqIEBwYXJhbSB7Kn0gaWRcclxuICAgKi9cclxuICByZW1vdmVFbGVtZW50IChpZCkge1xyXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMucGFnZUVsZW1lbnRzW2lkXVxyXG5cclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGRJZCBvZiBlbGVtZW50LmdldENoaWxkcmVuSWRzKCkpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUVsZW1lbnQoY2hpbGRJZClcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IHNsb3RDaGlsZCBvZiBlbGVtZW50LmdldFNsb3RDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgaWYgKHNsb3RDaGlsZC5lbGVtZW50KSB7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUVsZW1lbnQoc2xvdENoaWxkLmVsZW1lbnQuaWQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbGVtZW50LmNvbmZpZy5wYXJlbnQpIHtcclxuICAgICAgICB0aGlzLmRldGFjaENoaWxkRWxlbWVudCh0aGlzLnBhZ2VFbGVtZW50c1tlbGVtZW50LmNvbmZpZy5wYXJlbnRdLCBpZClcclxuICAgICAgfVxyXG4gICAgICBlbGVtZW50LnVubW91bnQoKVxyXG4gICAgICBkZWxldGUgdGhpcy5wYWdlRWxlbWVudHNbaWRdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIOW9k+WtkOiKgueCueS7jueItuiKgueCueenu+WHuuWQju+8jO+8iOWMheaLrFNMT1TvvInph43mlrDmm7TmlrDniLboioLngrnphY3nva5cclxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlUGFyZW50RWxlbWVudCDniLboioLngrlcclxuICAgICAqIEBwYXJhbSB7Kn0gY2hpbGRFbGVtZW50SWQg5a2Q6IqC54K5XHJcbiAgICAgKi9cclxuICBkZXRhY2hDaGlsZEVsZW1lbnQgKHNvdXJjZVBhcmVudEVsZW1lbnQsIGNoaWxkRWxlbWVudCkge1xyXG4gICAgbGV0IGlzU2xvdCA9IGZhbHNlXHJcbiAgICBmb3IgKGNvbnN0IHNsb3RQcm9wIG9mIHNvdXJjZVBhcmVudEVsZW1lbnQuY29tcG9uZW50RGVmaW5pdGlvbi5wcm9wcy5maWx0ZXIocHJvcCA9PiBwcm9wLnR5cGUgPT09ICdzbG90JykpIHtcclxuICAgICAgaWYgKHNvdXJjZVBhcmVudEVsZW1lbnQuY29uZmlnLnByb3BzW3Nsb3RQcm9wLm5hbWVdID09PSBjaGlsZEVsZW1lbnQpIHtcclxuICAgICAgICBzb3VyY2VQYXJlbnRFbGVtZW50LnNldFByb3BzQ29uZmlnKG51bGwsIHtcclxuICAgICAgICAgIFsncHJvcHMuJyArIHNsb3RQcm9wLm5hbWVdOiBudWxsXHJcbiAgICAgICAgfSlcclxuICAgICAgICBpc1Nsb3QgPSB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNTbG90KSB7XHJcbiAgICAgIHNvdXJjZVBhcmVudEVsZW1lbnQuY29uZmlnLnByb3BzLmNoaWxkcmVuID0gc291cmNlUGFyZW50RWxlbWVudC5pbnZva2UoJ2dldENoaWxkcmVuJylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOiKgueCueiuvue9ruaWsOeahOeItuiKgueCuVxyXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0UGFyZW50RWxlbWVudFxyXG4gICAqIEBwYXJhbSB7Kn0gc291cmNlRWxlbWVudFxyXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0RWxcclxuICAgKi9cclxuICBhdHRhY2hUb1BhcmVudCAodGFyZ2V0UGFyZW50RWxlbWVudCwgc291cmNlRWxlbWVudCwgc2xvdE5hbWUpIHtcclxuICAgIGlmIChzbG90TmFtZSkgeyAvLyDmlL7nva7liLBzbG905LitXHJcbiAgICAgIC8vIOiuvue9rnNsb3TlsZ7mgKflgLzkuLrnu4Tku7ZpZFxyXG4gICAgICAvLyDniLbnu4Tku7bpnIDopoHmiafooYxET03mk43kvZxcclxuICAgICAgdGFyZ2V0UGFyZW50RWxlbWVudC5zZXRQcm9wc0NvbmZpZyhudWxsLCB7XHJcbiAgICAgICAgWydwcm9wcy4nICsgc2xvdE5hbWVdOiBzb3VyY2VFbGVtZW50XHJcbiAgICAgIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyDov5nph4zlrrnlmajkvJrmj5DkvpsgYXBwZW5kQ2hpbGQg5pa55rOV77yM5bm25o+Q5L6b5pS+572u5L2N572uXHJcbiAgICAgIHRhcmdldFBhcmVudEVsZW1lbnQuaW52b2tlKCdhcHBlbmRDaGlsZCcsIFtzb3VyY2VFbGVtZW50XSlcclxuICAgICAgdGFyZ2V0UGFyZW50RWxlbWVudC5jb25maWcucHJvcHMuY2hpbGRyZW4gPSB0YXJnZXRQYXJlbnRFbGVtZW50Lmludm9rZSgnZ2V0Q2hpbGRyZW4nKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDojrflj5bpobXpnaLnmoTlrprkuYnkv6Hmga9cclxuICAgICAqIEByZXR1cm5zIEpTT05cclxuICAgICAqL1xyXG4gIGdldFBhZ2VKU09OICgpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgcHJvcGVydGllczogdGhpcy5wYWdlQ29uZmlnLnByb3BlcnRpZXMsXHJcbiAgICAgIHZhcmlhYmxlczogdGhpcy5wYWdlQ29uZmlnLnZhcmlhYmxlcyxcclxuICAgICAgZWxlbWVudHM6IFtdXHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIE9iamVjdC52YWx1ZXModGhpcy5wYWdlRWxlbWVudHMpKSB7XHJcbiAgICAgIHJlc3VsdC5lbGVtZW50cy5wdXNoKGVsZW1lbnQudG9KU09OKCkpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICBhZGREZWNvcmF0b3JzICh0eXBlLCBkZWNvcmF0b3IpIHtcclxuICAgIGlmICghdGhpcy5kZWNvcmF0b3JzW3R5cGVdKSB7XHJcbiAgICAgIHRoaXMuZGVjb3JhdG9yc1t0eXBlXSA9IFtdXHJcbiAgICB9XHJcbiAgICB0aGlzLmRlY29yYXRvcnNbdHlwZV0ucHVzaChkZWNvcmF0b3IpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIOS7juW9k+WJjemhtemdouWPmOmHj+WunuS+i+WAvOWkjeWOn1xyXG4gICAgICovXHJcbiAgdXBkYXRlVmFyaWFibGVDb25maWdGcm9tVmFsdWUgKCkge1xyXG4gICAgZm9yIChjb25zdCBwdiBvZiB0aGlzLnBhZ2VDb25maWcudmFyaWFibGVzKSB7XHJcbiAgICAgIGlmICh0aGlzLnBhZ2VDb25maWcudmFyaWFibGVzW3RyaW0ocHYubmFtZSldKSB7XHJcbiAgICAgICAgcHYudmFsdWUgPSBzdCh0aGlzLnBhZ2VDb25maWcudmFyaWFibGVzW3RyaW0ocHYubmFtZSldKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQYWdlRWxlbWVudE1hbmFnZXJcclxuIiwiaW1wb3J0IHdlYnBhY2tFeHRlcm5hbHMgZnJvbSAncmlkZ2UtZXh0ZXJuYWxzJ1xyXG5pbXBvcnQga3kgZnJvbSAna3knXHJcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1ZydcclxuaW1wb3J0IGxvYWRqcyBmcm9tICdsb2FkanMnXHJcblxyXG4vLyDnu4TmgIHljJbnu4Tku7botYTmupDmnI3liqHlnLDlnYBcclxuY29uc3QgbG9nID0gZGVidWcoJ2VkaXRvcjpyaWRnZS1sb2FkZXInKVxyXG5jb25zdCBpbXBvcnRhbnQgPSBkZWJ1ZygnaW1wb3J0YW50JylcclxuXHJcbi8qKlxyXG4gKiDnu4Tku7blrprkuYnvvIhqc+WPiuWFtuS+nei1lu+8ieWKoOi9veacjeWKoeexu1xyXG4gKiBAY2xhc3NcclxuICovXHJcbmNsYXNzIEVsZW1lbnRMb2FkZXIge1xyXG4gIC8qKlxyXG4gICAqIOaehOmAoOWZqFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsICDlhYPntKDkuIvovb3ln7rnoYDlnLDlnYBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5wa2dVcmwgIOesrOS4ieaWueW6k+S4i+i9veWcsOWdgFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBleHRlcm5hbE9wdGlvbnMg56ys5LiJ5pa55L6d6LWW5a6a5LmJ5L+h5oGv77yM6L+Z5Liq6YWN572u5Lya6KaG55uWIHdpbmQtcGFjay1leHRlcm5hbHMg5Litd2VicGFja0V4dGVybmFscyDlrprkuYlcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciAoe1xyXG4gICAgYmFzZVVybCxcclxuICAgIHVucGtnVXJsLFxyXG4gICAgZGVidWdVcmwsXHJcbiAgICBleHRlcm5hbE9wdGlvbnNcclxuICB9KSB7XHJcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsID8/ICcnXHJcbiAgICB0aGlzLnVucGtnVXJsID0gdW5wa2dVcmwgPz8gJ2h0dHA6Ly91bnBrZy5jb20nXHJcbiAgICAvLyDosIPor5XmnI3liqHnmoTlnLDlnYBcclxuICAgIHRoaXMuZGVidWdVcmwgPSBkZWJ1Z1VybFxyXG5cclxuICAgIGltcG9ydGFudCgnUmlkZ2VMb2FkZXIgYmFzZVVybDogJyArIHRoaXMuYmFzZVVybClcclxuXHJcbiAgICAvKiogQHByb3BlcnR5IOWJjeerr+e7hOS7tuWKoOi9vee8k+WtmCBrZXk6IOe7hOS7tmxpYuWQjeensOaIluWKoOi9veWcsOWdgCAgdmFsdWU6IOe7hOS7tmZjcCAqL1xyXG4gICAgdGhpcy5jb21wb25lbnRDYWNoZSA9IHt9XHJcblxyXG4gICAgLyoqIEBwcm9wZXJ0eSDliqDovb3nmoTliY3nq69ucG3ljIXmj4/ov7DnvJPlrZggKi9cclxuICAgIHRoaXMucGFja2FnZUpTT05DYWNoZSA9IHt9XHJcbiAgICAvLyDmnKrlronoo4XnmoTnu4Tku7bljIXliJfooahcclxuICAgIHRoaXMucGFja2FnZU5vdEluc3RhbGxlZCA9IFtdXHJcbiAgICAvLyDliqDovb3nmoTlrZfkvZPliJfooahcclxuICAgIHRoaXMubG9hZGVkRm9udHMgPSBbXVxyXG4gICAgLy8g5bey57uP5Yqg6L2955qE5YmN56uv57uE5Lu255qE56ys5LiJ5pa55L6d6LWW5bqTXHJcbiAgICB3aW5kb3cuZmNFeHRlcm5hbExvYWRlZCA9IFtdXHJcblxyXG4gICAgLy8g6LCD6K+V57uE5Lu25YyF5ZCN56ewXHJcbiAgICB0aGlzLmRlYnVnUGFja2FnZU5hbWUgPSBudWxsXHJcblxyXG4gICAgdGhpcy5wYWNrYWdlTG9hZGluZ1Byb21pc2VzID0ge31cclxuXHJcbiAgICB0aGlzLmV4dGVybmFsT3B0aW9ucyA9IGV4dGVybmFsT3B0aW9ucyA/PyB7fVxyXG5cclxuICAgIGlmICh3aW5kb3cudG9wLnJpZGdlQ29uZmlnICYmIHdpbmRvdy50b3AucmlkZ2VDb25maWcubG9hZGVyRXh0ZXJuYWxPcHRpb25zKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5leHRlcm5hbE9wdGlvbnMsIHdpbmRvdy50b3AucmlkZ2VDb25maWcubG9hZGVyRXh0ZXJuYWxPcHRpb25zKVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2NyaXB0TG9hZGluZ1Byb21pc2VzID0ge31cclxuXHJcbiAgICAvLyDnu4Tku7bliqDovb3lmajlm57osIPkuovku7ZcclxuICAgIHRoaXMuZXZlbnRDYWxsYmFja3MgPSBbXVxyXG5cclxuICAgIC8vIOiEmuacrOWcsOWdgOWvueW6lOeahGxpYuWQjeensFxyXG4gICAgdGhpcy5zY3JpcHRVcmxMaWJOYW1lID0ge31cclxuXHJcbiAgICB0aGlzLnBlbENhY2hlQnlMaWJOYW1lID0ge31cclxuXHJcbiAgICAvLyDnu4Tku7bliqDovb3kuK3nmoRNYXBcclxuICAgIHRoaXMuY29tcG9uZW50TG9hZGluZyA9IG5ldyBNYXAoKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0RGVidWdQYWNrYWdlICgpIHtcclxuICAgIGlmICh0aGlzLmRlYnVnUGFja2FnZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlYnVnUGFja2FnZVxyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGVidWdVcmwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmRlYnVnUGFja2FnZSA9IGF3YWl0IGt5LmdldCh0aGlzLmRlYnVnVXJsICsgJy9wYWNrYWdlLmpzb24nKS5qc29uKClcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRoaXMuZGVidWdQYWNrYWdlID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRlYnVnUGFja2FnZSA9IG51bGxcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmRlYnVnUGFja2FnZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDorr7nva7nrKzkuInmlrnlupPnmoTliqDovb3pop3lpJblrprkuYnkv6Hmga9cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIOi/meS4qumFjee9ruS8muimhuebliB3ZWJwYWNrRXh0ZXJuYWxzIOWumuS5iVxyXG4gICAgICovXHJcbiAgc2V0RXh0ZXJuYWxPcHRpb25zIChvcHRzKSB7XHJcbiAgICB0aGlzLmV4dGVybmFsT3B0aW9ucyA9IG9wdHNcclxuICB9XHJcblxyXG4gIHNldEFwcE5hbWUgKGFwcE5hbWUpIHtcclxuICAgIGlmIChhcHBOYW1lKSB7XHJcbiAgICAgIHRoaXMuYXBwTmFtZSA9IGFwcE5hbWVcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldFByb2plY3RJZCAocHJvamVjdElkKSB7XHJcbiAgICBpZiAocHJvamVjdElkKSB7XHJcbiAgICAgIHRoaXMucHJvamVjdElkID0gcHJvamVjdElkXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXREZWJ1Z1VybCAoZGVidWdVcmwpIHtcclxuICAgIHRoaXMuZGVidWdVcmwgPSBkZWJ1Z1VybFxyXG4gIH1cclxuXHJcbiAgc2V0RGVidWdQYWNrYWdlTmFtZSAoZGVidWdQYWNrYWdlTmFtZSkge1xyXG4gICAgdGhpcy5kZWJ1Z1BhY2thZ2VOYW1lID0gZGVidWdQYWNrYWdlTmFtZVxyXG4gIH1cclxuXHJcbiAgZ2V0U2VydmVQYXRoIChpc1Byb2plY3QpIHtcclxuICAgIGlmIChpc1Byb2plY3QgJiYgdGhpcy5wcm9qZWN0SWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYmFzZVVybCArICcvJyArIHRoaXMuYXBwTmFtZSArICcvJyArIHRoaXMucHJvamVjdElkXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXBwTmFtZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5iYXNlVXJsICsgJy8nICsgdGhpcy5hcHBOYW1lXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5iYXNlVXJsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDojrflj5blm77lhYPnmoR1cmzlnLDlnYDvvIwg5Zu+5YWDdXJs5bCG5L2c5Li65Zu+5YWD55qE5ZSv5LiA5qCH6K+G77yM5q2k5pa55rOV5qC55o2u5Zu+5YWD5a6a5LmJLT7lm77lhYN1cmzov5vooYznu5/kuIDovazmjaJcclxuICAgKiBAcGFyYW0ge29iamVjdH0gcGVsIOWbvuWFg+WumuS5iSB7cGFja2FnZU5hbWUsIHZlcnNpb24sIHBhdGh9IOmUruWAvOWvueixoVxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0Q29tcG9uZW50VXJsICh7IHBhY2thZ2VOYW1lLCBwYXRoIH0pIHtcclxuICAgIGlmICh0aGlzLmRlYnVnUGFja2FnZSAmJiBwYWNrYWdlTmFtZSA9PT0gdGhpcy5kZWJ1Z1BhY2thZ2UubmFtZSkge1xyXG4gICAgICByZXR1cm4gYCR7dGhpcy5kZWJ1Z1VybH0vJHtwYXRofWBcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VVcmx9LyR7cGFja2FnZU5hbWV9LyR7cGF0aH1gXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXRQYWNrYWdlSlNPTlVybCAocGFja2FnZU5hbWUpIHtcclxuICAgIHJldHVybiBgJHt0aGlzLmJhc2VVcmx9LyR7cGFja2FnZU5hbWV9L3BhY2thZ2UuanNvbmBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOiOt+WPluWbvuWFg+eahOacjeWKoeWvueixoeeahOWQjeensFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwZWwg5Zu+5YWD5a6a5LmJXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBnZXRDb21wb25lbnRMaWJOYW1lICh7IHBhY2thZ2VOYW1lLCBwYXRoIH0pIHtcclxuICAgIHJldHVybiBgLyR7cGFja2FnZU5hbWV9LyR7cGF0aH1gXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkIENvbXBvbmVudCBCeSBJZO+8mlxyXG4gICAqIHtcclxuICAgKiAgIHBhY2thZ2VOYW1lOiAnQGd3L3dpbmQtcGVscy1zdGFuZGFyZCcsXHJcbiAgICogICBwYXRoOiAnLi9idWlsZC9jb250YWluZXIxLnBlbC5qcydcclxuICAgKiB9XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhY2thZ2VOYW1lIE5wbSBwYWNrYWdlIGZyb20gd2hpY2ggY29tcG9uZW50IGJlbG9uZ3MgdG9cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBDb21wb25lbnQgcGF0aFxyXG4gICAqL1xyXG4gIGFzeW5jIGxvYWRDb21wb25lbnQgKGNvbXBvbmVudFBhdGgpIHtcclxuICAgIGxldCBwYWNrYWdlTmFtZSwgcGF0aFxyXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRQYXRoID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBwYWNrYWdlTmFtZSA9IGNvbXBvbmVudFBhdGgucGFja2FnZU5hbWVcclxuICAgICAgcGF0aCA9IGNvbXBvbmVudFBhdGgucGF0aFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8g5oq95Y+W5YyF5ZKM6Lev5b6EXHJcbiAgICAgIGNvbnN0IHBhdGhzID0gY29tcG9uZW50UGF0aC5zcGxpdCgnLycpXHJcbiAgICAgIGlmIChwYXRoc1swXS5zdGFydHNXaXRoKCdAJykpIHtcclxuICAgICAgICBwYWNrYWdlTmFtZSA9IHBhdGhzLnNwbGljZSgwLCAyKS5qb2luKCcvJylcclxuICAgICAgICBwYXRoID0gcGF0aHMuam9pbignLycpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFja2FnZU5hbWUgPSBwYXRocy5zcGxpY2UoMCwgMSkuam9pbignLycpXHJcbiAgICAgICAgcGF0aCA9IHBhdGhzLmpvaW4oJy8nKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29tcG9uZW50VXJsID0gdGhpcy5nZXRDb21wb25lbnRVcmwoeyBwYWNrYWdlTmFtZSwgcGF0aCB9KVxyXG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLmdldENvbXBvbmVudChjb21wb25lbnRVcmwpXHJcblxyXG4gICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOWvueS6juato+WcqOWKoOi9veS4reeahO+8jCDnm5HlkKzmiJDlip/jgIHlpLHotKXnmoTlm57osINcclxuICAgIGlmICh0aGlzLmNvbXBvbmVudExvYWRpbmcuZ2V0KGNvbXBvbmVudFVybCkgPT09ICdsb2FkaW5nJykge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMub24oJ2NvbXBvbmVudC1yZWFkeScsICh1cmwsIGZjcCkgPT4ge1xyXG4gICAgICAgICAgaWYgKHVybCA9PT0gY29tcG9uZW50VXJsKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoZmNwKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5vbignY29tcG9uZW50LWZhaWwnLCB1cmwgPT4ge1xyXG4gICAgICAgICAgaWYgKHVybCA9PT0gY29tcG9uZW50VXJsKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobnVsbClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudExvYWRpbmcuZ2V0KGNvbXBvbmVudFVybCkgPT09ICdmYWlsJykge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29tcG9uZW50TG9hZGluZy5zZXQoY29tcG9uZW50VXJsLCAnbG9hZGluZycpXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBmY3AgPSBhd2FpdCB0aGlzLmRvTG9hZENvbXBvbmVudCh7IHBhY2thZ2VOYW1lLCBwYXRoIH0pXHJcbiAgICAgIHRoaXMubm90aWZ5Q29tcG9uZW50TG9hZGVkKGNvbXBvbmVudFVybCwgZmNwKVxyXG5cclxuICAgICAgdGhpcy5jb21wb25lbnRDYWNoZVtjb21wb25lbnRVcmxdID0gZmNwXHJcbiAgICAgIHJldHVybiBmY3BcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhpcy5zZXRQZWxMb2FkRmFpbChjb21wb25lbnRVcmwpXHJcbiAgICAgIGxvZygn57uE5Lu25Yqg6L295byC5bi4JywgZSlcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGRvTG9hZENvbXBvbmVudCAoe1xyXG4gICAgcGFja2FnZU5hbWUsIHBhdGhcclxuICB9KSB7XHJcbiAgICBhd2FpdCB0aGlzLmNvbmZpcm1QYWNrYWdlRGVwZW5kZW5jaWVzKHBhY2thZ2VOYW1lKVxyXG4gICAgLy8gTG9hZCBEZXBlbmRlY2llcyBpbiBwYWNrYWdlLmpzb25cclxuICAgIGNvbnN0IGZjcCA9IGF3YWl0IHRoaXMubG9hZENvbXBvbmVudFNjcmlwdCh7IHBhY2thZ2VOYW1lLCBwYXRoIH0pXHJcbiAgICBpZiAoZmNwKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucHJlcGFyZUNvbXBvbmVudChmY3AsIHsgcGFja2FnZU5hbWUsIHBhdGggfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmNwXHJcbiAgfVxyXG5cclxuICBhc3luYyBwcmVwYXJlQ29tcG9uZW50IChmY3AsIHtcclxuICAgIHBhY2thZ2VOYW1lLFxyXG4gICAgcGF0aFxyXG4gIH0pIHtcclxuICAgIGZjcC5wYWNrYWdlTmFtZSA9IHBhY2thZ2VOYW1lXHJcbiAgICBmY3AucGF0aCA9IHBhdGhcclxuXHJcbiAgICBpZiAoZmNwLnJlcXVpcmVzICYmIGZjcC5yZXF1aXJlcy5sZW5ndGgpIHtcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkRXh0ZXJuYWxzKGZjcC5yZXF1aXJlcylcclxuICAgIH1cclxuXHJcbiAgICAvLyDlr7nkuo5pY29u5a6a5LmJ5Lit5ZCr5pyJ5Zu+54mH5ZCN5ZCO57yA77yM6K6k5Li65piv6aKE6KeI5Zu+5YWD77yM6K6+572ucHJldmlld1VybFxyXG4gICAgY29uc3QgaW1hZ2VOYW1lUmVnZXggPSAvXFwuKGpwZ3xnaWZ8cG5nfGpwZWd8c3ZnKSQvaVxyXG4gICAgaWYgKGZjcC5pY29uICYmIGltYWdlTmFtZVJlZ2V4LnRlc3QoZmNwLmljb24pKSB7XHJcbiAgICAgIGlmICh0aGlzLmRlYnVnUGFja2FnZU5hbWUgPT09IHBhY2thZ2VOYW1lICYmIHRoaXMuZGVidWdVcmwpIHtcclxuICAgICAgICBmY3AucHJldmlld1VybCA9IGAke3RoaXMuZGVidWdVcmx9JHtmY3AuaWNvbn1gXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmNwLnByZXZpZXdVcmwgPSBgL25wbV9wYWNrYWdlcy8ke3BhY2thZ2VOYW1lfS8ke2ZjcC5pY29ufWBcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOWkhOeQhua4suafk+WZqO+8jOWKoOi9vea4suafk+WZqOS+nei1llxyXG4gICAgaWYgKGZjcC5jb21wb25lbnQpIHtcclxuICAgICAgbGV0IGZjID0gZmNwLmNvbXBvbmVudFxyXG5cclxuICAgICAgLy8g5pSv5oyB5byC5q2l55qE5Yqg6L295oOF5Ya1XHJcbiAgICAgIGlmICh0eXBlb2YgZmMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBpZiAoZmMuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FzeW5jRnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBmYyA9IChhd2FpdCBmYygpKS5kZWZhdWx0XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsb2coJ+e7hOS7tiBDb21wb25lbnTlrprkuYnmnKrliqDovb3liLAnLCBmY3ApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBub3RpZnlDb21wb25lbnRMb2FkZWQgKHVybCwgZmNwKSB7XHJcbiAgICB0aGlzLmNvbXBvbmVudExvYWRpbmcuc2V0KHVybCwgJ2xvYWRlZCcpXHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmV2ZW50Q2FsbGJhY2tzLmZpbHRlcihpdGVtID0+IGl0ZW0uZXZlbnROYW1lID09PSAnY29tcG9uZW50LXJlYWR5JykuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpdGVtLmNhbGxiYWNrKHVybCwgZmNwKVxyXG4gICAgICB9KVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBjYWxsYmFjayBlcnJvciBpZ25vcmVkXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRQZWxMb2FkRmFpbCAodXJsKSB7XHJcbiAgICB0aGlzLmNvbXBvbmVudExvYWRpbmcuc2V0KHVybCwgJ2ZhaWwnKVxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5ldmVudENhbGxiYWNrcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmV2ZW50TmFtZSA9PT0gJ2NvbXBvbmVudC1mYWlsJykuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpdGVtLmNhbGxiYWNrKHVybClcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gY2FsbGJhY2sgZXJyb3IgaWdub3JlZFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuZXZlbnRDYWxsYmFja3MucHVzaCh7XHJcbiAgICAgIGV2ZW50TmFtZSxcclxuICAgICAgY2FsbGJhY2tcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIOWKoOi9veWJjeerr+e7hOS7tueahOS7o+egge+8jOaUr+aMgTLnp43mlrnlvI8gZ2xvYmFsVGhpcyDlj4ogYW1kXHJcbiAgICAgKi9cclxuICBhc3luYyBsb2FkQ29tcG9uZW50U2NyaXB0ICh7XHJcbiAgICBwYWNrYWdlTmFtZSxcclxuICAgIHBhdGhcclxuICB9KSB7XHJcbiAgICBjb25zdCBzY3JpcHRVcmwgPSB0aGlzLmdldENvbXBvbmVudFVybCh7IHBhY2thZ2VOYW1lLCBwYXRoIH0pXHJcbiAgICBjb25zdCBzY3JpcHRMaWJOYW1lID0gdGhpcy5nZXRDb21wb25lbnRMaWJOYW1lKHsgcGFja2FnZU5hbWUsIHBhdGggfSlcclxuXHJcbiAgICAvLyDliqDovb3lm77lhYPohJrmnKzvvIzlhbbkuK3mr4/kuKrlm77lhYPlnKjnvJbor5Hml7bpg73lt7Lnu4/orr7nva7liLDkuoZ3aW5kb3fmoLnkuIrvvIzku6Xlm77lhYN1cmzkuLrlj6/ku6VrZXlcclxuICAgIGF3YWl0IHRoaXMubG9hZFNjcmlwdChzY3JpcHRVcmwpXHJcblxyXG4gICAgLy8gZ2xvYmFsVGhpc+aWueW8j1xyXG4gICAgaWYgKHdpbmRvd1tzY3JpcHRMaWJOYW1lXSkge1xyXG4gICAgICByZXR1cm4gd2luZG93W3NjcmlwdExpYk5hbWVdLmRlZmF1bHRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICAqIOiOt+WPlue7hOS7tlxyXG4gICAgICog5LyY5YWI5LuOZmNDYWNoZSDkuK3ojrflj5bvvIjkvp3otZbniYjmnKzvvInvvJvlho3ku453aW5kb3fkuIvojrflj5bvvIjkuI3kvp3otZbniYjmnKzvvIlcclxuICAgICAqIEBwYXJhbSB7Kn0gcGVsXHJcbiAgICAgKi9cclxuICBnZXRDb21wb25lbnQgKGNvbXBvbmVudFVybCkge1xyXG4gICAgaWYgKHRoaXMuY29tcG9uZW50Q2FjaGVbY29tcG9uZW50VXJsXSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRDYWNoZVtjb21wb25lbnRVcmxdXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAqIOWKoOi9veWbvuWFg+WvueWklumDqOeahOS7o+eggeS+nei1llxyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBleHRlcm5hbHMg5aSW6YOo5L6d6LWW5bqT5YiX6KGoXHJcbiAgICAqL1xyXG4gIGFzeW5jIGxvYWRFeHRlcm5hbHMgKGV4dGVybmFscykge1xyXG4gICAgY29uc3Qgd2VicGFja0V4dGVybmFsc01lcmdlZCA9IE9iamVjdC5hc3NpZ24od2VicGFja0V4dGVybmFscywgd2luZG93Lmdsb2JhbEV4dGVybmFsQ29uZmlnKVxyXG5cclxuICAgIGZvciAoY29uc3QgZXh0ZXJuYWwgb2YgZXh0ZXJuYWxzKSB7XHJcbiAgICAgIC8vIOiOt+WPluWklumDqOS+nei1luW6k+eahOS4i+i9veWcsOWdgCBleHRlcm5hbOS4uuWbvuWFg+S4reWjsOaYjueahOS+nei1luW6k+WQjeensCDkvovlpoIgJ2VjaGFydHMnXHJcbiAgICAgIGNvbnN0IGV4dGVybmFsTW9kdWxlID0gd2VicGFja0V4dGVybmFsc01lcmdlZC5leHRlcm5hbHMuZmlsdGVyKGV4ID0+IGV4dGVybmFsID09PSBleC5tb2R1bGUpWzBdXHJcblxyXG4gICAgICAvLyDmnInlo7DmmI7liJnkuIvovb3vvIzlkKbliJnlv73nlaVcclxuICAgICAgaWYgKGV4dGVybmFsTW9kdWxlKSB7XHJcbiAgICAgICAgLy8g5Yik5pat56ys5LiJ5pa55bqT5aaC5p6c5bey57uP5Zyo5YWo5bGA5Yqg6L2977yM5YiZ55u05o6l5L2/55So5YWo5bGA55qE5bqTXHJcbiAgICAgICAgaWYgKGV4dGVybmFsTW9kdWxlLnJvb3QgJiYgd2luZG93W2V4dGVybmFsTW9kdWxlLnJvb3RdKSB7XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g6aaW5YWI6YCS5b2S5LiL6L295L6d6LWW55qE5L6d6LWWXHJcbiAgICAgICAgaWYgKGV4dGVybmFsTW9kdWxlLmRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5sb2FkRXh0ZXJuYWxzKGV4dGVybmFsTW9kdWxlLmRlcGVuZGVuY2llcylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGV4dGVybmFsTGliUGF0aCA9IGAke3RoaXMudW5wa2dVcmx9LyR7ZXh0ZXJuYWxNb2R1bGUuZGlzdH1gXHJcblxyXG4gICAgICAgIGlmIChleHRlcm5hbE1vZHVsZS5zdHlsZSkge1xyXG4gICAgICAgICAgLy8g5aSW55WM5a6a5LmJ55qE5qC35byP5Yqg6L295Zyw5Z2AXHJcbiAgICAgICAgICBpZiAodGhpcy5leHRlcm5hbE9wdGlvbnNbZXh0ZXJuYWxNb2R1bGUubW9kdWxlXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXh0ZXJuYWxPcHRpb25zW2V4dGVybmFsTW9kdWxlLm1vZHVsZV0pKSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXh0ZXJuYWxDc3NQYXRoIG9mIHRoaXMuZXh0ZXJuYWxPcHRpb25zW2V4dGVybmFsTW9kdWxlLm1vZHVsZV0pIHtcclxuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2NyaXB0KGV4dGVybmFsQ3NzUGF0aClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ+WKoOi9veW6lOeUqOWumuS5ieeahOagt+W8j+Wksei0pSDlnLDlnYDmmK86JyArIHRoaXMuZXh0ZXJuYWxPcHRpb25zW2V4dGVybmFsTW9kdWxlLm1vZHVsZV0pXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmV4dGVybmFsT3B0aW9uc1tleHRlcm5hbE1vZHVsZS5tb2R1bGVdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRTY3JpcHQodGhpcy5leHRlcm5hbE9wdGlvbnNbZXh0ZXJuYWxNb2R1bGUubW9kdWxlXSlcclxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ+WKoOi9veW6lOeUqOWumuS5ieeahOagt+W8j+Wksei0pSDlnLDlnYDmmK86JyArIHRoaXMuZXh0ZXJuYWxPcHRpb25zW2V4dGVybmFsTW9kdWxlLm1vZHVsZV0pXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHRlcm5hbE1vZHVsZS5zdHlsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2NyaXB0KGAke3RoaXMudW5wa2dVcmx9LyR7ZXh0ZXJuYWxNb2R1bGUuc3R5bGV9YClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zY3JpcHRMb2FkaW5nUHJvbWlzZXNbZXh0ZXJuYWxMaWJQYXRoXSkge1xyXG4gICAgICAgICAgLy8gbG9hZGpz5Lya6Ieq5Yqo5aSE55CG6YeN5aSN5Yqg6L2955qE6Zeu6aKY77yM5Zug5q2k5q2k5aSE5peg6ZyA5YGa6aKd5aSW5aSE55CGXHJcbiAgICAgICAgICB0aGlzLnNjcmlwdExvYWRpbmdQcm9taXNlc1tleHRlcm5hbExpYlBhdGhdID0gKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBsb2coJ+WKoOi9veesrOS4ieaWueW6kzonICsgZXh0ZXJuYWxMaWJQYXRoKVxyXG5cclxuICAgICAgICAgICAgICBhd2FpdCBsb2FkanMoZXh0ZXJuYWxMaWJQYXRoLCB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5Qcm9taXNlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBmdW5jdGlvbiAoc2NyaXB0UGF0aCwgc2NyaXB0RWwpIHtcclxuICAgICAgICAgICAgICAgICAgc2NyaXB0RWwuY3Jvc3NPcmlnaW4gPSB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+esrOS4ieaWueW6k+WKoOi9veW8guW4uCAnLCBgJHtleHRlcm5hbE1vZHVsZS5tb2R1bGV9YClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSkoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5zY3JpcHRMb2FkaW5nUHJvbWlzZXNbZXh0ZXJuYWxMaWJQYXRoXVxyXG4gICAgICAgIC8vIOi/memHjOW/hemhu+WKoOi9veWujOaIkOaJjeagh+W/l+S4umxvYWRlZOOAguWQpuWImeWklumDqOWPr+iDveivt+axguW5tuWPkeS4i+i9ve+8jOmCo+S5iOWQjumdoueahOW5tuWPkeWIpOaWreaIkOWKn+S9huWKoOi9veacquWujOaIkFxyXG4gICAgICAgIHdpbmRvdy5mY0V4dGVybmFsTG9hZGVkLnB1c2goZXh0ZXJuYWxNb2R1bGUubW9kdWxlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxvZygn5b+955Wl5bqTOicgKyBleHRlcm5hbClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDliqDovb3mjIflrprnmoTlrZfkvZPvvIjmjInlkI3np7DvvIlcclxuICAgICAqIEBwYXJhbSBuYW1lIOWtl+S9k+WQjeensFxyXG4gICAgICogQHBhcmFtIHBrZyDlrZfkvZPmiYDlnKjnmoTlm77lhYPljIUs5YyF5ous5ZCN56ew5ZKM54mI5pys6buY6K6k5Li6QGd3L3dlYi1mb250LWFzc2V0c0BsYXRlc3RcclxuICAgICAqL1xyXG4gIGFzeW5jIGxvYWRGb250IChwa2csIG5hbWUsIHVybCkge1xyXG4gICAgaWYgKCFuYW1lIHx8IHRoaXMubG9hZGVkRm9udHMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAvLyDpu5jorqTlrZfkvZPkuI3pnIDopoHliqDovb1cclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBmb250RmFjZU5hbWUgPSBwa2cgPyAocGtnICsgJy8nICsgdXJsKSA6IG5hbWVcclxuICAgICAgbGV0IGZvbnRVcmwgPSB0aGlzLmdldFNlcnZlUGF0aCgpICsgJy9ucG1fcGFja2FnZXMvJyArIChwa2cgPyAocGtnICsgJy8nICsgdXJsKSA6IG5hbWUpXHJcblxyXG4gICAgICAvLyDov5nmmK/lr7kxMTDnmoTlrZfkvZPliqDovb3nmoTlhbzlrrnvvIwgMTEw5Zu+57q45Lit77yM5a2X5L2T5piv55u05o6l5oyJ5ZCN56ew5L+d5a2Y5Yiw5Zu+5YWD5Lit55qEIOS+i+WmgiBncm90ZXNraWHvvIzmsqHmnInnm7TmjqXmj5DkvpvlrZfkvZPlnLDlnYDnmoR1cmzjgIIg5omA5Lul6ZyA6KaB5qC55o2u5a2X5L2T5YyF5LitSlNPTueahOWumuS5ieiOt+WPluWFt+S9k+eahOWtl+S9k3VybFxyXG4gICAgICAvLyDov5vooYzov5vkuIDmraXnmoTliqDovb1cclxuICAgICAgaWYgKCFwa2cgJiYgIXVybCAmJiBuYW1lLmluZGV4T2YoJy53b2ZmJykgPT09IC0xKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5jb25maXJtUGFja2FnZURlcGVuZGVuY2llcygnQGd3L3dlYi1mb250LWFzc2V0cycpXHJcbiAgICAgICAgaWYgKHRoaXMucGFja2FnZUpTT05DYWNoZVsnQGd3L3dlYi1mb250LWFzc2V0cyddKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5wYWNrYWdlSlNPTkNhY2hlWydAZ3cvd2ViLWZvbnQtYXNzZXRzJ10uZm9udHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgZm9udFVybCA9IHRoaXMuZ2V0U2VydmVQYXRoKCkgKyAnL25wbV9wYWNrYWdlcy9AZ3cvd2ViLWZvbnQtYXNzZXRzLycgKyB0aGlzLnBhY2thZ2VKU09OQ2FjaGVbJ0Bndy93ZWItZm9udC1hc3NldHMnXS5mb250c1tuYW1lXS51cmxcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign5Yqg6L295a2X5L2T5Zyw5Z2A5pyq5om+5YiwJywgbmFtZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGh0dHBzOi8vbG9jYWxob3N0OjMwMDEvc2NhZGEvbnBtX3BhY2thZ2VzL0Bndy93ZWItZm9udC1hc3NldHMvcGFja2FnZS5qc29uXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG5hbWUg55u05o6l5o+Q5L6b5a6M5pW05Zyw5Z2A55qE5oOF5Ya1XHJcbiAgICAgIGNvbnN0IGZmID0gbmV3IEZvbnRGYWNlKGZvbnRGYWNlTmFtZSwgYHVybCgke2ZvbnRVcmx9KWApXHJcblxyXG4gICAgICBhd2FpdCBmZi5sb2FkKClcclxuICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZmKVxyXG5cclxuICAgICAgdGhpcy5sb2FkZWRGb250cy5wdXNoKG5hbWUpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+WKoOi9veWtl+S9k+W8guW4uCcsIG5hbWUsIHBrZywgZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGxvYWRDc3MgKGhyZWYpIHtcclxuICAgIC8vIENyZWF0ZSBuZXcgbGluayBFbGVtZW50XHJcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXHJcblxyXG4gICAgLy8gc2V0IHRoZSBhdHRyaWJ1dGVzIGZvciBsaW5rIGVsZW1lbnRcclxuICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnXHJcblxyXG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJ1xyXG5cclxuICAgIGxpbmsuaHJlZiA9IGhyZWZcclxuXHJcbiAgICAvLyBHZXQgSFRNTCBoZWFkIGVsZW1lbnQgdG8gYXBwZW5kXHJcbiAgICAvLyBsaW5rIGVsZW1lbnQgdG8gaXRcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdIRUFEJylbMF0uYXBwZW5kQ2hpbGQobGluaylcclxuICB9XHJcblxyXG4gIGFzeW5jIGxvYWRTY3JpcHQgKHVybCkge1xyXG4gICAgaWYgKCF0aGlzLnNjcmlwdExvYWRpbmdQcm9taXNlc1t1cmxdKSB7XHJcbiAgICAgIC8vIGxvYWRqc+S8muiHquWKqOWkhOeQhumHjeWkjeWKoOi9veeahOmXrumimO+8jOWboOatpOatpOWkhOaXoOmcgOWBmumineWkluWkhOeQhlxyXG4gICAgICB0aGlzLnNjcmlwdExvYWRpbmdQcm9taXNlc1t1cmxdID0gKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgbG9nKCfliqDovb3lupM6JyArIHVybClcclxuICAgICAgICAgIGF3YWl0IGxvYWRqcyh1cmwsIHtcclxuICAgICAgICAgICAgcmV0dXJuUHJvbWlzZTogdHJ1ZSxcclxuICAgICAgICAgICAgYmVmb3JlOiBmdW5jdGlvbiAoc2NyaXB0UGF0aCwgc2NyaXB0RWwpIHtcclxuICAgICAgICAgICAgICBzY3JpcHRFbC5jcm9zc09yaWdpbiA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfnrKzkuInmlrnlupPliqDovb3lvILluLggJywgYCR7dXJsfWApXHJcbiAgICAgICAgfVxyXG4gICAgICB9KSgpXHJcbiAgICB9XHJcbiAgICBhd2FpdCB0aGlzLnNjcmlwdExvYWRpbmdQcm9taXNlc1t1cmxdXHJcbiAgfVxyXG5cclxuICBzZXRQYWNrYWdlQ2FjaGUgKHBhY2thZ2VOYW1lLCBwYWNrYWdlT2JqZWN0KSB7XHJcbiAgICB0aGlzLnBhY2thZ2VKU09OQ2FjaGVbcGFja2FnZU5hbWVdID0gcGFja2FnZU9iamVjdFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICAgKiDliLfmlrBEZWJ1Z+aooeW8j+S4i+S7juacrOWcsOW8gOWPkeacjeWKoeWKoOi9veeahOe7hOS7tlxyXG4gICAgICovXHJcbiAgYXN5bmMgcmVsb2FkRGVidWdDYWNoZSAoKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNhY2hlS2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuZmNDYWNoZSkpIHtcclxuICAgICAgaWYgKGNhY2hlS2V5LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5zY3JpcHRMb2FkaW5nUHJvbWlzZXNbY2FjaGVLZXldXHJcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2NyaXB0KGNhY2hlS2V5KVxyXG5cclxuICAgICAgICBpZiAod2luZG93W3RoaXMuc2NyaXB0VXJsTGliTmFtZVtjYWNoZUtleV1dKSB7XHJcbiAgICAgICAgICBjb25zdCBmY3AgPSB3aW5kb3dbdGhpcy5zY3JpcHRVcmxMaWJOYW1lW2NhY2hlS2V5XV0uZGVmYXVsdFxyXG5cclxuICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdEZjcChmY3AsIHRoaXMucGVsQ2FjaGVCeUxpYk5hbWVbdGhpcy5zY3JpcHRVcmxMaWJOYW1lW2NhY2hlS2V5XV0pXHJcbiAgICAgICAgICB0aGlzLmZjQ2FjaGVbY2FjaGVLZXldID0gZmNwXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDojrflj5ZwYWNrYWdlLmpzb27lrprkuYnlr7nosaFcclxuICAgKiBAcGFyYW0geyp9IHBhY2thZ2VOYW1lXHJcbiAgICogQHJldHVybnNcclxuICAgKi9cclxuICBhc3luYyBnZXRQYWNrYWdlSlNPTiAocGFja2FnZU5hbWUpIHtcclxuICAgIGlmICh0aGlzLnBhY2thZ2VKU09OQ2FjaGVbcGFja2FnZU5hbWVdKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhY2thZ2VKU09OQ2FjaGVbcGFja2FnZU5hbWVdXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZGVidWdVcmwpIHtcclxuICAgICAgY29uc3QgcGFja2FnZU9iamVjdCA9IGF3YWl0IHRoaXMuZ2V0RGVidWdQYWNrYWdlKClcclxuICAgICAgaWYgKHBhY2thZ2VPYmplY3QgJiYgcGFja2FnZU9iamVjdC5uYW1lID09PSBwYWNrYWdlTmFtZSkge1xyXG4gICAgICAgIHRoaXMucHJlZml4UGFja2FnZUpTT04ocGFja2FnZU9iamVjdCwgdGhpcy5kZWJ1Z1VybClcclxuICAgICAgICB0aGlzLnNldFBhY2thZ2VDYWNoZShwYWNrYWdlT2JqZWN0Lm5hbWUsIHBhY2thZ2VPYmplY3QpXHJcbiAgICAgICAgcmV0dXJuIHBhY2thZ2VPYmplY3RcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhY2thZ2VKU09OVXJsID0gdGhpcy5nZXRQYWNrYWdlSlNPTlVybChwYWNrYWdlTmFtZSlcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYWNrYWdlT2JqZWN0ID0gYXdhaXQga3kuZ2V0KHBhY2thZ2VKU09OVXJsKS5qc29uKClcclxuICAgICAgdGhpcy5wcmVmaXhQYWNrYWdlSlNPTihwYWNrYWdlT2JqZWN0LCB0aGlzLmJhc2VVcmwgKyAnLycgKyBwYWNrYWdlTmFtZSlcclxuICAgICAgdGhpcy5zZXRQYWNrYWdlQ2FjaGUocGFja2FnZU9iamVjdClcclxuXHJcbiAgICAgIHJldHVybiBwYWNrYWdlT2JqZWN0XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05QTSBQYWNrYWdlIE5vdCBMb2FkZWQ6ICcsIHBhY2thZ2VOYW1lLCBlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJlZml4UGFja2FnZUpTT04gKHBhY2thZ2VPYmplY3QsIHByZWZpeCkge1xyXG4gICAgaWYgKHBhY2thZ2VPYmplY3QuaWNvbikge1xyXG4gICAgICBwYWNrYWdlT2JqZWN0Lmljb24gPSBgJHtwcmVmaXh9LyR7cGFja2FnZU9iamVjdC5pY29ufWBcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGNvbSBvZiBwYWNrYWdlT2JqZWN0LmNvbXBvbmVudHMgPz8gW10pIHtcclxuICAgICAgaWYgKGNvbS5pY29uKSB7XHJcbiAgICAgICAgY29tLmljb24gPSBgJHtwcmVmaXh9LyR7Y29tLmljb259YFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDliqDovb3nu4Tku7bljIXnmoTkvp3otZbotYTmupBcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFja2FnZU5hbWUg57uE5Lu25YyF5ZCN56ewXHJcbiAgICovXHJcbiAgYXN5bmMgY29uZmlybVBhY2thZ2VEZXBlbmRlbmNpZXMgKHBhY2thZ2VOYW1lKSB7XHJcbiAgICBjb25zdCBwYWNrYWdlT2JqZWN0ID0gYXdhaXQgdGhpcy5nZXRQYWNrYWdlSlNPTihwYWNrYWdlTmFtZSlcclxuICAgIGlmIChwYWNrYWdlT2JqZWN0ICYmIHBhY2thZ2VPYmplY3QuZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZEV4dGVybmFscyhPYmplY3Qua2V5cyhwYWNrYWdlT2JqZWN0LmRlcGVuZGVuY2llcykpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBsb2FkSlNPTiAocGF0aCkge1xyXG4gICAgcmV0dXJuIGF3YWl0IGt5LmdldChwYXRoKS5qc29uKClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVsZW1lbnRMb2FkZXJcclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cclxuLy8gaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuLy8gaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcbi8vIOi/memHjOmcgOimgeazqOmHiuaOiVJlYWN044CBUmVhY3RET00g5ZCm5YiZ5q2k5YyF5Lya5ZCM5aSW5Zu057yW6L6R5Zmo562J6aG555uu5LiA6LW35L2/55So44CC6ICM5byA5Y+R5pyf6Ze055qE5Zu+5YWD55qEUmVhY3TmmK/pop3lpJZsb2Fk55qE77yM5Lya5ZyoXHJcbi8vIFJlYWN0IGhvb2sg5L2/55So5pe25oql6ZSZIOWboOatpO+8jFJlYWN05LiA5a6a6KaB5L2/55Sod2luZG935YWo5bGA55qEUmVhY3Tlr7nosaFcclxuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vUmVuZGVyZXInXHJcblxyXG5jb25zdCBjb250ZXh0UHJvdmlkZXJzID0gW1xyXG4gIC8vIGFudGQgQ29uZmlnUHJvdmlkZXIg5LiK5LiL5paHXHJcbiAgKGpzeCkgPT4ge1xyXG4gICAgaWYgKHdpbmRvdy5hbnRkKSB7XHJcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHdpbmRvdy5hbnRkLkNvbmZpZ1Byb3ZpZGVyLCB7XHJcbiAgICAgICAgcHJlZml4Q2xzOiAod2luZG93LnRvcC5mZHJlQ29uZmlnICYmIHdpbmRvdy50b3AuZmRyZUNvbmZpZy5hbnRkUHJlZml4Q2xzKSB8fCAnYW50J1xyXG4gICAgICB9LCBbanN4XSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBqc3hcclxuICAgIH1cclxuICB9LFxyXG4gIC4uLih3aW5kb3cudG9wLmZkcmVDb25maWcgJiYgd2luZG93LnRvcC5mZHJlQ29uZmlnLnJlYWN0Q29udGV4dFByb3ZpZGVycykgfHwgW11cclxuXVxyXG5cclxuLyoqXHJcbiAqIOa4suafk+WPilJlYWN057uE5Lu25Yiw5Zu+5YWD5bGCXHJcbiAqIEBwYXJhbSBKU1hDb21wb25lbnQgIFJlYWN057uE5Lu25a6e5L6LXHJcbiAqIEBwYXJhbSBlbCAgaHRtbOWxglxyXG4gKiBAcGFyYW0gaW5pdE9wdGlvbiBSZWFjdOWIneWni+WMluWxnuaAp1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhY3RSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcclxuICBjb25zdHJ1Y3RvciAoSlNYQ29tcG9uZW50LCBlbCwgaW5pdE9wdGlvbiA9IHt9KSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLmVsID0gZWxcclxuICAgIHRoaXMuSlNYQ29tcG9uZW50ID0gSlNYQ29tcG9uZW50XHJcbiAgICB0aGlzLnByb3BzID0gaW5pdE9wdGlvblxyXG5cclxuICAgIC8vIOinhOiMg++8mlJlYWN0RE9N55qEcmVuZGVy5pa55rOV5Lya6L+U5Zue57uE5Lu255qEcmVmIO+8iGNsYXNz57uE5Lu277yJ77yM54S26ICM5Zyo5pyA5pawUmVhY3RET03mj4/ov7DkuK3vvIxyZWbkuI3kvJrnq4vliLvov5Tlm55cclxuICAgIC8vIFJlYWN0RE9NLnJlbmRlcigpIGN1cnJlbnRseSByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSByb290IFJlYWN0Q29tcG9uZW50IGluc3RhbmNlLiBIb3dldmVyLFxyXG4gICAgLy8gdXNpbmcgdGhpcyByZXR1cm4gdmFsdWUgaXMgbGVnYWN5IGFuZCBzaG91bGQgYmUgYXZvaWRlZCBiZWNhdXNlIGZ1dHVyZSB2ZXJzaW9ucyBvZiBSZWFjdCBtYXkgcmVuZGVyXHJcbiAgICAvLyBjb21wb25lbnRzIGFzeW5jaHJvbm91c2x5IGluIHNvbWUgY2FzZXMuIElmIHlvdSBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSByb290IFJlYWN0Q29tcG9uZW50IGluc3RhbmNlLFxyXG4gICAgLy8gdGhlIHByZWZlcnJlZCBzb2x1dGlvbiBpcyB0byBhdHRhY2ggYSBjYWxsYmFjayByZWYgdG8gdGhlIHJvb3QgZWxlbWVudC5cclxuICAgIC8vIHRoaXMucHJvcHMucmVmQ2FsbGJhY2sgPSByZWYgPT4ge1xyXG4gICAgLy8gICAgIHRoaXMucmVuZGVyUmVmID0gcmVmO1xyXG4gICAgLy8gfTtcclxuICAgIGlmICghdGhpcy5wcm9wcy5yZWYpIHtcclxuICAgICAgdGhpcy5wcm9wcy5yZWYgPSBSZWFjdC5jcmVhdGVSZWYoKVxyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJSZWYgPSB0aGlzLnByb3BzLnJlZlxyXG4gICAgdGhpcy5yb290ID0gUmVhY3RET00uY3JlYXRlUm9vdChlbClcclxuXHJcbiAgICB0aGlzLnJvb3QucmVuZGVyKHRoaXMuZ2V0UmVuZGVySW5zdGFuY2UoKSlcclxuICB9XHJcblxyXG4gIGdldFJlbmRlckluc3RhbmNlICgpIHtcclxuICAgIGxldCByZWFjdEluc3RhbmNlID0gUmVhY3QuY3JlYXRlRWxlbWVudCh0aGlzLkpTWENvbXBvbmVudCwgdGhpcy5wcm9wcylcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRleHRQcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcmVhY3RJbnN0YW5jZSA9IGNvbnRleHRQcm92aWRlcnNbaV0ocmVhY3RJbnN0YW5jZSlcclxuICAgIH1cclxuICAgIHJldHVybiByZWFjdEluc3RhbmNlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDmjZXojrfnu4Tku7blkJHlpJbop6blj5HnmoTkuovku7ZcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCDkuovku7ZcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayDlm57osIPlh73mlbBcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMucHJvcHMsIHtcclxuICAgICAgW2V2ZW50XTogY2FsbGJhY2tcclxuICAgIH0pXHJcbiAgICBSZWFjdERPTS5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudCh0aGlzLkpTWENvbXBvbmVudCwgdGhpcy5wcm9wcyksIHRoaXMuZWwpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDov5vooYzmuLLmn5Plmajmlrnms5XosIPnlKjvvIhNVlZN5oOF5Ya15LiL5aSn5aSa5pWw5LiN5o6o6I2Q77yJXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCDmlrnms5XlkI3np7BcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIOWPguaVsOaVsOe7hFxyXG4gICAqL1xyXG4gIGludm9rZSAobWV0aG9kLCBhcmdzKSB7XHJcbiAgICAvLyDlj6rmnInnsbvnu4Tku7bmiY3og73osIPnlKjmlrnms5VcclxuICAgIC8vIFJlbmRlciBhIFJlYWN0IGVsZW1lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBjb250YWluZXIgYW5kXHJcbiAgICAvLyByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGNvbXBvbmVudCAob3IgcmV0dXJucyBudWxsIGZvciBzdGF0ZWxlc3MgY29tcG9uZW50cykuXHJcbiAgICBpZiAodGhpcy5yZW5kZXJSZWYgJiYgdGhpcy5yZW5kZXJSZWYuY3VycmVudCAmJiB0aGlzLnJlbmRlclJlZi5jdXJyZW50W21ldGhvZF0gJiYgdHlwZW9mIHRoaXMucmVuZGVyUmVmLmN1cnJlbnRbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJSZWYuY3VycmVudFttZXRob2RdKC4uLihhcmdzIHx8IFtdKSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+aXoOazleiwg+eUqOaXoOeKtuaAgee7hOS7tueahOaWueazlSEnKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog5pu05paw5bGe5oCn77yM5L2/5riy5p+T5Zmo6YeN5paw5riy5p+TXHJcbiAgICogUmVhY3TnmoTomZrmi59ET03mnLrliLbkvb/lvpdSZWFjdOeahOe7hOS7tumHjeaWsHJlbmRlcuWIsOWFt+S9k2VsZW1lbnTml7bkvJrlj6rmm7TmlrDlj5jljJbnmoRET01cclxuICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgc2V0T3B0aW9uIChvcHRpb24pIHtcclxuICAgIHRoaXMudXBkYXRlUHJvcHMob3B0aW9uKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog5pu05paw5bGe5oCn77yM5L2/5riy5p+T5Zmo6YeN5paw5riy5p+TXHJcbiAgICogUmVhY3TnmoTomZrmi59ET03mnLrliLbkvb/lvpdSZWFjdOeahOe7hOS7tumHjeaWsHJlbmRlcuWIsOWFt+S9k2VsZW1lbnTml7bkvJrlj6rmm7TmlrDlj5jljJbnmoRET01cclxuICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICovXHJcbiAgdXBkYXRlUHJvcHMgKHByb3BzKSB7XHJcbiAgICAvLyDmlrnms5Xor7TmmI7vvJogSWYgdGhlIFJlYWN0IGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBjb250YWluZXIsXHJcbiAgICAvLyB0aGlzIHdpbGwgcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlIGxhdGVzdCBSZWFjdCBlbGVtZW50LlxyXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzXHJcblxyXG4gICAgaWYgKHRoaXMucmVuZGVyUmVmICYmIHRoaXMucmVuZGVyUmVmLmN1cnJlbnQgJiYgdHlwZW9mIHRoaXMucmVuZGVyUmVmLmN1cnJlbnQudXBkYXRlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5yZW5kZXJSZWYuY3VycmVudC51cGRhdGVQcm9wcyhwcm9wcylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlYWN0RE9NLnJlbmRlcih0aGlzLmdldFJlbmRlckluc3RhbmNlKCksIHRoaXMuZWwpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDph43mlrDluIPlsYDvvIwg5ZON5bqU5riy5p+T5YWD57Sg56e75Yqo44CB5aSn5bCP6LCD5pW0562J5oOF5Ya1XHJcbiAgICogUmVhY3TnmoTomZrmi59ET03mnLrliLbkvb/lvpdSZWFjdOeahOe7hOS7tumHjeaWsHJlbmRlcuWIsOWFt+S9k2VsZW1lbnTml7bkvJrlj6rmm7TmlrDlj5jljJbnmoRET01cclxuICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICovXHJcbiAgbGF5b3V0IChvcHRpb24pIHtcclxuICAgIFJlYWN0RE9NLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KHRoaXMuSlNYQ29tcG9uZW50LCBvcHRpb24pLCB0aGlzLmVsKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog5riy5p+T6ZSA5q+BXHJcbiAgICovXHJcbiAgZGVzdHJveSAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJlYWN0RE9NIOaWueazleivtOaYjlxyXG4gICAgICogUmVtb3ZlIGEgbW91bnRlZCBSZWFjdCBjb21wb25lbnQgZnJvbSB0aGUgRE9NIGFuZCBjbGVhbiB1cCBpdHMgZXZlbnQgaGFuZGxlcnMgYW5kIHN0YXRlLlxyXG4gICAgICogSWYgbm8gY29tcG9uZW50IHdhcyBtb3VudGVkIGluIHRoZSBjb250YWluZXIsIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYSBjb21wb25lbnQgd2FzIHVubW91bnRlZCBhbmQgZmFsc2UgaWYgdGhlcmUgd2FzIG5vIGNvbXBvbmVudCB0byB1bm1vdW50LlxyXG4gICAgICovXHJcbiAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuZWwpXHJcbiAgICBpZiAodGhpcy5yZW5kZXJSZWYpIHtcclxuICAgICAgdGhpcy5yZW5kZXJSZWYgPSBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiDpobXpnaLmuLLmn5Pmir3osaHnsbvvvIzmj5DkvpvnlYzpnaLmuLLmn5PjgIHmlbDmja7ojrflj5bnrYnmlrnpnaLmk43kvZznmoTnu5/kuIDmjqXlj6NcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcclxuICAvKipcclxuICAgKiDmm7TmlrDlsZ7mgKfvvIzkvb/muLLmn5Plmajph43mlrDmuLLmn5NcclxuICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICogQGRlcHJlY2F0ZWQg5pS55Li6dXBkYXRlUHJvcHNcclxuICAgKi9cclxuICBzZXRPcHRpb24gKG9wdGlvbikge31cclxuXHJcbiAgLyoqXHJcbiAgICog5pu05paw5bGe5oCn77yM5L2/5riy5p+T5Zmo6YeN5paw5riy5p+TXHJcbiAgICogQHBhcmFtIG9wdGlvblxyXG4gICAqL1xyXG4gIHVwZGF0ZVByb3BzIChwcm9wcykge31cclxuXHJcbiAgLyoqXHJcbiAgICog6YeN5paw5biD5bGA77yMIOWTjeW6lOa4suafk+WFg+e0oOenu+WKqOOAgeWkp+Wwj+iwg+aVtOetieaDheWGtVxyXG4gICAqIEBwYXJhbSBvcHRpb25cclxuICAgKi9cclxuICBsYXlvdXQgKG9wdGlvbikge31cclxuXHJcbiAgLyoqXHJcbiAgICog6L+b6KGM5riy5p+T5Zmo5pa55rOV6LCD55So77yITVZWTeaDheWGteS4i+Wkp+WkmuaVsOS4jeaOqOiNkO+8iVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2Qg5pa55rOV5ZCN56ewXHJcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyDlj4LmlbDmlbDnu4RcclxuICAgKi9cclxuICBpbnZva2UgKG1ldGhvZCwgYXJncykge31cclxuXHJcbiAgLyoqXHJcbiAgICog5o2V6I6357uE5Lu25ZCR5aSW6Kem5Y+R55qE5pe26Ze0XHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQg5LqL5Lu2XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sg5Zue6LCD5Ye95pWwXHJcbiAgICovXHJcbiAgb24gKGV2ZW50LCBjYWxsYmFjaykge31cclxuXHJcbiAgLyoqXHJcbiAgICog5riy5p+T6ZSA5q+BXHJcbiAgICovXHJcbiAgZGVzdHJveSAoKSB7fVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJlciBmcm9tICcuL1JlbmRlcmVyJ1xyXG5cclxuLyoqXHJcbiAqIOa4suafk1Zhbm5pbGFKUyDnu4Tku7ZcclxuICogQHBhcmFtIGVsICBodG1s5bGCXHJcbiAqIEBwYXJhbSBpbml0T3B0aW9uIFJlYWN05Yid5aeL5YyW5bGe5oCnXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYW5pbGxhUmVuZGVyIGV4dGVuZHMgUmVuZGVyZXIge1xyXG4gIGNvbnN0cnVjdG9yIChWYW5uaWxhQ29tcG9uZW50LCBlbCwgaW5pdE9wdGlvbiA9IHt9KSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLmVsID0gZWxcclxuICAgIHRoaXMuVmFubmlsYUNvbXBvbmVudCA9IFZhbm5pbGFDb21wb25lbnRcclxuICAgIHRoaXMucHJvcHMgPSBpbml0T3B0aW9uXHJcblxyXG4gICAgdGhpcy5nZXRSZW5kZXJJbnN0YW5jZSgpLm1vdW50KGVsKVxyXG4gIH1cclxuXHJcbiAgZ2V0UmVuZGVySW5zdGFuY2UgKCkge1xyXG4gICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgdGhpcy5WYW5uaWxhQ29tcG9uZW50KHRoaXMucHJvcHMpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog5o2V6I6357uE5Lu25ZCR5aSW6Kem5Y+R55qE5pe26Ze0XHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQg5LqL5Lu2XHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sg5Zue6LCD5Ye95pWwXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgb24gKGV2ZW50LCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5pbnN0YW5jZS5vbihldmVudCwgY2FsbGJhY2spXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDov5vooYzmuLLmn5Plmajmlrnms5XosIPnlKjvvIhNVlZN5oOF5Ya15LiL5aSn5aSa5pWw5LiN5o6o6I2Q77yJXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCDmlrnms5XlkI3np7BcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIOWPguaVsOaVsOe7hFxyXG4gICAqL1xyXG4gIGludm9rZSAobWV0aG9kLCBhcmdzKSB7XHJcbiAgICBpZiAodGhpcy5nZXRSZW5kZXJJbnN0YW5jZSgpW21ldGhvZF0pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVySW5zdGFuY2UoKVttZXRob2RdLmFwcGx5KHRoaXMuZ2V0UmVuZGVySW5zdGFuY2UoKSwgYXJncylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNldE9wdGlvbiAob3B0aW9uKSB7XHJcbiAgICB0aGlzLnVwZGF0ZVByb3BzKG9wdGlvbilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOabtOaWsOWxnuaAp++8jOS9v+a4suafk+WZqOmHjeaWsOa4suafk1xyXG4gICAqIEBwYXJhbSBvcHRpb25cclxuICAgKi9cclxuICB1cGRhdGVQcm9wcyAocHJvcHMpIHtcclxuICAgIHRoaXMuZ2V0UmVuZGVySW5zdGFuY2UoKS51cGRhdGUocHJvcHMpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDph43mlrDluIPlsYDvvIwg5ZON5bqU5riy5p+T5YWD57Sg56e75Yqo44CB5aSn5bCP6LCD5pW0562J5oOF5Ya1XHJcbiAgICogQHBhcmFtIG9wdGlvblxyXG4gICAqL1xyXG4gIGxheW91dCAob3B0aW9uKSB7XHJcbiAgICB0aGlzLmdldFJlbmRlckluc3RhbmNlKCkubGF5b3V0KG9wdGlvbilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIOa4suafk+mUgOavgVxyXG4gICAqL1xyXG4gIGRlc3Ryb3kgKCkge1xyXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95ICYmIHRoaXMuaW5zdGFuY2UuZGVzdHJveSgpXHJcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8vIGltcG9ydCBfIGZyb20gJ2xvZGFzaCdcclxuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xyXG5pbXBvcnQgbG9kYXNoVGVtcGxhdGUgZnJvbSAnbG9kYXNoL3RlbXBsYXRlJ1xyXG5pbXBvcnQgbG9kYXNoQXQgZnJvbSAnbG9kYXNoL2F0J1xyXG5jb25zdCBsb2cgPSBkZWJ1Zygncmc6dGVtcGxhdGUnKVxyXG5jb25zdCBjb21waWxlZFRlbXBsYXRlcyA9IG5ldyBNYXAoKVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGVtcGxhdGUgKHRwbFN0cmluZywgdmFyaWFibGVzLCB1dGlscykge1xyXG4gIGlmIChsb2cuZW5hYmxlZCkge1xyXG4gICAgbG9nKCfmqKHmnb/orqHnrpcnLCB0cGxTdHJpbmcsIHZhcmlhYmxlcylcclxuICB9XHJcblxyXG4gIC8vIOWinuWKoGxvZGFzaOWvueixoeWIsOWPmOmHj++8jOS9v+aJgOaciV/nmoTmlrnms5Xpg73og73ooqvooajovr7lvI/kvb/nlKhcclxuICBpZiAodXRpbHMpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odmFyaWFibGVzLCB1dGlscylcclxuICB9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgaWYgKHR5cGVvZiB0cGxTdHJpbmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpZiAodHBsU3RyaW5nLnN0YXJ0c1dpdGgoJyR7JykpIHtcclxuICAgICAgLy8g55SoICR7fSDkuLrmqKHmnb/orqHnrpcg6L+Z57G75oCn6IO95L2O5a655piT5Ye66ZSZXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICAgICAgY29uc3QgZnVuYyA9IG5ldyBGdW5jdGlvbiguLi5PYmplY3Qua2V5cyh2YXJpYWJsZXMpLCBgcmV0dXJuIFxcYCR7dHBsU3RyaW5nfVxcYDtgKVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuYyguLi5PYmplY3QudmFsdWVzKHZhcmlhYmxlcykpXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRwbFN0cmluZy5tYXRjaCgve3soW1xcc1xcU10rPyl9fS9nKSkge1xyXG4gICAgICAvLyDnlKgge3sg5Li65qih5p2/6L+b6KGM6K6h566X55qE5oOF5Ya1IH19XHJcbiAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZXMuZ2V0KHRwbFN0cmluZykpIHtcclxuICAgICAgICBjb21waWxlZFRlbXBsYXRlcy5zZXQodHBsU3RyaW5nLCBsb2Rhc2hUZW1wbGF0ZSh0cGxTdHJpbmcsIHtcclxuICAgICAgICAgIGludGVycG9sYXRlOiAve3soW1xcc1xcU10rPyl9fS9nXHJcbiAgICAgICAgfSkpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGVzLmdldCh0cGxTdHJpbmcpKHZhcmlhYmxlcylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGphdmFzY3JpcHTooajovr7lvI/mg4XlhrXjgIJcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyDpppblhYjovazmjaLkuLrmqKHmnb/lrZfnrKbkuLJcclxuICAgICAgICBjb25zdCB0cGxTdHJpbmdDb24gPSBge3tKU09OLnN0cmluZ2lmeSgke3RwbFN0cmluZ30pfX1gXHJcbiAgICAgICAgLy8g55SobG9kYXNo6K6h566X5Li657uT5p6c5a2X56ym5LiyXHJcbiAgICAgICAgY29uc3QgdHBsRnVuYyA9IGxvZGFzaFRlbXBsYXRlKHRwbFN0cmluZ0Nvbiwge1xyXG4gICAgICAgICAgaW50ZXJwb2xhdGU6IC97eyhbXFxzXFxTXSs/KX19L2dcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvLyDlj43lkJHop6PnoIFcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0cGxGdW5jKHZhcmlhYmxlcykpXHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyDmjInot6/lvoTojrflj5ZcclxuICAgICAgICAgIHJldHVybiBsb2Rhc2hBdCh2YXJpYWJsZXMsIHRwbFN0cmluZylbMF1cclxuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XHJcbiAgICAgICAgICAvLyDmjIlKU09O5qC85byPXHJcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0cGxTdHJpbmcpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB0cGxTdHJpbmdcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1RlbXBsYXRlU3RyICh0cGxTdHJpbmcpIHtcclxuICByZXR1cm4gdHBsU3RyaW5nLnN0YXJ0c1dpdGgoJyR7JykgfHwgdHBsU3RyaW5nLnN0YXJ0c1dpdGgoJ3t7JylcclxufVxyXG4iLCJleHBvcnQgY29uc3QgcGUgPSAodmFsKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbClcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gdmFsXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc3QgPSAodmFsKSA9PiB7XHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbClcclxufVxyXG4iLCJpbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gJ25hbm9pZCdcclxuaW1wb3J0IGNhbWVsQ2FzZSBmcm9tICdsb2Rhc2gvY2FtZWxDYXNlJ1xyXG5pbXBvcnQgdHJpbSBmcm9tICdsb2Rhc2gvdHJpbSdcclxuY29uc3QgbmFub2lkID0gY3VzdG9tQWxwaGFiZXQoJzEyMzQ1Njc4OTBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsIDEwKVxyXG5cclxuZXhwb3J0IHtcclxuICBjYW1lbENhc2UsXHJcbiAgdHJpbSxcclxuICBuYW5vaWRcclxufVxyXG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8qISBNSVQgTGljZW5zZSDCqSBTaW5kcmUgU29yaHVzICovXG5cbmNvbnN0IGdsb2JhbHMgPSB7fTtcblxuY29uc3QgZ2V0R2xvYmFsID0gcHJvcGVydHkgPT4ge1xuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgJiYgcHJvcGVydHkgaW4gc2VsZikge1xuXHRcdHJldHVybiBzZWxmO1xuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiBwcm9wZXJ0eSBpbiB3aW5kb3cpIHtcblx0XHRyZXR1cm4gd2luZG93O1xuXHR9XG5cblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCAmJiBwcm9wZXJ0eSBpbiBnbG9iYWwpIHtcblx0XHRyZXR1cm4gZ2xvYmFsO1xuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB7XG5cdFx0cmV0dXJuIGdsb2JhbFRoaXM7XG5cdH1cbn07XG5cbmNvbnN0IGdsb2JhbFByb3BlcnRpZXMgPSBbXG5cdCdIZWFkZXJzJyxcblx0J1JlcXVlc3QnLFxuXHQnUmVzcG9uc2UnLFxuXHQnUmVhZGFibGVTdHJlYW0nLFxuXHQnZmV0Y2gnLFxuXHQnQWJvcnRDb250cm9sbGVyJyxcblx0J0Zvcm1EYXRhJ1xuXTtcblxuZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBnbG9iYWxQcm9wZXJ0aWVzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxzLCBwcm9wZXJ0eSwge1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IGdsb2JhbE9iamVjdCA9IGdldEdsb2JhbChwcm9wZXJ0eSk7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGdsb2JhbE9iamVjdCAmJiBnbG9iYWxPYmplY3RbcHJvcGVydHldO1xuXHRcdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmJpbmQoZ2xvYmFsT2JqZWN0KSA6IHZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbmNvbnN0IGlzT2JqZWN0ID0gdmFsdWUgPT4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbmNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIGdsb2JhbHMuQWJvcnRDb250cm9sbGVyID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgc3VwcG9ydHNTdHJlYW1zID0gdHlwZW9mIGdsb2JhbHMuUmVhZGFibGVTdHJlYW0gPT09ICdmdW5jdGlvbic7XG5jb25zdCBzdXBwb3J0c0Zvcm1EYXRhID0gdHlwZW9mIGdsb2JhbHMuRm9ybURhdGEgPT09ICdmdW5jdGlvbic7XG5cbmNvbnN0IG1lcmdlSGVhZGVycyA9IChzb3VyY2UxLCBzb3VyY2UyKSA9PiB7XG5cdGNvbnN0IHJlc3VsdCA9IG5ldyBnbG9iYWxzLkhlYWRlcnMoc291cmNlMSB8fCB7fSk7XG5cdGNvbnN0IGlzSGVhZGVyc0luc3RhbmNlID0gc291cmNlMiBpbnN0YW5jZW9mIGdsb2JhbHMuSGVhZGVycztcblx0Y29uc3Qgc291cmNlID0gbmV3IGdsb2JhbHMuSGVhZGVycyhzb3VyY2UyIHx8IHt9KTtcblxuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzb3VyY2UpIHtcblx0XHRpZiAoKGlzSGVhZGVyc0luc3RhbmNlICYmIHZhbHVlID09PSAndW5kZWZpbmVkJykgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVzdWx0LmRlbGV0ZShrZXkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBkZWVwTWVyZ2UgPSAoLi4uc291cmNlcykgPT4ge1xuXHRsZXQgcmV0dXJuVmFsdWUgPSB7fTtcblx0bGV0IGhlYWRlcnMgPSB7fTtcblxuXHRmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuXHRcdFx0aWYgKCEoQXJyYXkuaXNBcnJheShyZXR1cm5WYWx1ZSkpKSB7XG5cdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHR9XG5cblx0XHRcdHJldHVyblZhbHVlID0gWy4uLnJldHVyblZhbHVlLCAuLi5zb3VyY2VdO1xuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0Zm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcblx0XHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSAmJiBSZWZsZWN0LmhhcyhyZXR1cm5WYWx1ZSwga2V5KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVlcE1lcmdlKHJldHVyblZhbHVlW2tleV0sIHZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblZhbHVlID0gey4uLnJldHVyblZhbHVlLCBba2V5XTogdmFsdWV9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPYmplY3Qoc291cmNlLmhlYWRlcnMpKSB7XG5cdFx0XHRcdGhlYWRlcnMgPSBtZXJnZUhlYWRlcnMoaGVhZGVycywgc291cmNlLmhlYWRlcnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVyblZhbHVlLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHR9XG5cblx0cmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuY29uc3QgcmVxdWVzdE1ldGhvZHMgPSBbXG5cdCdnZXQnLFxuXHQncG9zdCcsXG5cdCdwdXQnLFxuXHQncGF0Y2gnLFxuXHQnaGVhZCcsXG5cdCdkZWxldGUnXG5dO1xuXG5jb25zdCByZXNwb25zZVR5cGVzID0ge1xuXHRqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG5cdHRleHQ6ICd0ZXh0LyonLFxuXHRmb3JtRGF0YTogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuXHRhcnJheUJ1ZmZlcjogJyovKicsXG5cdGJsb2I6ICcqLyonXG59O1xuXG5jb25zdCByZXRyeU1ldGhvZHMgPSBbXG5cdCdnZXQnLFxuXHQncHV0Jyxcblx0J2hlYWQnLFxuXHQnZGVsZXRlJyxcblx0J29wdGlvbnMnLFxuXHQndHJhY2UnXG5dO1xuXG5jb25zdCByZXRyeVN0YXR1c0NvZGVzID0gW1xuXHQ0MDgsXG5cdDQxMyxcblx0NDI5LFxuXHQ1MDAsXG5cdDUwMixcblx0NTAzLFxuXHQ1MDRcbl07XG5cbmNvbnN0IHJldHJ5QWZ0ZXJTdGF0dXNDb2RlcyA9IFtcblx0NDEzLFxuXHQ0MjksXG5cdDUwM1xuXTtcblxuY29uc3Qgc3RvcCA9IFN5bWJvbCgnc3RvcCcpO1xuXG5jbGFzcyBIVFRQRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG5cdFx0Ly8gU2V0IHRoZSBtZXNzYWdlIHRvIHRoZSBzdGF0dXMgdGV4dCwgc3VjaCBhcyBVbmF1dGhvcml6ZWQsXG5cdFx0Ly8gd2l0aCBzb21lIGZhbGxiYWNrcy4gVGhpcyBtZXNzYWdlIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQuXG5cdFx0c3VwZXIoXG5cdFx0XHRyZXNwb25zZS5zdGF0dXNUZXh0IHx8XG5cdFx0XHRTdHJpbmcoXG5cdFx0XHRcdChyZXNwb25zZS5zdGF0dXMgPT09IDAgfHwgcmVzcG9uc2Uuc3RhdHVzKSA/XG5cdFx0XHRcdFx0cmVzcG9uc2Uuc3RhdHVzIDogJ1Vua25vd24gcmVzcG9uc2UgZXJyb3InXG5cdFx0XHQpXG5cdFx0KTtcblx0XHR0aGlzLm5hbWUgPSAnSFRUUEVycm9yJztcblx0XHR0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG5cdH1cbn1cblxuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihyZXF1ZXN0KSB7XG5cdFx0c3VwZXIoJ1JlcXVlc3QgdGltZWQgb3V0Jyk7XG5cdFx0dGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG5cdFx0dGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblx0fVxufVxuXG5jb25zdCBkZWxheSA9IG1zID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vLyBgUHJvbWlzZS5yYWNlKClgIHdvcmthcm91bmQgKCM5MSlcbmNvbnN0IHRpbWVvdXQgPSAocmVxdWVzdCwgYWJvcnRDb250cm9sbGVyLCBvcHRpb25zKSA9PlxuXHRuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0Y29uc3QgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpZiAoYWJvcnRDb250cm9sbGVyKSB7XG5cdFx0XHRcdGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QobmV3IFRpbWVvdXRFcnJvcihyZXF1ZXN0KSk7XG5cdFx0fSwgb3B0aW9ucy50aW1lb3V0KTtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLXRoZW4gKi9cblx0XHRvcHRpb25zLmZldGNoKHJlcXVlc3QpXG5cdFx0XHQudGhlbihyZXNvbHZlKVxuXHRcdFx0LmNhdGNoKHJlamVjdClcblx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG5cdFx0XHR9KTtcblx0XHQvKiBlc2xpbnQtZW5hYmxlIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLXRoZW4gKi9cblx0fSk7XG5cbmNvbnN0IG5vcm1hbGl6ZVJlcXVlc3RNZXRob2QgPSBpbnB1dCA9PiByZXF1ZXN0TWV0aG9kcy5pbmNsdWRlcyhpbnB1dCkgPyBpbnB1dC50b1VwcGVyQ2FzZSgpIDogaW5wdXQ7XG5cbmNvbnN0IGRlZmF1bHRSZXRyeU9wdGlvbnMgPSB7XG5cdGxpbWl0OiAyLFxuXHRtZXRob2RzOiByZXRyeU1ldGhvZHMsXG5cdHN0YXR1c0NvZGVzOiByZXRyeVN0YXR1c0NvZGVzLFxuXHRhZnRlclN0YXR1c0NvZGVzOiByZXRyeUFmdGVyU3RhdHVzQ29kZXNcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZVJldHJ5T3B0aW9ucyA9IChyZXRyeSA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgcmV0cnkgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdC4uLmRlZmF1bHRSZXRyeU9wdGlvbnMsXG5cdFx0XHRsaW1pdDogcmV0cnlcblx0XHR9O1xuXHR9XG5cblx0aWYgKHJldHJ5Lm1ldGhvZHMgJiYgIUFycmF5LmlzQXJyYXkocmV0cnkubWV0aG9kcykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3JldHJ5Lm1ldGhvZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuXHR9XG5cblx0aWYgKHJldHJ5LnN0YXR1c0NvZGVzICYmICFBcnJheS5pc0FycmF5KHJldHJ5LnN0YXR1c0NvZGVzKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcigncmV0cnkuc3RhdHVzQ29kZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQuLi5kZWZhdWx0UmV0cnlPcHRpb25zLFxuXHRcdC4uLnJldHJ5LFxuXHRcdGFmdGVyU3RhdHVzQ29kZXM6IHJldHJ5QWZ0ZXJTdGF0dXNDb2Rlc1xuXHR9O1xufTtcblxuLy8gVGhlIG1heGltdW0gdmFsdWUgb2YgYSAzMmJpdCBpbnQgKHNlZSBpc3N1ZSAjMTE3KVxuY29uc3QgbWF4U2FmZVRpbWVvdXQgPSAyMTQ3NDgzNjQ3O1xuXG5jbGFzcyBLeSB7XG5cdGNvbnN0cnVjdG9yKGlucHV0LCBvcHRpb25zID0ge30pIHtcblx0XHR0aGlzLl9yZXRyeUNvdW50ID0gMDtcblx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHRcdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0XHQvLyBUT0RPOiBjcmVkZW50aWFscyBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRoZSBzcGVjIGNoYW5nZSBpcyBpbXBsZW1lbnRlZCBpbiBhbGwgYnJvd3NlcnMuIENvbnRleHQ6IGh0dHBzOi8vd3d3LmNocm9tZXN0YXR1cy5jb20vZmVhdHVyZS80NTM5NDczMzEyMzUwMjA4XG5cdFx0XHRjcmVkZW50aWFsczogdGhpcy5faW5wdXQuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJyxcblx0XHRcdC4uLm9wdGlvbnMsXG5cdFx0XHRoZWFkZXJzOiBtZXJnZUhlYWRlcnModGhpcy5faW5wdXQuaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKSxcblx0XHRcdGhvb2tzOiBkZWVwTWVyZ2Uoe1xuXHRcdFx0XHRiZWZvcmVSZXF1ZXN0OiBbXSxcblx0XHRcdFx0YmVmb3JlUmV0cnk6IFtdLFxuXHRcdFx0XHRhZnRlclJlc3BvbnNlOiBbXVxuXHRcdFx0fSwgb3B0aW9ucy5ob29rcyksXG5cdFx0XHRtZXRob2Q6IG5vcm1hbGl6ZVJlcXVlc3RNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5faW5wdXQubWV0aG9kKSxcblx0XHRcdHByZWZpeFVybDogU3RyaW5nKG9wdGlvbnMucHJlZml4VXJsIHx8ICcnKSxcblx0XHRcdHJldHJ5OiBub3JtYWxpemVSZXRyeU9wdGlvbnMob3B0aW9ucy5yZXRyeSksXG5cdFx0XHR0aHJvd0h0dHBFcnJvcnM6IG9wdGlvbnMudGhyb3dIdHRwRXJyb3JzICE9PSBmYWxzZSxcblx0XHRcdHRpbWVvdXQ6IHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgPT09ICd1bmRlZmluZWQnID8gMTAwMDAgOiBvcHRpb25zLnRpbWVvdXQsXG5cdFx0XHRmZXRjaDogb3B0aW9ucy5mZXRjaCB8fCBnbG9iYWxzLmZldGNoXG5cdFx0fTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5faW5wdXQgIT09ICdzdHJpbmcnICYmICEodGhpcy5faW5wdXQgaW5zdGFuY2VvZiBVUkwgfHwgdGhpcy5faW5wdXQgaW5zdGFuY2VvZiBnbG9iYWxzLlJlcXVlc3QpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgaW5wdXRgIG11c3QgYmUgYSBzdHJpbmcsIFVSTCwgb3IgUmVxdWVzdCcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9vcHRpb25zLnByZWZpeFVybCAmJiB0eXBlb2YgdGhpcy5faW5wdXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpZiAodGhpcy5faW5wdXQuc3RhcnRzV2l0aCgnLycpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignYGlucHV0YCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgc2xhc2ggd2hlbiB1c2luZyBgcHJlZml4VXJsYCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX29wdGlvbnMucHJlZml4VXJsLmVuZHNXaXRoKCcvJykpIHtcblx0XHRcdFx0dGhpcy5fb3B0aW9ucy5wcmVmaXhVcmwgKz0gJy8nO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9pbnB1dCA9IHRoaXMuX29wdGlvbnMucHJlZml4VXJsICsgdGhpcy5faW5wdXQ7XG5cdFx0fVxuXG5cdFx0aWYgKHN1cHBvcnRzQWJvcnRDb250cm9sbGVyKSB7XG5cdFx0XHR0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBnbG9iYWxzLkFib3J0Q29udHJvbGxlcigpO1xuXHRcdFx0aWYgKHRoaXMuX29wdGlvbnMuc2lnbmFsKSB7XG5cdFx0XHRcdHRoaXMuX29wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9vcHRpb25zLnNpZ25hbCA9IHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcblx0XHR9XG5cblx0XHR0aGlzLnJlcXVlc3QgPSBuZXcgZ2xvYmFscy5SZXF1ZXN0KHRoaXMuX2lucHV0LCB0aGlzLl9vcHRpb25zKTtcblxuXHRcdGlmICh0aGlzLl9vcHRpb25zLnNlYXJjaFBhcmFtcykge1xuXHRcdFx0Y29uc3Qgc2VhcmNoUGFyYW1zID0gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyh0aGlzLl9vcHRpb25zLnNlYXJjaFBhcmFtcykudG9TdHJpbmcoKTtcblx0XHRcdGNvbnN0IHVybCA9IHRoaXMucmVxdWVzdC51cmwucmVwbGFjZSgvKD86XFw/Lio/KT8oPz0jfCQpLywgc2VhcmNoUGFyYW1zKTtcblxuXHRcdFx0Ly8gVG8gcHJvdmlkZSBjb3JyZWN0IGZvcm0gYm91bmRhcnksIENvbnRlbnQtVHlwZSBoZWFkZXIgc2hvdWxkIGJlIGRlbGV0ZWQgZWFjaCB0aW1lIHdoZW4gbmV3IFJlcXVlc3QgaW5zdGFudGlhdGVkIGZyb20gYW5vdGhlciBvbmVcblx0XHRcdGlmICgoKHN1cHBvcnRzRm9ybURhdGEgJiYgdGhpcy5fb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgZ2xvYmFscy5Gb3JtRGF0YSkgfHwgdGhpcy5fb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSAmJiAhKHRoaXMuX29wdGlvbnMuaGVhZGVycyAmJiB0aGlzLl9vcHRpb25zLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSkge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3QuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtdHlwZScpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlcXVlc3QgPSBuZXcgZ2xvYmFscy5SZXF1ZXN0KG5ldyBnbG9iYWxzLlJlcXVlc3QodXJsLCB0aGlzLnJlcXVlc3QpLCB0aGlzLl9vcHRpb25zKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fb3B0aW9ucy5qc29uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX29wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX29wdGlvbnMuanNvbik7XG5cdFx0XHR0aGlzLnJlcXVlc3QuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cdFx0XHR0aGlzLnJlcXVlc3QgPSBuZXcgZ2xvYmFscy5SZXF1ZXN0KHRoaXMucmVxdWVzdCwge2JvZHk6IHRoaXMuX29wdGlvbnMuYm9keX0pO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZuID0gYXN5bmMgKCkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuX29wdGlvbnMudGltZW91dCA+IG1heFNhZmVUaW1lb3V0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgXFxgdGltZW91dFxcYCBvcHRpb24gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAke21heFNhZmVUaW1lb3V0fWApO1xuXHRcdFx0fVxuXG5cdFx0XHRhd2FpdCBkZWxheSgxKTtcblx0XHRcdGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoKCk7XG5cblx0XHRcdGZvciAoY29uc3QgaG9vayBvZiB0aGlzLl9vcHRpb25zLmhvb2tzLmFmdGVyUmVzcG9uc2UpIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRcdFx0Y29uc3QgbW9kaWZpZWRSZXNwb25zZSA9IGF3YWl0IGhvb2soXG5cdFx0XHRcdFx0dGhpcy5yZXF1ZXN0LFxuXHRcdFx0XHRcdHRoaXMuX29wdGlvbnMsXG5cdFx0XHRcdFx0dGhpcy5fZGVjb3JhdGVSZXNwb25zZShyZXNwb25zZS5jbG9uZSgpKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChtb2RpZmllZFJlc3BvbnNlIGluc3RhbmNlb2YgZ2xvYmFscy5SZXNwb25zZSkge1xuXHRcdFx0XHRcdHJlc3BvbnNlID0gbW9kaWZpZWRSZXNwb25zZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9kZWNvcmF0ZVJlc3BvbnNlKHJlc3BvbnNlKTtcblxuXHRcdFx0aWYgKCFyZXNwb25zZS5vayAmJiB0aGlzLl9vcHRpb25zLnRocm93SHR0cEVycm9ycykge1xuXHRcdFx0XHR0aHJvdyBuZXcgSFRUUEVycm9yKHJlc3BvbnNlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYG9uRG93bmxvYWRQcm9ncmVzc2AgaXMgcGFzc2VkLCBpdCB1c2VzIHRoZSBzdHJlYW0gQVBJIGludGVybmFsbHlcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRpZiAodGhpcy5fb3B0aW9ucy5vbkRvd25sb2FkUHJvZ3Jlc3MpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLm9uRG93bmxvYWRQcm9ncmVzcyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgb25Eb3dubG9hZFByb2dyZXNzYCBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXN1cHBvcnRzU3RyZWFtcykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignU3RyZWFtcyBhcmUgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGVudmlyb25tZW50LiBgUmVhZGFibGVTdHJlYW1gIGlzIG1pc3NpbmcuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RyZWFtKHJlc3BvbnNlLmNsb25lKCksIHRoaXMuX29wdGlvbnMub25Eb3dubG9hZFByb2dyZXNzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHRcdH07XG5cblx0XHRjb25zdCBpc1JldHJpYWJsZU1ldGhvZCA9IHRoaXMuX29wdGlvbnMucmV0cnkubWV0aG9kcy5pbmNsdWRlcyh0aGlzLnJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IGlzUmV0cmlhYmxlTWV0aG9kID8gdGhpcy5fcmV0cnkoZm4pIDogZm4oKTtcblxuXHRcdGZvciAoY29uc3QgW3R5cGUsIG1pbWVUeXBlXSBvZiBPYmplY3QuZW50cmllcyhyZXNwb25zZVR5cGVzKSkge1xuXHRcdFx0cmVzdWx0W3R5cGVdID0gYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3QuaGVhZGVycy5zZXQoJ2FjY2VwdCcsIHRoaXMucmVxdWVzdC5oZWFkZXJzLmdldCgnYWNjZXB0JykgfHwgbWltZVR5cGUpO1xuXG5cdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHJlc3VsdCkuY2xvbmUoKTtcblxuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2pzb24nKSB7XG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMucGFyc2VKc29uKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3B0aW9ucy5wYXJzZUpzb24oYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2VbdHlwZV0oKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdF9jYWxjdWxhdGVSZXRyeURlbGF5KGVycm9yKSB7XG5cdFx0dGhpcy5fcmV0cnlDb3VudCsrO1xuXG5cdFx0aWYgKHRoaXMuX3JldHJ5Q291bnQgPCB0aGlzLl9vcHRpb25zLnJldHJ5LmxpbWl0ICYmICEoZXJyb3IgaW5zdGFuY2VvZiBUaW1lb3V0RXJyb3IpKSB7XG5cdFx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBIVFRQRXJyb3IpIHtcblx0XHRcdFx0aWYgKCF0aGlzLl9vcHRpb25zLnJldHJ5LnN0YXR1c0NvZGVzLmluY2x1ZGVzKGVycm9yLnJlc3BvbnNlLnN0YXR1cykpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHJldHJ5QWZ0ZXIgPSBlcnJvci5yZXNwb25zZS5oZWFkZXJzLmdldCgnUmV0cnktQWZ0ZXInKTtcblx0XHRcdFx0aWYgKHJldHJ5QWZ0ZXIgJiYgdGhpcy5fb3B0aW9ucy5yZXRyeS5hZnRlclN0YXR1c0NvZGVzLmluY2x1ZGVzKGVycm9yLnJlc3BvbnNlLnN0YXR1cykpIHtcblx0XHRcdFx0XHRsZXQgYWZ0ZXIgPSBOdW1iZXIocmV0cnlBZnRlcik7XG5cdFx0XHRcdFx0aWYgKE51bWJlci5pc05hTihhZnRlcikpIHtcblx0XHRcdFx0XHRcdGFmdGVyID0gRGF0ZS5wYXJzZShyZXRyeUFmdGVyKSAtIERhdGUubm93KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFmdGVyICo9IDEwMDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLnJldHJ5Lm1heFJldHJ5QWZ0ZXIgIT09ICd1bmRlZmluZWQnICYmIGFmdGVyID4gdGhpcy5fb3B0aW9ucy5yZXRyeS5tYXhSZXRyeUFmdGVyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gYWZ0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzID09PSA0MTMpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBCQUNLT0ZGX0ZBQ1RPUiA9IDAuMztcblx0XHRcdHJldHVybiBCQUNLT0ZGX0ZBQ1RPUiAqICgyICoqICh0aGlzLl9yZXRyeUNvdW50IC0gMSkpICogMTAwMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdF9kZWNvcmF0ZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG5cdFx0aWYgKHRoaXMuX29wdGlvbnMucGFyc2VKc29uKSB7XG5cdFx0XHRyZXNwb25zZS5qc29uID0gYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5wYXJzZUpzb24oYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHR9XG5cblx0YXN5bmMgX3JldHJ5KGZuKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBmbigpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zdCBtcyA9IE1hdGgubWluKHRoaXMuX2NhbGN1bGF0ZVJldHJ5RGVsYXkoZXJyb3IpLCBtYXhTYWZlVGltZW91dCk7XG5cdFx0XHRpZiAobXMgIT09IDAgJiYgdGhpcy5fcmV0cnlDb3VudCA+IDApIHtcblx0XHRcdFx0YXdhaXQgZGVsYXkobXMpO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgaG9vayBvZiB0aGlzLl9vcHRpb25zLmhvb2tzLmJlZm9yZVJldHJ5KSB7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRcdFx0XHRjb25zdCBob29rUmVzdWx0ID0gYXdhaXQgaG9vayh7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG5cdFx0XHRcdFx0XHRvcHRpb25zOiB0aGlzLl9vcHRpb25zLFxuXHRcdFx0XHRcdFx0ZXJyb3IsXG5cdFx0XHRcdFx0XHRyZXRyeUNvdW50OiB0aGlzLl9yZXRyeUNvdW50XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBJZiBgc3RvcGAgaXMgcmV0dXJuZWQgZnJvbSB0aGUgaG9vaywgdGhlIHJldHJ5IHByb2Nlc3MgaXMgc3RvcHBlZFxuXHRcdFx0XHRcdGlmIChob29rUmVzdWx0ID09PSBzdG9wKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JldHJ5KGZuKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX29wdGlvbnMudGhyb3dIdHRwRXJyb3JzKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIF9mZXRjaCgpIHtcblx0XHRmb3IgKGNvbnN0IGhvb2sgb2YgdGhpcy5fb3B0aW9ucy5ob29rcy5iZWZvcmVSZXF1ZXN0KSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgaG9vayh0aGlzLnJlcXVlc3QsIHRoaXMuX29wdGlvbnMpO1xuXG5cdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3QgPSByZXN1bHQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5fb3B0aW9ucy50aW1lb3V0ID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuZmV0Y2godGhpcy5yZXF1ZXN0LmNsb25lKCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aW1lb3V0KHRoaXMucmVxdWVzdC5jbG9uZSgpLCB0aGlzLmFib3J0Q29udHJvbGxlciwgdGhpcy5fb3B0aW9ucyk7XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRfc3RyZWFtKHJlc3BvbnNlLCBvbkRvd25sb2FkUHJvZ3Jlc3MpIHtcblx0XHRjb25zdCB0b3RhbEJ5dGVzID0gTnVtYmVyKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpKSB8fCAwO1xuXHRcdGxldCB0cmFuc2ZlcnJlZEJ5dGVzID0gMDtcblxuXHRcdHJldHVybiBuZXcgZ2xvYmFscy5SZXNwb25zZShcblx0XHRcdG5ldyBnbG9iYWxzLlJlYWRhYmxlU3RyZWFtKHtcblx0XHRcdFx0c3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0XHRcdGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cblx0XHRcdFx0XHRpZiAob25Eb3dubG9hZFByb2dyZXNzKSB7XG5cdFx0XHRcdFx0XHRvbkRvd25sb2FkUHJvZ3Jlc3Moe3BlcmNlbnQ6IDAsIHRyYW5zZmVycmVkQnl0ZXM6IDAsIHRvdGFsQnl0ZXN9LCBuZXcgVWludDhBcnJheSgpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRhc3luYyBmdW5jdGlvbiByZWFkKCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cdFx0XHRcdFx0XHRpZiAoZG9uZSkge1xuXHRcdFx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG9uRG93bmxvYWRQcm9ncmVzcykge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2ZlcnJlZEJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHBlcmNlbnQgPSB0b3RhbEJ5dGVzID09PSAwID8gMCA6IHRyYW5zZmVycmVkQnl0ZXMgLyB0b3RhbEJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRvbkRvd25sb2FkUHJvZ3Jlc3Moe3BlcmNlbnQsIHRyYW5zZmVycmVkQnl0ZXMsIHRvdGFsQnl0ZXN9LCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRyZWFkKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVhZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdCk7XG5cdH1cbn1cblxuY29uc3QgdmFsaWRhdGVBbmRNZXJnZSA9ICguLi5zb3VyY2VzKSA9PiB7XG5cdGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcblx0XHRpZiAoKCFpc09iamVjdChzb3VyY2UpIHx8IEFycmF5LmlzQXJyYXkoc291cmNlKSkgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBgb3B0aW9uc2AgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QnKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGVlcE1lcmdlKHt9LCAuLi5zb3VyY2VzKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlID0gZGVmYXVsdHMgPT4ge1xuXHRjb25zdCBreSA9IChpbnB1dCwgb3B0aW9ucykgPT4gbmV3IEt5KGlucHV0LCB2YWxpZGF0ZUFuZE1lcmdlKGRlZmF1bHRzLCBvcHRpb25zKSk7XG5cblx0Zm9yIChjb25zdCBtZXRob2Qgb2YgcmVxdWVzdE1ldGhvZHMpIHtcblx0XHRreVttZXRob2RdID0gKGlucHV0LCBvcHRpb25zKSA9PiBuZXcgS3koaW5wdXQsIHZhbGlkYXRlQW5kTWVyZ2UoZGVmYXVsdHMsIG9wdGlvbnMsIHttZXRob2R9KSk7XG5cdH1cblxuXHRreS5IVFRQRXJyb3IgPSBIVFRQRXJyb3I7XG5cdGt5LlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcblx0a3kuY3JlYXRlID0gbmV3RGVmYXVsdHMgPT4gY3JlYXRlSW5zdGFuY2UodmFsaWRhdGVBbmRNZXJnZShuZXdEZWZhdWx0cykpO1xuXHRreS5leHRlbmQgPSBuZXdEZWZhdWx0cyA9PiBjcmVhdGVJbnN0YW5jZSh2YWxpZGF0ZUFuZE1lcmdlKGRlZmF1bHRzLCBuZXdEZWZhdWx0cykpO1xuXHRreS5zdG9wID0gc3RvcDtcblxuXHRyZXR1cm4ga3k7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVJbnN0YW5jZSgpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5sb2FkanMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4vKipcbiAqIEdsb2JhbCBkZXBlbmRlbmNpZXMuXG4gKiBAZ2xvYmFsIHtPYmplY3R9IGRvY3VtZW50IC0gRE9NXG4gKi9cblxudmFyIGRldm51bGwgPSBmdW5jdGlvbigpIHt9LFxuICAgIGJ1bmRsZUlkQ2FjaGUgPSB7fSxcbiAgICBidW5kbGVSZXN1bHRDYWNoZSA9IHt9LFxuICAgIGJ1bmRsZUNhbGxiYWNrUXVldWUgPSB7fTtcblxuXG4vKipcbiAqIFN1YnNjcmliZSB0byBidW5kbGUgbG9hZCBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGJ1bmRsZUlkcyAtIEJ1bmRsZSBpZHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrRm4gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3Vic2NyaWJlKGJ1bmRsZUlkcywgY2FsbGJhY2tGbikge1xuICAvLyBsaXN0aWZ5XG4gIGJ1bmRsZUlkcyA9IGJ1bmRsZUlkcy5wdXNoID8gYnVuZGxlSWRzIDogW2J1bmRsZUlkc107XG5cbiAgdmFyIGRlcHNOb3RGb3VuZCA9IFtdLFxuICAgICAgaSA9IGJ1bmRsZUlkcy5sZW5ndGgsXG4gICAgICBudW1XYWl0aW5nID0gaSxcbiAgICAgIGZuLFxuICAgICAgYnVuZGxlSWQsXG4gICAgICByLFxuICAgICAgcTtcblxuICAvLyBkZWZpbmUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgZm4gPSBmdW5jdGlvbiAoYnVuZGxlSWQsIHBhdGhzTm90Rm91bmQpIHtcbiAgICBpZiAocGF0aHNOb3RGb3VuZC5sZW5ndGgpIGRlcHNOb3RGb3VuZC5wdXNoKGJ1bmRsZUlkKTtcblxuICAgIG51bVdhaXRpbmctLTtcbiAgICBpZiAoIW51bVdhaXRpbmcpIGNhbGxiYWNrRm4oZGVwc05vdEZvdW5kKTtcbiAgfTtcblxuICAvLyByZWdpc3RlciBjYWxsYmFja1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYnVuZGxlSWQgPSBidW5kbGVJZHNbaV07XG5cbiAgICAvLyBleGVjdXRlIGNhbGxiYWNrIGlmIGluIHJlc3VsdCBjYWNoZVxuICAgIHIgPSBidW5kbGVSZXN1bHRDYWNoZVtidW5kbGVJZF07XG4gICAgaWYgKHIpIHtcbiAgICAgIGZuKGJ1bmRsZUlkLCByKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGFkZCB0byBjYWxsYmFjayBxdWV1ZVxuICAgIHEgPSBidW5kbGVDYWxsYmFja1F1ZXVlW2J1bmRsZUlkXSA9IGJ1bmRsZUNhbGxiYWNrUXVldWVbYnVuZGxlSWRdIHx8IFtdO1xuICAgIHEucHVzaChmbik7XG4gIH1cbn1cblxuXG4vKipcbiAqIFB1Ymxpc2ggYnVuZGxlIGxvYWQgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBCdW5kbGUgaWRcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzTm90Rm91bmQgLSBMaXN0IG9mIGZpbGVzIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBwdWJsaXNoKGJ1bmRsZUlkLCBwYXRoc05vdEZvdW5kKSB7XG4gIC8vIGV4aXQgaWYgaWQgaXNuJ3QgZGVmaW5lZFxuICBpZiAoIWJ1bmRsZUlkKSByZXR1cm47XG5cbiAgdmFyIHEgPSBidW5kbGVDYWxsYmFja1F1ZXVlW2J1bmRsZUlkXTtcblxuICAvLyBjYWNoZSByZXN1bHRcbiAgYnVuZGxlUmVzdWx0Q2FjaGVbYnVuZGxlSWRdID0gcGF0aHNOb3RGb3VuZDtcblxuICAvLyBleGl0IGlmIHF1ZXVlIGlzIGVtcHR5XG4gIGlmICghcSkgcmV0dXJuO1xuXG4gIC8vIGVtcHR5IGNhbGxiYWNrIHF1ZXVlXG4gIHdoaWxlIChxLmxlbmd0aCkge1xuICAgIHFbMF0oYnVuZGxlSWQsIHBhdGhzTm90Rm91bmQpO1xuICAgIHEuc3BsaWNlKDAsIDEpO1xuICB9XG59XG5cblxuLyoqXG4gKiBFeGVjdXRlIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0IG9yIEZ1bmN0aW9ufSBhcmdzIC0gVGhlIGNhbGxiYWNrIGFyZ3NcbiAqIEBwYXJhbSB7c3RyaW5nW119IGRlcHNOb3RGb3VuZCAtIExpc3Qgb2YgZGVwZW5kZW5jaWVzIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBleGVjdXRlQ2FsbGJhY2tzKGFyZ3MsIGRlcHNOb3RGb3VuZCkge1xuICAvLyBhY2NlcHQgZnVuY3Rpb24gYXMgYXJndW1lbnRcbiAgaWYgKGFyZ3MuY2FsbCkgYXJncyA9IHtzdWNjZXNzOiBhcmdzfTtcblxuICAvLyBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3NcbiAgaWYgKGRlcHNOb3RGb3VuZC5sZW5ndGgpIChhcmdzLmVycm9yIHx8IGRldm51bGwpKGRlcHNOb3RGb3VuZCk7XG4gIGVsc2UgKGFyZ3Muc3VjY2VzcyB8fCBkZXZudWxsKShhcmdzKTtcbn1cblxuXG4vKipcbiAqIExvYWQgaW5kaXZpZHVhbCBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgZmlsZSBwYXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja0ZuIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGxvYWRGaWxlKHBhdGgsIGNhbGxiYWNrRm4sIGFyZ3MsIG51bVRyaWVzKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudCxcbiAgICAgIGFzeW5jID0gYXJncy5hc3luYyxcbiAgICAgIG1heFRyaWVzID0gKGFyZ3MubnVtUmV0cmllcyB8fCAwKSArIDEsXG4gICAgICBiZWZvcmVDYWxsYmFja0ZuID0gYXJncy5iZWZvcmUgfHwgZGV2bnVsbCxcbiAgICAgIHBhdGhuYW1lID0gcGF0aC5yZXBsYWNlKC9bXFw/fCNdLiokLywgJycpLFxuICAgICAgcGF0aFN0cmlwcGVkID0gcGF0aC5yZXBsYWNlKC9eKGNzc3xpbWcpIS8sICcnKSxcbiAgICAgIGlzTGVnYWN5SUVDc3MsXG4gICAgICBlO1xuXG4gIG51bVRyaWVzID0gbnVtVHJpZXMgfHwgMDtcblxuICBpZiAoLyheY3NzIXxcXC5jc3MkKS8udGVzdChwYXRobmFtZSkpIHtcbiAgICAvLyBjc3NcbiAgICBlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICBlLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBlLmhyZWYgPSBwYXRoU3RyaXBwZWQ7XG5cbiAgICAvLyB0YWcgSUU5K1xuICAgIGlzTGVnYWN5SUVDc3MgPSAnaGlkZUZvY3VzJyBpbiBlO1xuXG4gICAgLy8gdXNlIHByZWxvYWQgaW4gSUUgRWRnZSAodG8gZGV0ZWN0IGxvYWQgZXJyb3JzKVxuICAgIGlmIChpc0xlZ2FjeUlFQ3NzICYmIGUucmVsTGlzdCkge1xuICAgICAgaXNMZWdhY3lJRUNzcyA9IDA7XG4gICAgICBlLnJlbCA9ICdwcmVsb2FkJztcbiAgICAgIGUuYXMgPSAnc3R5bGUnO1xuICAgIH1cbiAgfSBlbHNlIGlmICgvKF5pbWchfFxcLihwbmd8Z2lmfGpwZ3xzdmd8d2VicCkkKS8udGVzdChwYXRobmFtZSkpIHtcbiAgICAvLyBpbWFnZVxuICAgIGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgZS5zcmMgPSBwYXRoU3RyaXBwZWQ7ICAgIFxuICB9IGVsc2Uge1xuICAgIC8vIGphdmFzY3JpcHRcbiAgICBlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIGUuc3JjID0gcGF0aDtcbiAgICBlLmFzeW5jID0gYXN5bmMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhc3luYztcbiAgfVxuXG4gIGUub25sb2FkID0gZS5vbmVycm9yID0gZS5vbmJlZm9yZWxvYWQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXYudHlwZVswXTtcblxuICAgIC8vIHRyZWF0IGVtcHR5IHN0eWxlc2hlZXRzIGFzIGZhaWx1cmVzIHRvIGdldCBhcm91bmQgbGFjayBvZiBvbmVycm9yXG4gICAgLy8gc3VwcG9ydCBpbiBJRTktMTFcbiAgICBpZiAoaXNMZWdhY3lJRUNzcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFlLnNoZWV0LmNzc1RleHQubGVuZ3RoKSByZXN1bHQgPSAnZSc7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIHNoZWV0cyBvYmplY3RzIGNyZWF0ZWQgZnJvbSBsb2FkIGVycm9ycyBkb24ndCBhbGxvdyBhY2Nlc3MgdG9cbiAgICAgICAgLy8gYGNzc1RleHRgICh1bmxlc3MgZXJyb3IgaXMgQ29kZToxOCBTZWN1cml0eUVycm9yKVxuICAgICAgICBpZiAoeC5jb2RlICE9IDE4KSByZXN1bHQgPSAnZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHJldHJpZXMgaW4gY2FzZSBvZiBsb2FkIGZhaWx1cmVcbiAgICBpZiAocmVzdWx0ID09ICdlJykge1xuICAgICAgLy8gaW5jcmVtZW50IGNvdW50ZXJcbiAgICAgIG51bVRyaWVzICs9IDE7XG5cbiAgICAgIC8vIGV4aXQgZnVuY3Rpb24gYW5kIHRyeSBhZ2FpblxuICAgICAgaWYgKG51bVRyaWVzIDwgbWF4VHJpZXMpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRGaWxlKHBhdGgsIGNhbGxiYWNrRm4sIGFyZ3MsIG51bVRyaWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUucmVsID09ICdwcmVsb2FkJyAmJiBlLmFzID09ICdzdHlsZScpIHtcbiAgICAgIC8vIGFjdGl2YXRlIHByZWxvYWRlZCBzdHlsZXNoZWV0c1xuICAgICAgcmV0dXJuIGUucmVsID0gJ3N0eWxlc2hlZXQnOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB9XG4gICAgXG4gICAgLy8gZXhlY3V0ZSBjYWxsYmFja1xuICAgIGNhbGxiYWNrRm4ocGF0aCwgcmVzdWx0LCBldi5kZWZhdWx0UHJldmVudGVkKTtcbiAgfTtcblxuICAvLyBhZGQgdG8gZG9jdW1lbnQgKHVubGVzcyBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWApXG4gIGlmIChiZWZvcmVDYWxsYmFja0ZuKHBhdGgsIGUpICE9PSBmYWxzZSkgZG9jLmhlYWQuYXBwZW5kQ2hpbGQoZSk7XG59XG5cblxuLyoqXG4gKiBMb2FkIG11bHRpcGxlIGZpbGVzLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgLSBUaGUgZmlsZSBwYXRoc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tGbiAtIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBsb2FkRmlsZXMocGF0aHMsIGNhbGxiYWNrRm4sIGFyZ3MpIHtcbiAgLy8gbGlzdGlmeSBwYXRoc1xuICBwYXRocyA9IHBhdGhzLnB1c2ggPyBwYXRocyA6IFtwYXRoc107XG5cbiAgdmFyIG51bVdhaXRpbmcgPSBwYXRocy5sZW5ndGgsXG4gICAgICB4ID0gbnVtV2FpdGluZyxcbiAgICAgIHBhdGhzTm90Rm91bmQgPSBbXSxcbiAgICAgIGZuLFxuICAgICAgaTtcblxuICAvLyBkZWZpbmUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgZm4gPSBmdW5jdGlvbihwYXRoLCByZXN1bHQsIGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAvLyBoYW5kbGUgZXJyb3JcbiAgICBpZiAocmVzdWx0ID09ICdlJykgcGF0aHNOb3RGb3VuZC5wdXNoKHBhdGgpO1xuXG4gICAgLy8gaGFuZGxlIGJlZm9yZWxvYWQgZXZlbnQuIElmIGRlZmF1bHRQcmV2ZW50ZWQgdGhlbiB0aGF0IG1lYW5zIHRoZSBsb2FkXG4gICAgLy8gd2lsbCBiZSBibG9ja2VkIChleC4gR2hvc3RlcnkvQUJQIG9uIFNhZmFyaSlcbiAgICBpZiAocmVzdWx0ID09ICdiJykge1xuICAgICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHBhdGhzTm90Rm91bmQucHVzaChwYXRoKTtcbiAgICAgIGVsc2UgcmV0dXJuO1xuICAgIH1cblxuICAgIG51bVdhaXRpbmctLTtcbiAgICBpZiAoIW51bVdhaXRpbmcpIGNhbGxiYWNrRm4ocGF0aHNOb3RGb3VuZCk7XG4gIH07XG5cbiAgLy8gbG9hZCBzY3JpcHRzXG4gIGZvciAoaT0wOyBpIDwgeDsgaSsrKSBsb2FkRmlsZShwYXRoc1tpXSwgZm4sIGFyZ3MpO1xufVxuXG5cbi8qKlxuICogSW5pdGlhdGUgc2NyaXB0IGxvYWQgYW5kIHJlZ2lzdGVyIGJ1bmRsZS5cbiAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IHBhdGhzIC0gVGhlIGZpbGUgcGF0aHNcbiAqIEBwYXJhbSB7KHN0cmluZ3xGdW5jdGlvbnxPYmplY3QpfSBbYXJnMV0gLSBUaGUgKDEpIGJ1bmRsZUlkIG9yICgyKSBzdWNjZXNzXG4gKiAgIGNhbGxiYWNrIG9yICgzKSBvYmplY3QgbGl0ZXJhbCB3aXRoIHN1Y2Nlc3MvZXJyb3IgYXJndW1lbnRzLCBudW1SZXRyaWVzLFxuICogICBldGMuXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBbYXJnMl0gLSBUaGUgKDEpIHN1Y2Nlc3MgY2FsbGJhY2sgb3IgKDIpIG9iamVjdFxuICogICBsaXRlcmFsIHdpdGggc3VjY2Vzcy9lcnJvciBhcmd1bWVudHMsIG51bVJldHJpZXMsIGV0Yy5cbiAqL1xuZnVuY3Rpb24gbG9hZGpzKHBhdGhzLCBhcmcxLCBhcmcyKSB7XG4gIHZhciBidW5kbGVJZCxcbiAgICAgIGFyZ3M7XG5cbiAgLy8gYnVuZGxlSWQgKGlmIHN0cmluZylcbiAgaWYgKGFyZzEgJiYgYXJnMS50cmltKSBidW5kbGVJZCA9IGFyZzE7XG5cbiAgLy8gYXJncyAoZGVmYXVsdCBpcyB7fSlcbiAgYXJncyA9IChidW5kbGVJZCA/IGFyZzIgOiBhcmcxKSB8fCB7fTtcblxuICAvLyB0aHJvdyBlcnJvciBpZiBidW5kbGUgaXMgYWxyZWFkeSBkZWZpbmVkXG4gIGlmIChidW5kbGVJZCkge1xuICAgIGlmIChidW5kbGVJZCBpbiBidW5kbGVJZENhY2hlKSB7XG4gICAgICB0aHJvdyBcIkxvYWRKU1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBidW5kbGVJZENhY2hlW2J1bmRsZUlkXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZEZuKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxvYWRGaWxlcyhwYXRocywgZnVuY3Rpb24gKHBhdGhzTm90Rm91bmQpIHtcbiAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tzXG4gICAgICBleGVjdXRlQ2FsbGJhY2tzKGFyZ3MsIHBhdGhzTm90Rm91bmQpO1xuICAgICAgXG4gICAgICAvLyByZXNvbHZlIFByb21pc2VcbiAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgIGV4ZWN1dGVDYWxsYmFja3Moe3N1Y2Nlc3M6IHJlc29sdmUsIGVycm9yOiByZWplY3R9LCBwYXRoc05vdEZvdW5kKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHVibGlzaCBidW5kbGUgbG9hZCBldmVudFxuICAgICAgcHVibGlzaChidW5kbGVJZCwgcGF0aHNOb3RGb3VuZCk7XG4gICAgfSwgYXJncyk7XG4gIH1cbiAgXG4gIGlmIChhcmdzLnJldHVyblByb21pc2UpIHJldHVybiBuZXcgUHJvbWlzZShsb2FkRm4pO1xuICBlbHNlIGxvYWRGbigpO1xufVxuXG5cbi8qKlxuICogRXhlY3V0ZSBjYWxsYmFja3Mgd2hlbiBkZXBlbmRlbmNpZXMgaGF2ZSBiZWVuIHNhdGlzZmllZC5cbiAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGRlcHMgLSBMaXN0IG9mIGJ1bmRsZSBpZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gc3VjY2Vzcy9lcnJvciBhcmd1bWVudHNcbiAqL1xubG9hZGpzLnJlYWR5ID0gZnVuY3Rpb24gcmVhZHkoZGVwcywgYXJncykge1xuICAvLyBzdWJzY3JpYmUgdG8gYnVuZGxlIGxvYWQgZXZlbnRcbiAgc3Vic2NyaWJlKGRlcHMsIGZ1bmN0aW9uIChkZXBzTm90Rm91bmQpIHtcbiAgICAvLyBleGVjdXRlIGNhbGxiYWNrc1xuICAgIGV4ZWN1dGVDYWxsYmFja3MoYXJncywgZGVwc05vdEZvdW5kKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGxvYWRqcztcbn07XG5cblxuLyoqXG4gKiBNYW51YWxseSBzYXRpc2Z5IGJ1bmRsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgYnVuZGxlIGlkXG4gKi9cbmxvYWRqcy5kb25lID0gZnVuY3Rpb24gZG9uZShidW5kbGVJZCkge1xuICBwdWJsaXNoKGJ1bmRsZUlkLCBbXSk7XG59O1xuXG5cbi8qKlxuICogUmVzZXQgbG9hZGpzIGRlcGVuZGVuY2llcyBzdGF0dXNlc1xuICovXG5sb2FkanMucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgYnVuZGxlSWRDYWNoZSA9IHt9O1xuICBidW5kbGVSZXN1bHRDYWNoZSA9IHt9O1xuICBidW5kbGVDYWxsYmFja1F1ZXVlID0ge307XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGJ1bmRsZSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWRcbiAqIEBwYXJhbSBTdHJpbmd9IGJ1bmRsZUlkIC0gVGhlIGJ1bmRsZSBpZFxuICovXG5sb2FkanMuaXNEZWZpbmVkID0gZnVuY3Rpb24gaXNEZWZpbmVkKGJ1bmRsZUlkKSB7XG4gIHJldHVybiBidW5kbGVJZCBpbiBidW5kbGVJZENhY2hlO1xufTtcblxuXG4vLyBleHBvcnRcbnJldHVybiBsb2FkanM7XG5cbn0pKTtcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVRvQXJyYXk7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuLyoqXG4gKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVdvcmRzO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwidmFyIGdldCA9IHJlcXVpcmUoJy4vZ2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBdDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5T2Y7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsInZhciB0cmltbWVkRW5kSW5kZXggPSByZXF1aXJlKCcuL190cmltbWVkRW5kSW5kZXgnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUcmltO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAqL1xuZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0U2xpY2U7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICovXG5mdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyc0VuZEluZGV4O1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gKi9cbmZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyc1N0YXJ0SW5kZXg7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGNhc3RTbGljZSA9IHJlcXVpcmUoJy4vX2Nhc3RTbGljZScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgc3RyaW5nVG9BcnJheSA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvQXJyYXknKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNhc2VGaXJzdDtcbiIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgZGVidXJyID0gcmVxdWlyZSgnLi9kZWJ1cnInKSxcbiAgICB3b3JkcyA9IHJlcXVpcmUoJy4vd29yZHMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiO1xuXG4vKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbnZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDb21wb3VuZGVyO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuIiwidmFyIGJhc2VQcm9wZXJ0eU9mID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5T2YnKTtcblxuLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xudmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICdcXHhkZic6ICdzcycsXG4gIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICovXG52YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1cnJMZXR0ZXI7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIGJhc2VQcm9wZXJ0eU9mID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5T2YnKTtcblxuLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbnZhciBodG1sRXNjYXBlcyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG52YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlSHRtbENoYXI7XG4iLCIvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlU3RyaW5nQ2hhcjtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZTtcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGVXb3JkO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlRXNjYXBlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxubW9kdWxlLmV4cG9ydHMgPSByZUV2YWx1YXRlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVJbnRlcnBvbGF0ZTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaWN0SW5kZXhPZjtcbiIsInZhciBhc2NpaVRvQXJyYXkgPSByZXF1aXJlKCcuL19hc2NpaVRvQXJyYXknKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHVuaWNvZGVUb0FycmF5ID0gcmVxdWlyZSgnLi9fdW5pY29kZVRvQXJyYXknKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9BcnJheTtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmltbWVkRW5kSW5kZXg7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlVG9BcnJheTtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICByc09yZFVwcGVyLFxuICByc09yZExvd2VyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlV29yZHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduSW5XaXRoO1xuIiwidmFyIGJhc2VBdCA9IHJlcXVpcmUoJy4vX2Jhc2VBdCcpLFxuICAgIGZsYXRSZXN0ID0gcmVxdWlyZSgnLi9fZmxhdFJlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gKlxuICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAqIC8vID0+IFszLCA0XVxuICovXG52YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF0O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNFcnJvciA9IHJlcXVpcmUoJy4vaXNFcnJvcicpO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdHRlbXB0O1xuIiwidmFyIGNhcGl0YWxpemUgPSByZXF1aXJlKCcuL2NhcGl0YWxpemUnKSxcbiAgICBjcmVhdGVDb21wb3VuZGVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQ29tcG91bmRlcicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICpcbiAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKi9cbnZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsQ2FzZTtcbiIsInZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKSxcbiAgICB1cHBlckZpcnN0ID0gcmVxdWlyZSgnLi91cHBlckZpcnN0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gKiB0byBsb3dlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICogLy8gPT4gJ0ZyZWQnXG4gKi9cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FwaXRhbGl6ZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGRlYnVyckxldHRlciA9IHJlcXVpcmUoJy4vX2RlYnVyckxldHRlcicpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4vKipcbiAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICogLy8gPT4gJ2RlamEgdnUnXG4gKi9cbmZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1cnI7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBlc2NhcGVIdG1sQ2hhciA9IHJlcXVpcmUoJy4vX2VzY2FwZUh0bWxDaGFyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFcnJvcihFcnJvcik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXJyb3I7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAqIGBwYXRoYCBjcmVhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gKiAvLyA9PiA0XG4gKlxuICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYXNzaWduSW5XaXRoID0gcmVxdWlyZSgnLi9hc3NpZ25JbldpdGgnKSxcbiAgICBhdHRlbXB0ID0gcmVxdWlyZSgnLi9hdHRlbXB0JyksXG4gICAgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBjdXN0b21EZWZhdWx0c0Fzc2lnbkluID0gcmVxdWlyZSgnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25JbicpLFxuICAgIGVzY2FwZVN0cmluZ0NoYXIgPSByZXF1aXJlKCcuL19lc2NhcGVTdHJpbmdDaGFyJyksXG4gICAgaXNFcnJvciA9IHJlcXVpcmUoJy4vaXNFcnJvcicpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyksXG4gICAgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vX3JlSW50ZXJwb2xhdGUnKSxcbiAgICB0ZW1wbGF0ZVNldHRpbmdzID0gcmVxdWlyZSgnLi90ZW1wbGF0ZVNldHRpbmdzJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gJ0ludmFsaWQgYHZhcmlhYmxlYCBvcHRpb24gcGFzc2VkIGludG8gYF8udGVtcGxhdGVgJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIHZhbGlkYXRlIHRoZSBgdmFsaWRhdGVgIG9wdGlvbiBpbiBgXy50ZW1wbGF0ZWAgdmFyaWFibGUuXG4gKlxuICogRm9yYmlkcyBjaGFyYWN0ZXJzIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNoYW5nZSB0aGUgbWVhbmluZyBvZiB0aGUgZnVuY3Rpb24gYXJndW1lbnQgZGVmaW5pdGlvbjpcbiAqIC0gXCIoKSxcIiAobW9kaWZpY2F0aW9uIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMpXG4gKiAtIFwiPVwiIChkZWZhdWx0IHZhbHVlKVxuICogLSBcIltde31cIiAoZGVzdHJ1Y3R1cmluZyBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICogLSBcIi9cIiAoYmVnaW5uaW5nIG9mIGEgY29tbWVudClcbiAqIC0gd2hpdGVzcGFjZVxuICovXG52YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2hcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gKi9cbnZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICpcbiAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSd0ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAqXG4gKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAqXG4gKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICpcbiAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICpcbiAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gKlxuICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gKiBjb21waWxlZChkYXRhKTtcbiAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gKlxuICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gKiBjb21waWxlZC5zb3VyY2U7XG4gKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gKiAvLyAgIHJldHVybiBfX3A7XG4gKiAvLyB9XG4gKlxuICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gKiAgIHZhciBKU1QgPSB7XFxcbiAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICogICB9O1xcXG4gKiAnKTtcbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gIHZhciBzZXR0aW5ncyA9IHRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0cy5fLnRlbXBsYXRlU2V0dGluZ3MgfHwgdGVtcGxhdGVTZXR0aW5ncztcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICB2YXIgaXNFc2NhcGluZyxcbiAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICwgJ2cnKTtcblxuICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgLy8gYW5kIGVzY2FwZSB0aGUgY29tbWVudCwgdGh1cyBpbmplY3RpbmcgY29kZSB0aGF0IGdldHMgZXZhbGVkLlxuICB2YXIgc291cmNlVVJMID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICA/ICgnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJykgK1xuICAgICAgICdcXG4nKVxuICAgIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgaWYgKCF2YXJpYWJsZSkge1xuICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICB9XG4gIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZm9yYmlkZGVuIGNoYXJhY3RlciB3YXMgZm91bmQgaW4gYHZhcmlhYmxlYCwgdG8gcHJldmVudFxuICAvLyBwb3RlbnRpYWwgY29tbWFuZCBpbmplY3Rpb24gYXR0YWNrcy5cbiAgZWxzZSBpZiAocmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMudGVzdCh2YXJpYWJsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCk7XG4gIH1cblxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuIiwidmFyIGVzY2FwZSA9IHJlcXVpcmUoJy4vZXNjYXBlJyksXG4gICAgcmVFc2NhcGUgPSByZXF1aXJlKCcuL19yZUVzY2FwZScpLFxuICAgIHJlRXZhbHVhdGUgPSByZXF1aXJlKCcuL19yZUV2YWx1YXRlJyksXG4gICAgcmVJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4vX3JlSW50ZXJwb2xhdGUnKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlU2V0dGluZ3M7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKSxcbiAgICBiYXNlVHJpbSA9IHJlcXVpcmUoJy4vX2Jhc2VUcmltJyksXG4gICAgY2FzdFNsaWNlID0gcmVxdWlyZSgnLi9fY2FzdFNsaWNlJyksXG4gICAgY2hhcnNFbmRJbmRleCA9IHJlcXVpcmUoJy4vX2NoYXJzRW5kSW5kZXgnKSxcbiAgICBjaGFyc1N0YXJ0SW5kZXggPSByZXF1aXJlKCcuL19jaGFyc1N0YXJ0SW5kZXgnKSxcbiAgICBzdHJpbmdUb0FycmF5ID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9BcnJheScpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udHJpbSgnICBhYmMgICcpO1xuICogLy8gPT4gJ2FiYydcbiAqXG4gKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICogLy8gPT4gJ2FiYydcbiAqXG4gKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAqL1xuZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHJldHVybiBiYXNlVHJpbShzdHJpbmcpO1xuICB9XG4gIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJpbTtcbiIsInZhciBjcmVhdGVDYXNlRmlyc3QgPSByZXF1aXJlKCcuL19jcmVhdGVDYXNlRmlyc3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICogLy8gPT4gJ0ZyZWQnXG4gKlxuICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gKiAvLyA9PiAnRlJFRCdcbiAqL1xudmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXBwZXJGaXJzdDtcbiIsInZhciBhc2NpaVdvcmRzID0gcmVxdWlyZSgnLi9fYXNjaWlXb3JkcycpLFxuICAgIGhhc1VuaWNvZGVXb3JkID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZVdvcmQnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKSxcbiAgICB1bmljb2RlV29yZHMgPSByZXF1aXJlKCcuL191bmljb2RlV29yZHMnKTtcblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd29yZHM7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsImV4cG9ydCB7IHVybEFscGhhYmV0IH0gZnJvbSAnLi91cmwtYWxwaGFiZXQvaW5kZXguanMnXG5leHBvcnQgbGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxuZXhwb3J0IGxldCBjdXN0b21SYW5kb20gPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplLCBnZXRSYW5kb20pID0+IHtcbiAgbGV0IG1hc2sgPSAoMiA8PCAoTWF0aC5sb2coYWxwaGFiZXQubGVuZ3RoIC0gMSkgLyBNYXRoLkxOMikpIC0gMVxuICBsZXQgc3RlcCA9IC1+KCgxLjYgKiBtYXNrICogZGVmYXVsdFNpemUpIC8gYWxwaGFiZXQubGVuZ3RoKVxuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgbGV0IGogPSBzdGVwXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2pdICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnQgbGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBzaXplID0gMjEpID0+XG4gIGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxuZXhwb3J0IGxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PlxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKS5yZWR1Y2UoKGlkLCBieXRlKSA9PiB7XG4gICAgYnl0ZSAmPSA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlID4gNjIpIHtcbiAgICAgIGlkICs9ICctJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnXydcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH0sICcnKVxuIiwiZXhwb3J0IGNvbnN0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJpbXBvcnQgUmlkZ2UgZnJvbSAnLi9SaWRnZSdcclxuXHJcbndpbmRvdy5SaWRnZSA9IFJpZGdlXHJcbmV4cG9ydCBkZWZhdWx0IFJpZGdlXHJcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZXh0ZXJuYWxzIiwicm9vdCIsImRpc3QiLCJkZXBlbmRlbmNpZXMiLCJzdHlsZSIsIkVsZW1lbnRMb2FkZXIiLCJQYWdlRWxlbWVudE1hbmFnZXIiLCJSaWRnZSIsImNvbnN0cnVjdG9yIiwib3B0cyIsImJhc2VVcmwiLCJ1bnBrZ1VybCIsInVua3BnVXJsIiwiZGVidWdVcmwiLCJsb2FkZXIiLCJwYWdlRWxlbWVudE1hbmFnZXJzIiwibG9hZCIsImpzb24iLCJpbnN0YW5jZSIsIndpbmRvdyIsInJpZGdlIiwianNvbk9iamVjdCIsImxvYWRKU09OIiwibG9hZFBhZ2UiLCJsb2FkQ29tcG9uZW50IiwiY29tcG9uZW50UGF0aCIsImVsIiwicGFnZUNvbmZpZyIsInBhZ2VNYW5hZ2VyIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwibW91bnQiLCJkb2N1bWVudCIsImJvZHkiLCJjcmVhdGVQYWdlTWFuYWdlciIsImdldFBhZ2VFbGVtZW50TWFuYWdlciIsImlkIiwicmVnaXN0ZXJNZXRob2QiLCJuYW1lIiwibWV0aG9kIiwiZGVidWciLCJSZWFjdFJlbmRlcmVyIiwiVmFuaWxsYVJlbmRlciIsInRlbXBsYXRlIiwibG9kYXNoU2V0IiwibG9nIiwiZXJyb3IiLCJFbGVtZW50V3JhcHBlciIsImNvbmZpZyIsInBhdGgiLCJzeXN0ZW1Qcm9wZXJ0aWVzIiwiX19yaWRnZSIsIl9fcGFnZU1hbmFnZXIiLCJfX2VsZW1lbnRXcmFwcGVyIiwicHJvcGVydGllcyIsInNjb3BlVmFyaWFibGVWYWx1ZXMiLCJzZXRNb2RlIiwibW9kZSIsIl9fbW9kZSIsImZvcmNlVXBkYXRlIiwiaXNSb290IiwicGFyZW50IiwiY2xvbmUiLCJjbG9uZWQiLCJ0b0pTT04iLCJjb21wb25lbnREZWZpbml0aW9uIiwicHJlbG9hZGVkIiwicHJvcHMiLCJjaGlsZHJlbiIsIm1hcCIsIndyYXBwZXJJZCIsInRlbXBsYXRlTm9kZSIsImdldEVsZW1lbnQiLCJjbG9uZWRDaGlsZCIsInBhcmVudFdyYXBwZXIiLCJwcmVsb2FkIiwiZGVlcFByZWxvYWQiLCJzZXRTdGF0dXMiLCJsb2FkQ29tcG9uZW50RGVmaW5pdGlvbiIsImNoaWxkSWQiLCJjaGlsZFdyYXBwZXIiLCJyZW1vdmVTdGF0dXMiLCJjb21wb25lbnQiLCJhcHBlbmRDaGlsZCIsIndyYXBwZXIiLCJwdXNoIiwiaW5pdFByb3BzQW5kRXZlbnRzIiwic2xvdFByb3BzIiwicHJvcCIsImlzTmV3IiwidmFsdWUiLCJpbnB1dCIsInZhbCIsImVtaXQiLCJldmVudE5hbWUiLCJzdWJzdHIiLCJ0b1VwcGVyQ2FzZSIsImlzQ29udGFpbmVyIiwiY2xhc3NMaXN0IiwiYWRkIiwiQXJyYXkiLCJpc0FycmF5IiwiZWxlbWVudCIsImZpbHRlciIsImNoaWxkIiwidHlwZSIsImV2ZW50IiwiZXZlbnRzIiwiYXJncyIsInVwZGF0ZUV4cHJlc3Npb25lZFByb3BlcnRpZXMiLCJpc01vdW50ZWQiLCJzZXRBdHRyaWJ1dGUiLCJlbGVtZW50V3JhcHBlciIsImZvcmNlVXBkYXRlU3R5bGUiLCJ0aGVuIiwicmVuZGVyZXIiLCJjcmVhdGVSZW5kZXJlciIsInVubW91bnQiLCJsZW5ndGgiLCJkZXN0cm95IiwicGFyZW50RWxlbWVudCIsInJlbW92ZUNoaWxkIiwiZ2V0UHJvcGVydGllcyIsImUiLCJPYmplY3QiLCJhc3NpZ24iLCJjb3ZlckNvbnRhaW5lciIsIndpZHRoIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJsZWZ0IiwidHJhbnNmb3JtIiwidG9wIiwieCIsInkiLCJ2aXNpYmlsaXR5IiwidmlzaWJsZSIsInN0eWxlTmFtZSIsImtleXMiLCJzdHlsZUV4IiwiZ2V0VmFyaWFibGVDb250ZXh0IiwidXBkYXRlUHJvcGVydGllcyIsInVwZGF0ZVByb3BzIiwic2V0U2NvcGVWYXJpYWJsZVZhbHVlcyIsInVwZGF0ZVNjb3BlVmFyaWFibGVWYWx1ZXMiLCJ1cGRhdGVkIiwiZ2V0U2NvcGVWYXJpYWJsZVZhbHVlcyIsImdldFZhcmlhYmxlVmFsdWVzIiwiZm9yY2VVcGRhdGVQcm9wcyIsImNvbnNvbGUiLCJwcm9wQmluZEtleSIsInByb3BFeCIsImhhc0V4cHJlc3Npb24iLCJpbnZva2UiLCJyZWFjdEJ5IiwidmFyaWFibGVOYW1lcyIsImNvbmZpZ1VzZVZhcmlhYmxlIiwidXNlZCIsImV4cHJlc3Npb24iLCJ2YWx1ZXMiLCJ2YXJpYWJsZU5hbWUiLCJpbmRleE9mIiwicGF5bG9hZCIsInVwZGF0ZVBhZ2VWYXJpYWJsZVZhbHVlIiwiYWN0aW9uIiwidmFyaWFibGVDb250ZXh0IiwibmV3VmFyaWFibGVWYWx1ZSIsInRhcmdldCIsImFwcGx5RGVjb3JhdGUiLCJob29rTmFtZSIsImRlY29yYXRvcnMiLCJkZWNvcmF0b3IiLCJhdHRhY2hFbEV2ZW50IiwiY29tcG9uZW50Q29uZmlnIiwic3RvcFByb3BhZ2F0aW9uIiwic3RhdHVzIiwiYWRkTWFza0xheWVyIiwiY2xhc3NOYW1lIiwiekluZGV4IiwicmVtb3ZlTWFza0xheWVyIiwicXVlcnlTZWxlY3RvciIsInRleHQiLCJjb250ZW50IiwibGF5ZXIiLCJjcmVhdGVFbGVtZW50IiwicmlnaHQiLCJib3R0b20iLCJpbm5lckhUTUwiLCJzZXRTdHlsZSIsInNldFByb3BzQ29uZmlnIiwiZmllbGQiLCJrZXlQYXRoIiwia2V5Iiwic3BsaXQiLCJ0aXRsZSIsInNldEV2ZW50c0NvbmZpZyIsInVwZGF0ZSIsImdldFN0eWxlIiwiZ2V0Q2hpbGRyZW5JZHMiLCJnZXRTbG90Q2hpbGRyZW4iLCJyZXN1bHQiLCJuIiwidHJpbSIsIm5hbm9pZCIsInBlIiwic3QiLCJ3cmFwcGVyQ2xhc3MiLCJpbml0aWFsaXplIiwicGFnZVZhcmlhYmxlVmFsdWVzIiwidmFyaWFibGVzQ29uZmlnIiwidmFyaWFibGVzIiwicGFnZUVsZW1lbnRzIiwiZWxlbWVudHMiLCJnZXRQYWdlUHJvcGVydGllcyIsImdldFZhcmlhYmxlQ29uZmlnIiwidXBkYXRlUGFnZVByb3BlcnRpZXMiLCJ1cGRhdGVSb290RWxTdHlsZSIsInVwZGF0ZVZhcmlhYmxlUmVsYXRlZCIsInVwZGF0ZVZhcmlhYmxlQ29uZmlnIiwicHYiLCJnZXRQYWdlRWxlbWVudHMiLCJkaXYiLCJhd2FpdGluZ3MiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsInZhcmlhYmxlS2V5cyIsImZyYWN0aW9uIiwiZWxlbWVudENvbmZpZyIsInJlbW92ZUVsZW1lbnQiLCJzbG90Q2hpbGQiLCJkZXRhY2hDaGlsZEVsZW1lbnQiLCJzb3VyY2VQYXJlbnRFbGVtZW50IiwiY2hpbGRFbGVtZW50IiwiaXNTbG90Iiwic2xvdFByb3AiLCJhdHRhY2hUb1BhcmVudCIsInRhcmdldFBhcmVudEVsZW1lbnQiLCJzb3VyY2VFbGVtZW50Iiwic2xvdE5hbWUiLCJnZXRQYWdlSlNPTiIsImFkZERlY29yYXRvcnMiLCJ1cGRhdGVWYXJpYWJsZUNvbmZpZ0Zyb21WYWx1ZSIsIndlYnBhY2tFeHRlcm5hbHMiLCJreSIsImxvYWRqcyIsImltcG9ydGFudCIsImV4dGVybmFsT3B0aW9ucyIsImNvbXBvbmVudENhY2hlIiwicGFja2FnZUpTT05DYWNoZSIsInBhY2thZ2VOb3RJbnN0YWxsZWQiLCJsb2FkZWRGb250cyIsImZjRXh0ZXJuYWxMb2FkZWQiLCJkZWJ1Z1BhY2thZ2VOYW1lIiwicGFja2FnZUxvYWRpbmdQcm9taXNlcyIsInJpZGdlQ29uZmlnIiwibG9hZGVyRXh0ZXJuYWxPcHRpb25zIiwic2NyaXB0TG9hZGluZ1Byb21pc2VzIiwiZXZlbnRDYWxsYmFja3MiLCJzY3JpcHRVcmxMaWJOYW1lIiwicGVsQ2FjaGVCeUxpYk5hbWUiLCJjb21wb25lbnRMb2FkaW5nIiwiTWFwIiwiZ2V0RGVidWdQYWNrYWdlIiwiZGVidWdQYWNrYWdlIiwidW5kZWZpbmVkIiwiZ2V0Iiwic2V0RXh0ZXJuYWxPcHRpb25zIiwic2V0QXBwTmFtZSIsImFwcE5hbWUiLCJzZXRQcm9qZWN0SWQiLCJwcm9qZWN0SWQiLCJzZXREZWJ1Z1VybCIsInNldERlYnVnUGFja2FnZU5hbWUiLCJnZXRTZXJ2ZVBhdGgiLCJpc1Byb2plY3QiLCJnZXRDb21wb25lbnRVcmwiLCJwYWNrYWdlTmFtZSIsImdldFBhY2thZ2VKU09OVXJsIiwiZ2V0Q29tcG9uZW50TGliTmFtZSIsInBhdGhzIiwic3RhcnRzV2l0aCIsInNwbGljZSIsImpvaW4iLCJjb21wb25lbnRVcmwiLCJjYWNoZSIsImdldENvbXBvbmVudCIsInJlc29sdmUiLCJyZWplY3QiLCJvbiIsInVybCIsImZjcCIsInNldCIsImRvTG9hZENvbXBvbmVudCIsIm5vdGlmeUNvbXBvbmVudExvYWRlZCIsInNldFBlbExvYWRGYWlsIiwiY29uZmlybVBhY2thZ2VEZXBlbmRlbmNpZXMiLCJsb2FkQ29tcG9uZW50U2NyaXB0IiwicHJlcGFyZUNvbXBvbmVudCIsIkVycm9yIiwicmVxdWlyZXMiLCJsb2FkRXh0ZXJuYWxzIiwiaW1hZ2VOYW1lUmVnZXgiLCJpY29uIiwidGVzdCIsInByZXZpZXdVcmwiLCJmYyIsImRlZmF1bHQiLCJpdGVtIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwic2NyaXB0VXJsIiwic2NyaXB0TGliTmFtZSIsImxvYWRTY3JpcHQiLCJ3ZWJwYWNrRXh0ZXJuYWxzTWVyZ2VkIiwiZ2xvYmFsRXh0ZXJuYWxDb25maWciLCJleHRlcm5hbCIsImV4dGVybmFsTW9kdWxlIiwiZXgiLCJleHRlcm5hbExpYlBhdGgiLCJleHRlcm5hbENzc1BhdGgiLCJ3YXJuIiwicmV0dXJuUHJvbWlzZSIsImJlZm9yZSIsInNjcmlwdFBhdGgiLCJzY3JpcHRFbCIsImNyb3NzT3JpZ2luIiwibG9hZEZvbnQiLCJwa2ciLCJmb250RmFjZU5hbWUiLCJmb250VXJsIiwiZm9udHMiLCJmZiIsIkZvbnRGYWNlIiwibG9hZENzcyIsImhyZWYiLCJsaW5rIiwicmVsIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzZXRQYWNrYWdlQ2FjaGUiLCJwYWNrYWdlT2JqZWN0IiwicmVsb2FkRGVidWdDYWNoZSIsImNhY2hlS2V5IiwiZmNDYWNoZSIsImluaXRGY3AiLCJnZXRQYWNrYWdlSlNPTiIsInByZWZpeFBhY2thZ2VKU09OIiwicGFja2FnZUpTT05VcmwiLCJwcmVmaXgiLCJjb20iLCJjb21wb25lbnRzIiwiUmVuZGVyZXIiLCJjb250ZXh0UHJvdmlkZXJzIiwianN4IiwiYW50ZCIsIlJlYWN0IiwiQ29uZmlnUHJvdmlkZXIiLCJwcmVmaXhDbHMiLCJmZHJlQ29uZmlnIiwiYW50ZFByZWZpeENscyIsInJlYWN0Q29udGV4dFByb3ZpZGVycyIsIkpTWENvbXBvbmVudCIsImluaXRPcHRpb24iLCJyZWYiLCJjcmVhdGVSZWYiLCJyZW5kZXJSZWYiLCJSZWFjdERPTSIsImNyZWF0ZVJvb3QiLCJyZW5kZXIiLCJnZXRSZW5kZXJJbnN0YW5jZSIsInJlYWN0SW5zdGFuY2UiLCJpIiwiY3VycmVudCIsInNldE9wdGlvbiIsIm9wdGlvbiIsImxheW91dCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJWYW5uaWxhQ29tcG9uZW50IiwiYXBwbHkiLCJsb2Rhc2hUZW1wbGF0ZSIsImxvZGFzaEF0IiwiY29tcGlsZWRUZW1wbGF0ZXMiLCJ0cGxTdHJpbmciLCJ1dGlscyIsImVuYWJsZWQiLCJmdW5jIiwiRnVuY3Rpb24iLCJtYXRjaCIsImludGVycG9sYXRlIiwidHBsU3RyaW5nQ29uIiwidHBsRnVuYyIsImVyciIsImVycjEiLCJpc1RlbXBsYXRlU3RyIiwiY3VzdG9tQWxwaGFiZXQiLCJjYW1lbENhc2UiXSwic291cmNlUm9vdCI6IiJ9