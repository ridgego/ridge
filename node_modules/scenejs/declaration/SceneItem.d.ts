import Animator from "./Animator";
import Frame from "./Frame";
import { IObject, IArrayFormat } from "@daybrush/utils";
import { NameType, AnimateElement, AnimatorState, SceneItemState, SceneItemOptions, EasingType, PlayCondition, SceneItemEvents } from "./types";
import OrderMap from "order-map";
import { InjectResult, StyledInjector } from "css-styled";
export declare function getEntries(times: number[], states: AnimatorState[]): number[][];
declare class SceneItem extends Animator<SceneItemOptions, SceneItemState, SceneItemEvents> {
    times: number[];
    items: IObject<Frame>;
    nameMap: OrderMap<string | number>;
    elements: AnimateElement[];
    styled: StyledInjector;
    styledInjector: InjectResult;
    temp: Frame;
    private needUpdate;
    private target;
    private targetFunc;
    constructor(properties?: any, options?: Partial<SceneItemOptions>);
    getDuration(): number;
    size(): number;
    setDuration(duration: number): this;
    setId(id?: number | string): this;
    set(time: any, ...args: any[]): any;
    get(time: string | number, ...args: NameType[]): any;
    getOrders(names: NameType[]): NameType[] | undefined;
    setOrders(names: NameType[], orders: NameType[]): NameType[];
    getOrderObject(): IObject<(string | number)[]>;
    setOrderObject(obj: IObject<NameType[]>): void;
    remove(time: string | number, ...args: any[]): this;
    append(item: SceneItem | IObject<any>): this;
    prepend(item: SceneItem | IObject<any>): this;
    unshift(time: number): this;
    toObject(isStartZero?: boolean): IObject<Frame>;
    setSelector(target: string | boolean | ((id: number | string) => string)): this;
    getElements(): AnimateElement[];
    setElements(target: boolean | string | AnimateElement | IArrayFormat<AnimateElement>): this;
    setElement(target: boolean | string | AnimateElement | IArrayFormat<AnimateElement>): this;
    setTarget(target: any): this;
    setCSS(time: number, properties?: string[]): this;
    setTime(time: number | string, isTick?: boolean, isParent?: boolean, parentEasing?: EasingType): this;
    update(): this;
    newFrame(time: string | number): Frame;
    setFrame(time: string | number, frame: Frame): this;
    getFrame(time: number | string, ...names: any[]): Frame;
    removeFrame(time: number | string, ...names: any[]): this;
    hasFrame(time: number | string): boolean;
    hasName(args: string[]): boolean;
    mergeFrame(time: number | string, frame: Frame): this;
    getNowFrame(time: number, parentEasing?: EasingType, isAccurate?: boolean): Frame;
    getCurrentFrame(needUpdate?: boolean, parentEasing?: EasingType): Frame;
    getComputedFrame(time: number, parentEasing?: EasingType, isAccurate?: boolean): Frame;
    load(properties?: any, options?: any): this;
    clone(): SceneItem;
    forEach(callback: (item: Frame, time: number, items: IObject<Frame>) => void): this;
    setOptions(options?: Partial<SceneItemOptions>): this;
    toCSS(playCondition?: PlayCondition, parentDuration?: number, states?: AnimatorState[]): string;
    exportCSS(playCondition?: PlayCondition, duration?: number, options?: AnimatorState[]): "" | this;
    pause(): this;
    pauseCSS(): this;
    endCSS(): this;
    end(): this;
    playCSS(isExportCSS?: boolean, playClassName?: string, properties?: object): this;
    getAnimationElement(): AnimateElement;
    addPlayClass(isPaused: boolean, playClassName?: string, properties?: object): HTMLElement | SVGElement;
    clear(): this;
    getNowValue(time: number, properties: NameType[], left?: number, right?: number, isAccurate?: boolean, easing?: EasingType, usePrevValue?: boolean): any;
    private _toKeyframes;
    private updateFrameOrders;
}
export default SceneItem;
